<div class=intro>
  <p>Le <b>code golfing</b> est une activité consistant à implémenter un algorithme avec un code source le plus court possible.</p>
  <p>De nombreux <a href=//golf.shinh.org/ target=_blank>concours</a> proposent de créer des démos JavaScript en moins de <a href=//140byt.es target=_blank>140 caractères</a>, <a href=//js1k.com target=_blank>1ko</a>, <a href=//js13kgames.com/ target=_blank>13ko</a>, <a href="http://www.pouet.net/prodlist.php?type%5B%5D=32b&type%5B%5D=64b&type%5B%5D=128b&type%5B%5D=256b&type%5B%5D=512b&type%5B%5D=1k&type%5B%5D=4k&type%5B%5D=8k&type%5B%5D=16k&type%5B%5D=32k&type%5B%5D=40k&type%5B%5D=64k&type%5B%5D=80k&type%5B%5D=96k&type%5B%5D=100k&type%5B%5D=128k&type%5B%5D=256k&type%5B%5D=artpack&type%5B%5D=bbstro&type%5B%5D=cracktro&type%5B%5D=demo&type%5B%5D=demopack&type%5B%5D=demotool&type%5B%5D=dentro&type%5B%5D=diskmag&type%5B%5D=fastdemo&type%5B%5D=game&type%5B%5D=intro&type%5B%5D=invitation&type%5B%5D=liveact&type%5B%5D=musicdisk&type%5B%5D=procedural+graphics&type%5B%5D=report&type%5B%5D=slideshow&type%5B%5D=votedisk&type%5B%5D=wild&platform%5B%5D=JavaScript&page=1" target=_blank>etc.</a></p>
  <p>Plusieurs développeurs ont des sites dédiés au code golfing JS: <a href=//aem1k.com/ target=_blank>aem1k</a>, <a href=://www.p01.org/releases/ target=_blank>p01</a>, etc.</p>
  <p>Cette page rassemble mes premières réalisations.</p>
</div>

<div class=section>
	<h2>Quelle quantité de code JavaScript peut-on exécuter en 140 caractères?</h2>
	<h3>novembre 2013</h3>
  <p>La réponse est: 190 caractères!</p>
  <p>Sur <a href=//140byt.es target=_blank>140byt.es</a>, le but est d'écrire des fonctions JavaScript qui tiennent dans un tweet, autrement dit dans 140 caractères.</p>
  <p>Jusqu'à maintenant, ces fonctions ont toujours été écrites "en clair", en caractères ASCII. Mais un tweet peut contenir 140 caractères Unicode, y compris des caractères "astraux", utilisant 4 octets.</p>
  <p>J'ai donc eu l'idée d'exploiter cet encodage (UTF-16) pour compresser du code JavaScript "trop long", et insérer ce code compressé dans une expression JavaScript capable de le décompresser et de l'exécuter, tout en respectant la limite de 140 caractères.</p>
  <p>Voici la représentation binaire d'un caractère UTF-16 "astral". Il est composé de deux moitiés ("surrogates") de 16 bits, dont les 6 premiers bits sont fixés. Les 10 derniers bits (représentés par des "x") peuvent prendre n'importe quelle valeur.</p>
  <pre>110110xx xxxxxxxx  110111xx xxxxxxxx</pre>
  <br>
  <p>Voici la représentation binaire de la chaîne "ABCD" (en ASCII). Chaque caractère est encodé sur 1 octet.<br>(En fait, 7 bits suffisent pour encoder un caractère ASCII, mais dans les encodages modernes, le 8ème bit est laissé à 0).</p>
  <pre>01000001 01000010 01000011 01000100</pre>
  <br>
  <p>L'idée est donc de n'utiliser que des caractères UTF-16 astraux, en stockant un caractère ASCII à la fin de chaque surrogate.<br>Voici la chaîne "ABCD" encodée dans 2 caractères UTF-16 (avec 2 caractères en un, on a donc une compression de 50% !):</p>
  <pre>11011000 01000001 11011100 01000010  11011000 01000011 11011100 01000100 ==> 𠑂𠱄
         |--A---|          |--B---|           |--C---|          |--D---|    (ABCD encodé)</pre>
  <br>
  <p>Voici un encodeur (de 129 caractères) permettant de faire cette compression:</p>
  <pre>z=function(b,c,a,f,e){c="";f=String.fromCharCode;for(a=0;190>a;a+=2)c+=f(55296+b[e="charCodeAt"](a))+f(56320+b[e](a+1));return c}</pre>
  <button onclick="source_encoder190.style.display='block';this.style.display='none'">Voir le code source</button>
  <pre id=source_encoder190 style="display: none">/**
* @param b: the input string (in ASCII)
* @param c, a, f: placeholders
*/
z = function(b, c, a, f){
    
  // Return string
  c="";
  
  // Shortcut for "String.fromCherCode"
  f = String.fromCharCode;
  
  // Loop on all the ASCII characters
  for(a = 0; 190 > a; a += 2)
  
    // Append an UTF-16 (two surrogates) to the return string
    c += f(0xD800 + b.charCodeAt(a)) + f(0xDC00 + b.charCodeAt(a + 1));
  
  // Return
  return c
}</pre>
  <script>compressAscii190=function(b,c,a){c="";if(b.length%2)b+=" ";f=String.fromCharCode;for(a=0;b.length>a;a+=2)c+=f(55296+b[e="charCodeAt"](a))+f(56320+b[e](a+1));return c}</script>
  <br>
  <p>Et voici le code permettant de décompresser et exécuter le code JavaScript original (merci à <a href=//twitter.com/subzey target=_blank>@subzey</a> pour son aide):</p>
  <pre>// remplacer "𠑂𠱄" par votre chaîne encodée
eval(unescape(escape("𠑂𠱄").replace(/uD./g,'')))</pre>
  <button onclick="source_decoder190.style.display='block';this.style.display='none'">Voir le code source</button>
  <pre id=source_decoder190 style="display: none">// First, we need to know how JavaScript handles escaped characters:
// ASCII characters are escaped as: %XX (XX is an hexadecimal value)
// UTF-16 surrogates are escaped as: %uYYXX (YYXX is an hexadecimal value, XX is the last byte)
// The escape() function does this, unescape() does the opposite.

// Encoded string
var encoded = "𠑂𠱄";

// Escape it
var escaped = escape(encoded); // --> "%uD841%uDC42%uD843%uDC44"

// Remove the 3 characters after each "%" ("uYY")
var replaced = escaped.replace(/uD./g,''); // --> "%41%42%43%44"

// Unescape it
var unescaped = unescape(replaced); // --> "ABCD" (the decoded string)

// Eval
eval(unescaped); // Tries to execute the decoded string.
  </pre>
  <br>
  <p>Ce décompresseur-exécuteur mesure seulement 45 caractères. On peut donc exécuter <b>190</b> ((140 - 45) x 2) caractères JS dans un seul tweet.</p>
  <br>
  <hr>
  <br>
  <p><b>Démo:</b></p>
  Code JavaScript:
  <br>
  <br>
  <textarea rows=3 id=compress>alert("Ce script mesure cent quatre-vingt-dix caractères et ne rentre hélas pas dans un tweet... Mais si on le compresse en quatre-vingt-quinze caractères unicode, cela devient possible !");</textarea>
  <br>
  <script>longueur_js = 0;</script>
  <button onclick="alert(compress.innerHTML.length + ' caractères')">1: Compter (ASCII)</button> &nbsp; > &nbsp; 
  <button onclick="eval(compress.innerHTML)">2: Exécuter</button> &nbsp; > &nbsp; 
  <button onclick="longueur_js=compress.innerHTML.length;compress.innerHTML='eval(unescape(escape(\''+compressAscii190(compress.innerHTML)+'\').replace(/uD./g,\'\')))'">3: Compresser</button> &nbsp; > &nbsp; 
  <button onclick="alert((Math.ceil(longueur_js/2)+45) + ' caractères')">4: Compter (UTF-16)</button> &nbsp; > &nbsp; 
  <button onclick="eval(compress.innerHTML)">5: Exécuter</button>
</div>

<div class=section>
	<h2>Escargot</h2>
	<h3>octobre 2013</h3>
	<p>Une fonction générant une matrice "en escargot", en 133 caractères</p>
	<pre>s=function(e,c,d,b,f,h,g){c=[[]];d=1;b=h=0;for(f=-1;e;e--){for(g=1;g<2*e;g++)g>e?b+=d:f+=d,c[b]||(c[b]=[]),c[b][f]=++h;d=-d}return c}</pre>
  <button onclick="source_escargot.style.display='block';this.style.display='none'">Voir le code source</button>
  <br>
  <pre id=source_escargot style="display:none">/**
* Snail
* @param n: the size of the matrix (n*n)
* @return: a 2D array with integers
*/

s = function(n,a,d,x,y,c,i){
  
  // a is the result matrix
  a = [[]];
  
  // d is the direction: right, bottom = 1; left, top = -1
  d = 1;
  
  // c is the counter value.
  c = 0;
  
  // x and y are the coordinates of the number in the matrix
  x = 0;
  y = -1;

  // Loop while n decrements
  for(; n; n--){

    // The two following loops are merged in the minified code:
    
    // fill n columns
    for(i = 0; i < n; i++){
      
      y += d;
      a[x][y] = ++c;
    }
    
    // fill n-1 lines 
    for(i = 0; i < n - 1; i++){
      
      x += d;
      if(!a[x]){
        a[x] = [];
      }
      a[x][y] = ++c;
    }

    // change direction
    d = -d;
  }
  
  return a;
}</pre>
  <br>
  <b>Démo</b>:
  <br>
  Taille: <input id=taille_escargot value=8 size=2> <button id=button_escargot>Générer</button>
  <script>
    snail=function(e,c,d,b,f,h,g){c=[[]];d=1;b=h=0;for(f=-1;e;e--){for(g=1;g<2*e;g++)g>e?b+=d:f+=d,c[b]||(c[b]=[]),c[b][f]=++h;d=-d}return c}
    button_escargot.onclick = function(){
      var size = parseInt(taille_escargot.value);
      if(size > 0){
        demo_escargot.style.display = "block";
        var matrix = snail(size);
        var html = "<table style='width:auto;table-layout:fixed;background:#fff' border=rules>";
        var i, j;
        for(i = 0; i < size; i++){
          html += "<tr>";
          for(j = 0; j < size; j++){
            html += "<td style='padding:5px;text-align:center'>" + matrix[i][j] + "</td>";
          }
          html += "</tr>";
        }
        html += "</table>";
        demo_escargot.innerHTML = html;
      }
    }
  </script>
  <div class=demo id=demo_escargot style="display:none"></div>
</div>

<div class=section>
	<h2>Touches enfoncées</h2>
	<h3>septembre 2013</h3>
	<p>Un moyen de savoir à tout moment si une touche du clavier est en train d'être enfoncée, en seulement 58 caractères.</p>
	<pre>k={};onkeydown=onkeyup=function(e){k[e=e.keyCode]=!k[e]}</pre>
	<p>
    Pour l'utiliser, il suffit de choisir "n" - le code d'une touche de clavier (<a href=//whatthekeycode.com target=_blank>par exemple ici</a>) et de tester k[n]. Celui-ci est vrai quand la touche en question est pressée, et faux quand elle ne l'est plus.
    <br>
    (Si elle n'a jamais été pressée, k[n] sera undefined, ce qui est considéré comme "false" dans un test.)
    <br>
    <button onclick="source_touches_enfoncees.style.display='block';this.style.display='none'">Voir le code source</button>
  <br>
  <pre id=source_touches_enfoncees style="display:none">// Initialize the global k (the array representing the keys currently pressed).
// Also works with k = [].
k = {};

// Add two event handlers to the window object:
// window.onkeydown and window.onkeyup.
// They don't need the window prefix (it's implicit)
// And they both get the same callback function
onkeydown = onkeyup = function(e){

  // The two following lines are merged in the minified code:

  // e is the event handler. let's replace it with the e.keyCode attribute
  e = e.keyCode;
  
  // Invert the value of k[e]:
  // undefined => true
  // true => false
  // false => true
  k[e] = ! k[e];

}</pre>
  <br>
  <b>Démo:</b> Voici l'état de k en temps réel. Enfoncez des touches du clavier pour le faire évoluer.
    <script>
      k=[];onkeydown=onkeyup=function(e){k[e=e.keyCode]=!k[e];demo_touches_enfoncees.innerHTML="k = ["+k+"]"}
    </script>
    <div class=demo><pre id=demo_touches_enfoncees>k = [ ]</pre></div>
  </p>
</div>

<div class=section>
	<h2>MiniGameOfLife</h2>
	<h3>septembre 2013</h3>
	<p>Un moteur de jeu de la vie en seulement 130 caractères.</p>
  <pre>g=function(f,c,g,d,e,b,h){g=[];e=[c+1,c,c-1,1];for(b=c*c;b--;g[b]=3==d||f[b]&&2==d,d=0)for(h in e)d+=f[b+e[h]]+f[b-e[h]];return g}</pre>
  <button onclick="source_miniGameOfLife.style.display='block';this.style.display='none'">Voir le code source</button>
  <br>
  <pre id=source_miniGameOfLife style="display:none">// @param s: current state of the grid
// @param d: size of the grid (d*d)
// @param n: placeholder
// @param k: placeholder
// @param m: placeholder
// @param i: placeholder
// @param j: placeholder
g = function(s, d, n, k, m, i, j){
  for(
    n = [],                           // Initialize next state
    m = [d + 1, d, d - 1, 1],         // Initialize a list of the neighbours offsets
    i = d * d;                        // For each cell
    i--;
    n[i] = k == 3 || s[i] && k == 2,  // Set next state (live if it has 3 neighbours or lives and has 2 neighbours)
    k = 0                             // Reset the count of living neighbours
  )
  for(j in m)                         // for each neighbour offset
    k += s[i + m[j]] + s[i - m[j]]    // count the living neighbours (at positions -offset and +offset)
  return(n)                           // return the next state
}</pre>
  <br>
	<b>Démo:</b> <a href=//xem.github.io/miniGameOfLife target=_blank>http://xem.github.io/miniGameOfLife</a>
</div>

<div class=section>
	<h2>MiniMinifier</h2>
	<h3>mars à septembre 2013</h3>
	<p>Un minifieur de code CSS en seulement 73 caractères. (supprime tous les commentaires et les espaces inutiles)</p>
  <pre>c.replace(/^\s|\s$|\/\*[^]*?\*\/|\s*;*([^\:\w.#'"\s*-])\s*|(:) /g,'$1$2')</pre>
  <p>Et sa version complète, en 348 caractères (supprime aussi les 0 inutiles, les unités inutiles, compresse les couleurs RGB et hexadécimales, et gère les vieux IE)</p>
  <pre>c.replace(/(\/\*[^]*?\*\/|\s)+/g,' ').replace(/([^#\d\w\(._'"-])((0)[a-z%]+|0(\.))|^ | $|[ ;]*([^\:\w.#)'" *-]) *| (\))|(:) */gi,'$1$3$4$5$6$7').replace(/rgb\((\d+),(\d+),(\d+)\)|#[a-f0-9]{6}/gi,function(h,a,b,c,i,p){if(c){h='#';p=[a,b,c];for(i in p)h+=('0'+parseInt(p[i]).toString(16)).slice(-2)}p=h[2]+h[4]+h[6];return p==h[1]+h[3]+h[5]?'#'+p:h})</pre>
	<br>
  <b>Démo:</b> <a href=//xem.github.io/miniMinifier target=_blank>http://xem.github.io/miniMinifier</a>
</div>

<div class=section>
	<h2>MiniCodeEditor</h2>
	<h3>mars 2013</h3>
	<p>Un système de sandbox HTML/CSS/JS (comme codepen ou jsfiddle) en seulement 130 caractères.<br>Il met à jour une iframe avec du code HTML, CSS et JS passé en paramètres.</p>
  <pre>function u(h,c,j,r){r.src="";r=r.contentWindow.document;r.write(h.value+"&lt;script>"+j.value+"&lt;\/script>&lt;style>"+c.value);r.close()}</pre>
  <button onclick="source_miniCodeEditor.style.display='block';this.style.display='none'">Voir le code source</button>
  <br>
  <pre id=source_miniCodeEditor style="display:none">// @param h: HTML code
// @param c: css code
// @param j: JS code
// @param r: rendering iframe
function u(h,c,j,r){
  
  // Reset the iframe
  r.src = "";
  
  // Access to the document of the iframe
  r = r.contentWindow.document;
  
  // Write in the iframe's body: the HTML, the JS in a &lt;script> tag, and the CSS in a &lt;style> tag (which is automatically closed)
  r.write(h.value + "&lt;script>" + j.value+"&lt;\/script>&lt;style>" + c.value);
  
  // Stop writing in the iframe (this stops the iframe's loading).
  r.close();
}</pre>
	<b>Page GitHub:</b> <a href=//github.com/xem/miniCodeEditor target=_blank>http://github.com/xem/miniCodeEditor</a>
  <br>
	<b>Démo:</b> <a href=//xem.github.io/miniCodeEditor target=_blank>http://xem.github.io/miniCodeEditor</a>
</div>

<div class=section>
	<h2>Manipulations binaires</h2>
	<h3>septembre 2012</h3>
	<p>
		Les opérations binaires en JavaScript sont des pièges. J'ai d'ailleurs écrit un post wtfjs à ce sujet. (<a href="http://wtfjs.com/2012/09/19/Hexadecimal-weirdness" target=_blank>lien</a>)
		<br>
    C'est pourquoi j'ai écrit une mini lib de 137 caractères qui permet de faire correctement des "left shift", "right shift", et d'extraire quelques bits d'un nombre.
    <pre>M=Math;function l(a,b){return a*M.pow(2,b)}function r(a,b){return M.floor(a/M.pow(2,b))}function b(a,b,c){return r(a,b)&M.pow(2,c-b+1)-1}</pre>
    <button onclick="source_binaire.style.display='block';this.style.display='none'">Voir le code source</button>
  <br>
  <pre id=source_binaire style="display:none">// M is a shortcut for Math
M = Math;

// Left shift
// a << b is equivalent to a * (2 ^ b)
function l(a,b){
  return a * M.pow(2, b);
}

// Right shift
// a >> b is equivalent to a / (2 ^ b)
function r(a,b){
  return M.floor(a / M.pow(2, b));
}

// Bit extraction
// returns a's bits from b to c
// i.e. the last (c - b + 1) bits of (a >> b)
function b(a,b,c){
  return r(a,b) & M.pow(2, c - b + 1) - 1;
}</pre>
	</p>
</div>