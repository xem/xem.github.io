<!doctype html>
<meta charset=utf-8>
<meta name="viewport" content="width=device-width, user-scalable=no">
<html>
<head>
<link rel=stylesheet href="../style.css?v=2022">
<title>Maxime Euzière</title>
<base target=_blank>
</head>
<body class=large>

<div class="wrapper">

<header></header>

<div id=menu></div>

<main>

<style>
table { border-spacing: 0; border-collapse: collapse; width: 100% }
th, td { padding: 5px; width: 200px }
th { background: #eee }
h4 { margin-bottom: 0; }
h1 { font-size: 30px }
h2 { font-size: 24px; line-height: 40px; }
h3 { font-size: 20px }
h4 { font-size: 18px }
h5 { font-size: 16px }
ul, ol { padding-left: 15px }
li { line-height: 25px }
pre { margin: 3px; font-size: 12px; }
pre.inline, pre.inline code { display: inline; padding: 4px 2px; background: #333; font-size: 11px;}
.math { margin: 15px 0 }
.section iframe { min-height: 400px; }
.ch10 { border: 1px solid #000 }
.ch10 * { border: none }
.ch10 hr { border-bottom: 1px solid #000 }
.ch10 td { width: 100%; vertical-align: top }
.ch10 td + td { min-width: 430px; }
.newWindow { float: right; left: -10px; position: relative; z-index: 2; padding: 5px; border: 1px solid #555; border-radius: 5px; color: #000; font-size: 20px; width: 40px; height: 40px; background: url('images/new_window.svg') no-repeat center center #def; }
.section p { line-height: 25px; marfin: 15px 0; }
.grey, .grey td, iframe { border: 3px solid #999 }
.token.comment, .token.prolog, .token.doctype, .token.cdata { color: #bbb; }
summary { cursor: pointer }
.toc li { line-height: 15px; }
.toc p { line-height: 13px; }
.demo { background: url('images/new_window.svg') no-repeat 10px center #def; padding: 10px 10px 10px 40px; border-radius: 5px; border: 2px solid #456; color: #000 }
pre a { color: #abf }

</style>

<div class=section id=webgl_guide>
<h2>WebGL guide (part 2/2): Advanced techniques</h2>
<h3>June 2020 - WIP</h3>

<!--p>(TODO: FXAA?)-->

<br><hr><br>

<h2 id="0">Introduction</h2>

<p>Welcome to the second part of my <a href="webgl-guide.html">WebGL guide</a>!
<p>I had to split the guide in two parts to embed all my demos... indeed, browsers tend to lose their WebGL contexts after 16 occurrences.
<br>Context loss can also happen when the computer goes into hibernation mode, and can be fixed by adding these two event listeners in your program:
<pre class=lang-js><code>canvas.onwebglcontextlost = e => e.preventDefault(); // make the canvas trigger onwebglcontextrestored if the context is lost
canvas.webglcontextrestored = e => { /* re-init shader, program, buffers, textures and clear color here */ }</code></pre>
<p>Anyway, this second part will show a bunch of techniques built upon the basics shown in <a href="webgl-guide.html" target=_self>part 1</a>, that I recommend reading first.
<p>In this page, to make things easier to read, I will only show the relevant lines of codes involved to produce each effect. A link to a complete, editable demo will be available when necessary.
<p>Keep in mind that most of the advanced visual effects presented here rely on the same basic principles shown in the previous parts (messing with light rays, angles, distances, sizes, reflections, projections and colors, in order to make the computer draw what we want, pixel per pixel).
<br>This also means that you can invent your own tricks! (this guide is as complete as possible, but not exhaustive).
<p>I'd like to thank again all the people and resources that helped me write this guide, and all the readers who came here thanks to JS newsletters, social networks and word of mouth.
<p>Let's get started!

<br><br><hr><br>

<h2>Table of contents</h2>

<div class=toc>
<p><b>Advanced 3D rendering</b>
<ul>
<li><a href="#1a" target="_self">Transparency and alpha blending</a> <!-- 1 demo -->
<li><a href="#1b" target="_self">Mouse interactivity</a> <!-- 3 demos -->
<li><a href="#1c" target="_self">Framebuffers and renderbuffers</a> <!-- 1 demo -->
<li><a href="#1d" target="_self">Instanced geometry</a>
</ul>

<p><b>Advanced coloring / texturing</b>
<ul>
<li><a href="#2a" target="_self">Animate, transform and wrap textures</a> <!-- 1 demo -->
<li><a href="#2b" target="_self">Mip mapping</a>
<li><a href="#2c" target="_self">Reflexions and environment mapping</a> <!-- 1 demo -->
<li><a href="#2d" target="_self">Normal / Height / Parallax / Bump mapping</a> <!-- 1 demo -->
<li><a href="#2e" target="_self">Fresnel</a>
<li><a href="#2f" target="_self">Matcaps / lit spheres</a>
<li><a href="#2g" target="_self">Cel-shading / ramp textures</a>
</ul>

<p><b>Advanced lighting</b>
<ul>
<li><a href="#3a" target="_self">Multiple light sources</a> <!-- 1 demo -->
<li><a href="#3b" target="_self">Shadows!</a> <!-- 1 demo -->
<li><a href="#3c" target="_self">360° shadows</a> <!-- 1 demo -->
<li><a href="#3d" target="_self">Penumbra and soft shadows</a> <!-- 1 demo -->
<li><a href="#3e" target="_self">Baked lighting</a>
</ul>

<p><b>Advanced display</b>
<ul>
<li><a href="#4a" target="_self">Fog</a> <!-- 1 demo -->
<li><a href="#4b" target="_self">Text</a> <!-- 1 demo -->
<li><a href="#4c" target="_self">Particles</a>
<li><a href="#4d" target="_self">Multiple passes and post-processing</a>
</ul>

<p><b>Load external 3D models</b>
<ul>
<li><a href="#5a" target="_self">.obj / .mtl files</a> <!-- 1 demo -->
<li><a href="#5b" target="_self">.fbx files</a>
<li><a href="#5c" target="_self">.gltf / .glb files</a>
<li><a href="#5d" target="_self">Others (.ply, .prwm...)</a>
</ul>

<p><b>Advanced shader manipulation</b>
<ul>
<li><a href="#6a" target="_self">Using multiple shaders</a> <!-- 1 demo -->
<li><a href="#6b" target="_self">Build shaders</a>
</ul>

<p><b>Interesting subjects to study next</b>
<ul>
<li><a href="#7a" target="_self">3D physics</a>
<li><a href="#7b" target="_self">Tessellation and decimation</a>
<li><a href="#7c" target="_self">Interpolation, animation and rigging</a>
<li><a href="#7d" target="_self">VR</a>
<li><a href="#7e" target="_self">Field of view</a>
<li><a href="#7f" target="_self">Other WebGL features</a>
<li><a href="#7g" target="_self">Raycasting and distance fields</a>
<li><a href="#7h" target="_self">Raytracing and Physics Based Rendering</a>
<li><a href="#7i" target="_self">NURBS</a>
<li><a href="#7j" target="_self">WebGPU</a>
<li><a href="#7k" target="_self">WebGL and Gamedev</a>
<li><a href="#7l" target="_self">Use WebGL to compute stuff</a>
<li><a href="#7m" target="_self">Visualizing the camera</a>
</ul>
</div>

<br><hr><br>
<h2>Advanced 3D rendering</h2>
<br><hr>

<h4 id=1a>Transparency and alpha blending</h4>

<p>There are many ways to handle transparency in a WebGL program:
<ul>
<li>First, remember that the HTML <b>&lt;canvas></b> is transparent by default, and can absolutely stay like that if it doesn't get a CSS background or a clear color (as we saw in <a href="webgl-guide.html#2c">part 1</a>).
<li>The fragment shader can set a rgba value for each pixel it renders. By default, when lowering the "a", it will blend with the canvas's background (not its clear color):
<br>
<br><img src="images/webgl-guide/alpha1.png" width=750>
<br>
<li>In order to blend a triangle it with the clear color (or the elements behind it), you need to call two new functions:
<pre class=lang-js><code>gl.enable(gl.BLEND); // enable alpha blending
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // specify how alpha must blend: fragment color * alpha + clear color * (1 - alpha)</code></pre>
<img src="images/webgl-guide/alpha2.png" width=750>
<p><a href="../../webgl-guide/editor/?demo=17/triangle" class=demo>OPEN FULL DEMO</a>
<br><br>
<li>If you want to use a PNG image with transparency as a texture, many solutions are possible, but the most convenient one is to enable alpha premultiplication when loading the image:
<pre class=lang-js><code>gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);</code></pre>
<br>
If premultiplication is not enabled, the transparent pixels will become white and the semi-transparent ones will become fully opaque:
<br>
<br><img src="images/webgl-guide/alpha3.png" width=700>

<p><a href="../../webgl-guide/editor/?demo=17/png" class=demo>OPEN FULL DEMO</a>
<br><br>
<li>Finally, you may want to give some transparency to entire objects. To do that, you can assign a RGBA color to each vertex, with A &lt; 1.0.
<br>Then, enable WegGL's alpha blending with <pre class="inline lang-js"><code>gl.enable(gl.BLEND);</code></pre> and <pre class="inline lang-js"><code>gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);</code></pre> as we did earlier.
<br>If you're drawing an object (like a cube) with transparency, you also need to disable <b>gl.DEPTH_TEST</b>, so that the front faces don't block the other faces from being drawn
<br>If your scene contains a mix of opaque and transparent objects, you'll need to draw all your opaque objects first, then disable depth test with <pre class="inline lang-js"><code>gl.disable(gl.DEPTH_TEST);</code></pre>, then draw all your objects with transparency, then re-enable depth test with <pre class="inline lang-js"><code>gl.enable(gl.DEPTH_TEST);</code></pre> for the next frame.
</ul>

<table class=ch10>
<tr>
<td>
<pre><code class="lang-js">// Set rgba colors for each face's vertices
var colors = new Float32Array([
  0.5, 0.5, 1.0, 0.3,   0.5, 0.5, 1.0, 0.3,
  0.5, 0.5, 1.0, 0.3,   0.5, 0.5, 1.0, 0.3, // front
  0.5, 1.0, 0.5, 0.3,   0.5, 1.0, 0.5, 0.3,
  0.5, 1.0, 0.5, 0.3,   0.5, 1.0, 0.5, 0.3, // right
  1.0, 0.5, 0.5, 0.3,   1.0, 0.5, 0.5, 0.3,
  1.0, 0.5, 0.5, 0.3,   1.0, 0.5, 0.5, 0.3, // up
  1.0, 1.0, 0.5, 0.3,   1.0, 1.0, 0.5, 0.3,
  1.0, 1.0, 0.5, 0.3,   1.0, 1.0, 0.5, 0.3, // left
  1.0, 1.0, 1.0, 0.3,   1.0, 1.0, 1.0, 0.3,
  1.0, 1.0, 1.0, 0.3,   1.0, 1.0, 1.0, 0.3, // down
  0.5, 1.0, 1.0, 0.3,   0.5, 1.0, 1.0, 0.3,
  0.5, 1.0, 1.0, 0.3,   0.5, 1.0, 1.0, 0.3  // back
]);

(...)

// Pass 4 values to the color attribute instead of 3
buffer(gl, colors, program, 'color', 4, gl.FLOAT);

(...)

// Set the clear color
gl.clearColor(0.0, 0.0, 0.0, 1.0);

// Enable alpha blending
gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

(...)

// Clear
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

// Draw opaque objects here (if any)
// (...)

// Disable depth test
gl.disable(gl.DEPTH_TEST);

// Draw semi-transparent objects here (if any)
gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);

// Reenable depth test for next frame
gl.enable(gl.DEPTH_TEST);

</code></pre>
<td>
<iframe width=430 height=430 style="max-width:420px;" src="../../webgl-guide/17/cube"></iframe>
<br>
<a class=newWindow title="Open in a new window" href="../../webgl-guide/editor/?demo=17/cube">
</table>

<br><br><hr><br>

<h4 id=1b>Mouse interactivity</h4>

<p><b>Technique 1: Select a 3D item with the mouse</b>

<p>Here's the simple (and a bit hacky) way:
<ul>
<li>When the canvas is clicked, color each object in the scene with a different flat color (for example, a different shade of red).
<li>Then read the pixel color where the mouse is clicked and find the corresponding object.
<li>Then, immediately repaint every object with their correct color / texture / lighting so that the hack doesn't have time to appear on screen.
</ul>
This technique can be used for an object (like a cube), or a face, or a single triangle, depending on your needs!

<p>
<table class=ch10>
<tr>
<td>
<pre><code class="lang-js">var vshader = `
// (...)
uniform float objectNumber; // 1.0 - 255.0
void main() {
  gl_Position = mvp * pos;
  
  // (...)
  
  // On click, draw the shape with a flat color
  if(objectNumber){
    v_col = vec4(objectNumber, 0.0, 0.0, 1.0);
  }
  
  // Else, draw normally
  else {
    v_col = col;
  }
}`;

// (...)

canvas.onclick = e => {
  var x = e.clientX - canvas.offsetLeft;
  var y = e.clientY - canvas.offsetTop;
  var picked = false;
  
  // Draw each object with a different shade of red
  for(var i in myObjects){
    gl.uniform1f(objectNumber, i);
    draw(...);
  }
  
  // Read pixel at the clicked position
  var pixel = new Uint8Array(4);
  gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

  // Do something with the red value of the pixel
  alert("object " + pixels[0] + " clicked");
  
  // Disable hack and rerender everything normally
  gl.uniform1f(objectNumber, 0);
  for(i in myObjects){
    draw(...);
  }
}</code></pre>
<td>
<iframe width=430 height=430 style="max-width:420px;" src="https://xem.github.io/webgl-guide/book/ch10/PickObject.html"></iframe>
<br>Click the cube to trigger an alert

<br><br><hr>

<iframe width=430 height=430 style="max-width:420px;" src="https://xem.github.io/webgl-guide/book/ch10/PickFace.html"></iframe>
<br>Click a face of the cube to paint it in white

</table>

<p>A less hacky way consists in computing the intersection between the vector starting from the mouse and the triangles in your scene to see which one is clicked (more info <a href="http://www.3dkingdoms.com/selection.html#ray">on 3Dkingdoms</a>).

<br><br>

<p><b>Technique 2: rotate a cube with the mouse (easy)</b>

<ul>
<li>Detect when the mouse is clicked.
<li>Update the cube's Y angle when the mouse is clicked and moves horizontally.
<li>Update the cube's X angle when the mouse is clicked and moves vertically.
</ul>

<table class=ch10>
<tr>
<td>

<pre><code class="lang-js">canvas.onmousedown = e => {
  lastX = e.clientX;
  lastY = e.clientY;
  dragging = true;
};

canvas.onmouseup = e => {
  dragging = false;
};

canvas.onmousemove = e => {
  var x = e.clientX;
  var y = e.clientY;

  if(dragging){
    
    // Set angles
    dx = (y - lastY) * 100 / canvas.height;
    dy = (x - lastX) * 100 / canvas.width;
    
    rx += dx;
    ry += dy;
    
    // Remember mouse position
    lastX = x;
    lastY = y;
    
    // Draw the modified cube
    draw();
    
    // ... set the model, mvp and inverseTransform matrices ...
    
    gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_SHORT, 0);
  }
};</code></pre>

<td>

<iframe width=430 height=430 style="max-width:420px;" src="../../webgl-guide/18/rotate"></iframe>

<br>Rotate the cube with the mouse

<br><a class=newWindow title="Open in a new window" href="../../webgl-guide/editor/?demo=18/rotate"></a>

</table>

<br><br>

<b>Technique 3: rotate a cube with the mouse (advanced)</b>

<p>In the demo above, you may have remarked that the cube rotation is wrong when its vertical angle is too big.
<br>Indeed, When the vertical angle is, for example, 180 degrees, all the cube will be upside-down, and the horizontal rotation performed first will be inversed compared to the mouse's direction:
<br><br><img src="images/webgl-guide/drag.gif" width=350>

<p>This problem is present in most 3D tutorials and libraries out there, and is generally "fixed" (hidden) by preventing the vertical angle to go beyond 45 degrees.
<br>Fortunately, a real solution exists! <b>Kevin Chapelier</b> implemented it in his <a href="http://www.kchapelier.com/txlkwxlker/sphere.html">sphere demo</a> and explained it to me:
<p>First, every time the cube rotates, instead of rotating along the X axis then along the Y axis, make it rotate along a specifix axis, perpendicular to mouse movement:
<br><br><img src="images/webgl-guide/custom-axis.png" width=1200>
<p>So far, we didn't solve anything... but introducing this custom rotation axis is very important.
<br>Indeed, it is possible to inverse the rotation that has been made by the cube so far, and apply this inverse transformation to our custom axis.
<br>This may sound a bit strange, but it does something pretty awesome:
<br>it virtually cancels all the previous rotations made along this axis, in order to perform the next bit of rotation as if the cube had never rotated before:

<table class=ch10>
<tr>
<td>

<pre><code class="lang-js">canvas.onmousedown = e => {
  lastX = e.clientX;
  lastY = e.clientY;
  dragging = true;
};

canvas.onmouseup = e => {
  dragging = false;
};

canvas.onmousemove = e => {
  var x = e.clientX;
  var y = e.clientY;
  if(dragging){
    
    // Set angles
    dx = (y - lastY) * 100 / canvas.height;
    dy = (x - lastX) * 100 / canvas.width;

    // Compute rotation axis (perpendicular to mouse movement)
    axis[0] = dx;
    axis[1] = dy;
    axis[2] = 0;

    // Inverse the rotation that has been done so far
    inverseRotation = (new DOMMatrix(modelMatrix)).invertSelf();
    
    // Apply the inverse rotation to the rotation axis
    axis = axisTransformMatrix(axis, inverseRotation);
    
    // Compute the new rotation matrix "deltaRotation" along the axis
    deltaRotation = fromRotation(axis, Math.hypot(dx, dy) / 100);

    // Compute the rotation: rotation * deltaRotation
    if(deltaRotation){
      modelMatrix.multiplySelf(deltaRotation);
    }
    
    // Remember mouse position
    lastX = x;
    lastY = y;
    
    // ... set the model, mvp and inverseTransform matrices ...
    
    gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_SHORT, 0);
  }
};</code></pre>

<td>

<iframe width=430 height=430 style="max-width:420px;" src="../../webgl-guide/18/fixed"></iframe>

<br>Rotate the cube with the mouse

<br><a class=newWindow title="Open in a new window" href="../../webgl-guide/editor/?demo=18/fixed"></a>

</table>

<p>As a result, the cube can now follow the mouse in every direction:
<br><br><img src="images/webgl-guide/drag2.gif" width=350>
<br>
<p>New functions added in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/matrix.js">matrix.js</a>:

<pre class=lang-js><code>// Create a matrix representing a rotation around an arbitrary axis [x, y, z]
fromRotation = (axis, angle) => {

  var x = axis[0], y = axis[1], z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  
  if (len == 0) return null;

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(angle);
  c = Math.cos(angle);
  t = 1 - c;

  return new Float32Array([
    x * x * t + c,      y * x * t + z * s,  z * x * t - y * s,   0,
    x * y * t - z * s,  y * y * t + c,      z * y * t + x * s,   0,
    x * z * t + y * s,  y * z * t - x * s,  z * z * t + c,       0,
    0, 0, 0, 1
  ]);
};

// Apply a matrix transformation to a custom axis
transformMat4 = (a, m) => {
  let x = a[0],
    y = a[1],
    z = a[2];
  let w = (m[3] * x + m[7] * y + m[11] * z + m[15])|| 1.0;
  
  return new Float32Array([
    (m[0] * x + m[4] * y + m[8] * z + m[12]) / w,
    (m[1] * x + m[5] * y + m[9] * z + m[13]) / w,
    (m[2] * x + m[6] * y + m[10] * z + m[14]) / w
  ]);
}</code></pre>

<br><br><hr><br>

<h4 id=1c>Framebuffers and renderbuffers</h4>

<p>Until now, we've used the color and depth buffers to draw 3D content on the WebGL canvas. It is also possible to bypass this default target to perform <b>offscreen rendering</b>.
<br>This can be done by creating <b>a framebuffer object</b>, which, in turn, writes the image data in a <b>texture object</b>, and the depth data in a <b>renderbuffer object</b>.
<br>The texture object can be used as if it was loaded from an image file, and the renderbuffer object can be used to cast shadows, as we'll see in the <a href="#3b">following chapters</a>.
<br><br><img src="images/webgl-guide/framebuffer.png" width=700>

<p>Here's an example of 3D cube rendered as a texture and applied on a quad.
<br>You can see that only one program and one pair of shaders is present in the code,
<br>that's because they're generic enough to be used by both the textured cube and the textured quad, even though each of them uses different meshes, uv and mvp matrices.  
<br>However, it's totally possible to write two programs and two pairs of shaders (one for the offscreen texture, and another for the canvas) !

<table class=ch10>
<tr>
<td>
<pre><code class="lang-js">(...)
var OFFSCREEN_WIDTH = 256;
var OFFSCREEN_HEIGHT = 256;
var fbo = gl.createFramebuffer();
var texture = gl.createTexture();
var viewProjMatrixFBO = identity();

(...)

framebuffer.texture = texture;
depthBuffer = gl.createRenderbuffer();
gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, OFFSCREEN_WIDTH, OFFSCREEN_HEIGHT);
gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,bgl.TEXTURE_2D, texture, 0);
gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);
cameraMatrix = perspective({fovy: deg2rad(30), aspect: OFFSCREEN_WIDTH/OFFSCREEN_HEIGHT, near: 1, far: 100});

// Transform camera matrix
// Draw something in the framebuffer
// Draw a plane with this texture

(...)</code></pre>
<td>
<iframe width=430 height=430 style="max-width:420px;" src="https://xem.github.io/webgl-guide/book/ch10/FramebufferObject.html"></iframe>

<br><a class=newWindow title="Open in a new window" href="https://xem.github.io/webgl-guide/book/ch10/FramebufferObject.html"></a>

</table>


<br><br><hr><br>
<h4 id=2a>Instanced geometry</h4>

<p>todo

<br><br><hr><br>
<h2>Advanced coloring / texturing</h2>
<br><hr><br>

<h4 id=2a>Animate, transform and wrap texturess</h4>
<p>todo (more info <a href="http://learnwebgl.brown37.net/10_surface_properties/texture_mapping_transforms.html">here</a>)


<h4 id=2b>Mip mapping</h4>
<p>todo


<h4 id=2c>Reflexions and environment mapping</h4>
<p>todo (more info <a href="https://webglfundamentals.org/webgl/lessons/webgl-environment-maps.html">here</a>)


<h4 id=2d>Normal / Height / Parallax / Bump mapping</h4>
<p>todo (more info <a href="http://learnwebgl.brown37.net/10_surface_properties/other_surface_manipulators.html">here</a> & <a href="https://apoorvaj.io/exploring-bump-mapping-with-webgl/">here</a>)


<h4 id=2e>Fresnel</h4>
<p>todo


<h4 id=2f>Matcaps / lit spheres</h4>
<p>todo

<h4 id=2g>Cel-shading / ramp textures</h4>
<p>todo

<br><br><hr><br>
<h2>Advanced lighting</h2>
<br><hr><br>

<h4 id=3a>Multiple light sources</h4>
<p>todo (more info <a href="http://learnwebgl.brown37.net/09_lights/lights_other_models.html">here</a>)

<br><br><hr><br>

<h4 id=3b>Shadows!</h4>

<p>Displaying shadows consists in rendering with a darker color the objects that are hidden from the light source by another object.
<p>It's a bit tricky because it involves many concepts introduced in the previous chapters (shading, depth buffer, multiple shaders, ...)
<ul>
<li>First, you need to consider a virtual camera placed at the same position as the light source. Everything you can see will be in the light, everything you can <b>not</b> see will be in the shadow.
<li>To implement that, you need a first pair of shaders that computes the distances between the light source and the scene's fragments (by computing a depth buffer from this virtual camera),
<br>and a second pair of shaders that uses these results to draw the scene from the "real" camera position.
<li>To pass this demth buffer between the two pairs of shaders, a texture can be used. In this context, it's called a <b>shadow map</b>.
<li>For now, the depth will be stored in the R value of the shadow map's RGBA pixels, which is a 8 bit integer.
<li>All the depths between the near and far clipping planes are normalized (placed in the range [0:1]), and will be multiplied by 256 to be stored in a 8-bit value.
<li>These shadow map's depth values will be compared to real-world distances, so a small offset a bit higher than 1/256 (0.005) is added to avoid rounding errors's <a href="images/webgl-guide/bands.jpg">Mach bands</a>.
<li>In this example, fragments that are not the closest to the light source (i.e. in the shadow) will be drawn with 70% of their RGB colors instead of 100%.
</ul>

<table class=ch10>
<tr>
<td>
<pre style="font-size:12px"><code class="lang-js">shadow_vshader = `
void main() {
 gl_Position = u_MvpMatrix * pos;
}`;

shadow_fshader = `
void main() {
 gl_FragColor = vec4(gl_FragCoord.z, 0.0, 0.0, 0.0);
};

vshader = `
(...)
v_PositionFromLight = u_MvpMatrixFromLight * pos;
`;

fshader = `
uniform sampler2D u_ShadowMap;
varying vec4 v_PositionFromLight;
varying vec4 v_Color;
void main() {

  // Retrieve shadow map texel and depth encoded inside it
  vec3 shadowCoord = (v_PositionFromLight.xyz/v_PositionFromLight.w)/2.0+0.5;
  vec4 rgbaDepth = texture2D(u_ShadowMap, shadowCoord.xy);
  float depth = rgbaDepth.r;
  
  // Render shadowed fragments 30% darker
  float visibility = (shadowCoord.z>depth+0.005)?0.7:1.0;
  gl_FragColor = vec4(v_Color.rgb*visibility,v_Color.a);
}
`;

var OFFSCREEN_WIDTH = 1024, OFFSCREEN_HEIGHT = 1024;
var LIGHT_X = 0, LIGHT_Y = 7, LIGHT_Z = 2;

(...)

var shadowProgram = createProgram(gl, SHADOW_VSHADER_SOURCE, SHADOW_FSHADER_SOURCE);
var normalProgram = createProgram(gl, VSHADER_SOURCE, FSHADER_SOURCE);

(...)

var fbo = initFramebufferObject(gl);
gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, fbo.texture);

(...)

var viewProjMatrixFromLight = perspective({fov: 70, ratio: OFFSCREEN_WIDTH/OFFSCREEN_HEIGHT, near: 1, far: 100);
viewProjMatrixFromLight = lookAt(viewProjMatrixFromLight, LIGHT_X, LIGHT_Y, LIGHT_Z, 0, 0, 0);

(...)

var mvpMatrixFromLight_t; // For triangle
var mvpMatrixFromLight_p; // For plane

setInterval(() => {

  // Shadow map generation
  gl.useProgram(shadowProgram);
  
  // Draw the triangle and the plane
  drawTriangle(gl, shadowProgram, triangle, currentAngle, viewProjMatrixFromLight);
  mvpMatrixFromLight_t = new DOMMatrix(g_mvpMatrix); // Used later
  drawPlane(gl, shadowProgram, plane, viewProjMatrixFromLight);
  mvpMatrixFromLight_p = new DOMMatrix(g_mvpMatrix); // Used later
  
  // Change the drawing destination to color buffer
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  
  // Regular drawing
  gl.useProgram(normalProgram);
  gl.uniform1i(normalProgram.u_ShadowMap, 0); // Pass gl.TEXTURE0
  gl.uniformMatrix4fv(normalProgram.u_MvpMatrixFromLight, false, mvpMatrixFromLight_t.toFloat32Array());
  drawTriangle(gl, normalProgram, triangle, currentAngle, viewProjMatrix.toFloat32Array());
  gl.uniformMatrix4fv(normalProgram.u_MvpMatrixFromLight, false, mvpMatrixFromLight_p.toFloat32Array());
  drawPlane(gl, normalProgram, plane, viewProjMatrix);
}, 33);
</code></pre>
<td>
<iframe width=430 height=430 style="max-width:420px;" src="https://xem.github.io/webgl-guide/book/ch10/Shadow.html"></iframe>
</table>

<ul>
<li>This 8-bit shadow only works for small scenes where the light is close to the scene's objects.
<li>A solution consists in using the four RGBA components of the texture map to store the distance, instead of just R, for a 32-bit precision:
<br>
<br><img src="images/webgl-guide/rgba.jpg" width=550>
<li>The rounding offset can now be lowered to 0.0015 (a bit above 1/(2<sup>32</sup>)) 
</ul>

<table class=ch10>
<tr>
<td>
<pre><code class="lang-js">
var shadow_fshader = `
  (...)
  const vec4 bitShift = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);
  const vec4 bitMask = vec4(1.0/256.0, 1.0/256.0, 1.0/256.0, 0.0);
  vec4 rgbaDepth = fract(gl_FragCoord.z * bitShift);
  rgbaDepth -= rgbaDepth.gbaa * bitMask;
  gl_FragColor = rgbaDepth;
`;
var fshader = `
  (...)
  float unpackDepth(const in vec4 rgbaDepth) {
    const vec4 bitShift = vec4(1.0, 1.0/256.0, 1.0/(256.0 * 256.0), 1.0/(256.0 * 256.0 * 256.0));
    float depth = dot(rgbaDepth, bitShift);
    return depth;
  }
  void main() {
    vec3 shadowCoord = (v_PositionFromLight.xyz / v_PositionFromLight.w)/2.0 + 0.5;
    vec4 rgbaDepth = texture2D(u_ShadowMap, shadowCoord.xy);
    float depth = unpackDepth(rgbaDepth);
    float visibility = (shadowCoord.z > depth + 0.0015)? 0.7:1.0;
    gl_FragColor = vec4(v_Color.rgb * visibility, v_Color.a);
  };
`
</code></pre>
</table>

<br><br><hr><br>

<h4 id=3c>360° shadows</h4>
<p>todo


<h4 id=3d>Penumbra and soft shadows</h4>
<p>todo


<h4 id=3e>Baked lighting</h4>

<p><b>Baked lighting</b> was an optimization used in early 3D games, where real-time computations were very CPU-intensive.
<br>The lights, shadings and shadows were often precomputed or drawn by artists during the game development and displayed as textures to save resources.
<br>Famous example from Zelda Wind Waker on Gamecube: 
<br><br><img src="images/webgl-guide/baked.jpg" width=700>


<br><br><hr><br>
<h2>Advanced display</h2>
<br><hr><br>

<h4 id="4a">Fog</h4>

<ul>
<li>Fog will take effect linearly between a near point (where the fog is fully transparent) and a far point (where the fog is fully opaque).
<li>The vertex shader must know the position of the camera to compute a varying distance between the camera and each vertex.
<li>Using this varying distance, the fragment shader knows the distance between the camera and each fragment.
<br>
<br>
<img src="images/webgl-guide/fog.png">
<br>Fortunately, the native GLSL methods <b>distance()</b>, <b>clamp()</b> and <b>mix()</b> simplify the shader's implementation.
<li>The WebGL canvas context's clear color is equal to the fog's color when it's fully opaque.
</ul>

<table class=ch10>
<tr>
<td>
<pre><code class="lang-js">var vshader = `
// (...)
uniform vec4 camera;
varying float v_dist;
void main() {

  // (...)
  
  v_dist = distance(modelMatrix * pos, camera);
}`;

var fshader = `
// (...)
uniform vec3 fogColor;
uniform vec2 fogDist; // near / far
void main() {

  // (...)
  
  // Compute fog factor
  float fogFactor = clamp((fogDist.y - v_dist) / (fogDist.y - fogDist.x), 0.0, 1.0);
  
  // Include fog factor in the color
  gl_FragColor = vec4(mix(fogColor, vec3(col), fogFactor), 1.0);
}`;

var fogColor = [0.137, 0.231, 0.423];
gl.uniform3fv(gl.getUniformLocation(gl.program, 'fogColor'), fogColor);
gl.uniform2fv(gl.getUniformLocation(gl.program, 'fogDist'), [55, 80]);
gl.uniform4fv(gl.getUniformLocation(gl.program, 'u_Eye'), [25, 65, 35, 1.0]);

(...)

gl.clearColor(fogColor[0], fogColor[1], fogColor[2], 1.0);

</code></pre>
<td>
<iframe width=430 height=500 style="max-width:420px;min-height:500px;" src="https://xem.github.io/webgl-guide/book/ch10/Fog.html"></iframe>
</table>

<p>To simplify, you can also use <b>v_dist = gl_Position.w;</b> in the vertex shader, as it is a nice approximation of the distance between the camera and the vertex.
<br>
(see <a href="https://xem.github.io/webgl-guide/book/ch10/Fog_w.html">the book's "fog_w" demo</a> for more info)

<br><br><hr><br>
<h4 id="4b">Text</h4>

<p>WebGL can't display text natively on screen.
<br>We have to cheat a little if we want to display text in our scene...

<p><b>1) Superpose a HTML div over the WebGL canvas</b>

<p>This approach is recommended if you want to display fixed informations on top of the scene (like a game's HUD).
<br>However, if you want to align the text to a specific point in the scene (like a vertex), the div's position can be computed in JavaScript.
<br>Some examples are available on <a href="https://webglfundamentals.org/webgl/lessons/webgl-text-html.html">Webglfundamentals</a>.

<p><table style="border: 1px solid;width:750px"><tr>
<td style="width:450px">
<pre class="language-html"><code>&lt;canvas id="canvas" width=400 height=400>&lt;/canvas>
&lt;div id="text">Hello World&lt;/div>
&lt;style>
#text {
  font-size: 30px;
  font-family: arial;
  color: #fff;
  text-shadow: 0 0 2px 2px #000;
  position: absolute;
  top: 250px;
  left: 130px;
}
&lt;/style></code></pre>
<td style="width:300px"><a href="../../webgl-guide/editor/?demo=7/text-html"><img src="images/webgl-guide/text-html.png" width=290></a>
</table>


<br>
<p><b>2) Place text inside the scene</b>
<p>In order to have text appear in the scene and be translated, rotated, scaled, overlap or be overlapped by other elements, it needs to be put into a texture, and applied on a polygon.
<br>To do that, you can either create a texture with all the alphabet and make WebGL draw the text letter by letter, or simply draw the text on an image or a 2D canvas and use it as a texture:

<p><table style="border: 1px solid; width: 1000px"><tr>
<td style="width:700px">
<pre class="language-html"><code>&lt;canvas id="canvas2d" width=256 height=256 hidden>&lt;/canvas>
&lt;script>
// 2D canvas context
var ctx = canvas2d.getContext("2d");

// Render text
ctx.fillStyle = "#fff";
ctx.fillRect(0, 0, 256, 256);
ctx.fillStyle = "#00F";
ctx.font = "30px Arial";
ctx.fillText("Hello WebGL", 30, 200);

// ...

// Set a 2D texture
var sampler = gl.getUniformLocation(program, 'sampler');
var texture = gl.createTexture();
gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas2d);

// ...

gl.drawArrays(gl.TRIANGLE_STRIP, 0, n); // Draw the quad

&lt;/script></code></pre>
<td style="width:300px"><a href="../../webgl-guide/editor/?demo=7/text-canvas"><img src="images/webgl-guide/text-canvas.png" width=290></a>
(click for full demo)
</table>

<br>
<p>NB: other approaches are available on <a href="https://css-tricks.com/techniques-for-rendering-text-with-webgl/">CSS-tricks</a> and WebGLFundamentals <a href="https://webglfundamentals.org/webgl/lessons/webgl-text-texture.html">here</a> and <a href="https://webglfundamentals.org/webgl/lessons/webgl-text-glyphs.html">here</a>.

<br><br><hr><br>
<h4 id="4c">Particles</h4>

<p>todo

<br><br><hr><br>
<h4 id="4d">Multiple passes and post-processing</h4>

<p>todo

<br><br><hr><br>
<h2>Load external 3D models</h2>
<br><hr><br>

<h4 id=5a>.obj / .mtl files</h4>

<br><br><img src="images/webgl-guide/objmtl.gif" width=400>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file">Wavefront OBJ</a> is a popular and simple 3D model file format, it contains text and can be exported by free tools like Blender.
<li>It contains the definitions of vertices, vertex normals, texture UV coordinates for each vertex, and faces organized in objects and groups.
<li>A companion MTL file is used to define the material properties of each object or group (color, opacity, texture, ...).
<li>Below are described the most important features of these file formats, and all the traps and tricks I found while writing my own parser.
</ul>
<p>OBJ file content:
<pre style="max-height:none" class="language-js"><b># List of geometric vertices (x, y, z, [w], [r], [g], [b]).
# w is optional and defaults to 1.0. r,g,b are optional and their values are between 0 and 1.
# Some 3D softwares export the vertices RGB colors after the x/y/z or x/y/z/w coordinates,
# so if a line contains 6 floats, it's x/y/z/r/g/b. If it contains 7, it's x/y/z/w/r/g/b.
# Note that this is the only way to declare colors per-vertex, since materials can only be applied to entire polygons.
# It's not guaranteed that all the lines have the same number of arguments.
# Sometimes, due to exporting errors, all the vertices are offseted (ex: the object is placed too high and every Y value is > 10).
# Depending on your needs, it may be interesting to bring the first vertex back to [0,0,0] and offset all the other vertices accordingly.</b>
v 0.123 0.234 0.345
v 0.123 0.234 0.345 1.0
v 0.123 0.234 0.345 0.456 0.567 0.678
v 0.123 0.234 0.345 1.0 0.456 0.567 0.678
v ...

<b># List of texture coordinates (u, [v], [w]), between 0 and 1. v and w are optional and default to 0.
# v is usually set (without it, 2D textures wouldn't work), but w is specific to advanced rendering techniques and almost never used.
# If none of the file's objects are textured, there won't be any "vt" lines.</b>
vt 0.500 1
vt ...

<b># List of normals (x, y, z). Some 3D editors don't normalize them, so make sure to always call normalize() in your shaders.
# If they're implicit (not present in the file), and if you want to light/shade your model, you'll need to compute them like this:
# for a triangle A, B, C (in counterclockwise order), the face normal is equal to:
# vn = AB . BC = [yAB*zBC – zAB*yBC, zAB*xBC – xAB*zBC, xAB*yBC – yAB*xBC]</b>
vn 0.707 0.000 0.707
vn ...

<b># Polygonal faces (triangles, quads, and polygons with more than 4 sides can be mixed here).
# Allowed forms:
# - "vertex" indices
# - "vertex/texture" indices
# - "vertex/texture/normal" indices
# - "vertex//normal" indices
# Warning! Indices start at 1, not 0. The values need to be decremented to be used in a WebGL index buffer.
# Warning #2! in WebGL you can't have 3 sets of data and 3 sets of indices, so when parsing mixed indices (in the form a/b/c d/e/f g/h/i),
# you'll need to reorganize the data in either 3 non-indexed buffers, or in 3 buffers using the same indices.
# Also, to be displayed with WebGL, quads and other polygons (anything with more than 3 sides) must be converted to triangles:
# (For n-edge polygons, each triangle is of the form [0, i, i+1] for i=1..n-2. See <a href="https://stackoverflow.com/a/23724231">this StackOverflow post</a> for more info).
# The vertices order is counter-clockwise by default, which helps recomputing implicit normals properly.</b>
f 1 2 3
f 1 2 3 4
f 3/1 4/2 5/3
f 6/4/1 3/5/3 7/6/5
f 7//1 8//2 9//3
f ...

<b># Faces can be gathered in objects and groups (both are optional).
# Objects can contain groups, but groups can also exist without parent object.
# It may be a good idea to always force the creation of a default object and group when parsing an OBJ file, for consistency.
# Everything that follows an object definition belongs to this object until a new object starts.
# Everything that follows a group definition belongs to this group until a new object or group starts.
# Each group generally requires a new pair of shaders to be rendered, as they generally use different colors, textures, shininess, transparency, etc)</b>
o myObject
g myGroup1
f 1 2 3
...
g myGroup2
f 4 5 6
...

<b># Smooth shading can be enabled or disabled per object or group.
# When enabled, shading may be computed per fragment. When disabled, it may be computed per vertex or per face.
# It's enabled by default for every object, and inherited by default for every group.
# 1 / on, and 0 / off are equivalent.
# If the value of s changes inside a group, a new group should be created, to compute normals separately.
# 's' can also be used by some 3D softwares to define smoothing groups, with numbers > 0.
# All the groups with the same value should be smoothed together when the vertex normals are recomputed.
# It's quite rare though, so you can consider that anything different than '0' or 'off' is 'on'.</b>
s 1
s on

s 0
s off

<b># Load a material file and use one or many materials defined inside it.
# Many 'mtllib' lines may exist in the same obj file (in general there's only one).
# If a material has the same name in different mtl files, the last one loaded overwrites previous occurrences.
# If the material changes within a group, a new group should be created, so WebGL can render both separately.</b>
mtllib material.mtl
usemtl material1
# all the following elements will use material1 until another usemtl is reached.
...
 
usemtl material2
# all the following elements will use material2 until another usemtl is reached.
...</pre>

<p>MTL file content:
<pre style="max-height:none" class="language-js">
<b># Define a material named material1.</b>
newmtl material1

<b># All the following properties are optional. Most materials only have one color or one texture map.
# Whether it's called color or lighting, the implementation is the same.</b>

<b># Ambient color (RGB, each channel between 0 and 1).</b>
Ka 1.000 1.000 1.000

<b># Diffuse color.</b>
Kd 1.000 1.000 1.000

<b># Specular color + specular exponent.</b>
Ks 0.000 0.000 0.000     # black (off)
Ns 10.000                # shininess, between 0 and 1000

<b># Transparency (or its opposite, "dissolving": d = 1 - Tr). Only d is used in general, but both should be supported.</b>
d 0.9
Tr 0.1

<b># Illumination model (more info <a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file#Basic_materials">on Wikipedia</a>).</b>
illum 0 # Color on and Ambient off
illum 1 # Color on and Ambient on
illum 2 # Specular highlight on
...     # The other models are not covered here (raytracing, etc)

<b># Texture map (more info <a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file#Texture_maps">on Wikipedia</a>)</b>
map_Ka ambient.png # ambient texture
map_Kd diffuse.png # diffuse texture, very often only this one is set, sometimes both are set but use the same file
map_Ks specular.png # specular texture
...
</pre>

<p>Obj and mtl files may contain other statements not detailed here, see <a href="http://www.hodge.net.au/sam/blog/wp-content/uploads/obj_format.txt">OBJ specs</a> and <a href="https://www.fileformat.info/format/material/index.htm">MTL specs</a>
<p>When parsed, all the v, ft, vn, f floats should be concatenated in big Float32Arrays, as it's the format in which WebGL expects to receive data buffers.
<p>You can see my mini OBJ/MTL parser/viewer <a href="//xem.github.io/webgl-guide/obj">on Github</a>. It supports all the features listed above.


<p>(TODO: explain shaded textures)



<h4 id=5b>.fbx files</h4>
<p>todo


<h4 id=5c>.gltf / .glb files</h4>
<p>todo


<h4 id=5d>Others (.ply, .prwm...)</h4>
<p>todo

<br><br><hr><br>
<h2>Advanced shader manipulation</h2>
<br><hr><br>

<h4 id=6a>Using multiple shaders</h4>

<ul>
<li>If your scene contains many objects rendered differently (colored, textured, alpha, etc), you may want to use many shaders instead of a single, long shader
<li>You need to create a program for each shader, and when rendering a frame, switch between them using <b>gl.useProgram(...)</b>
</ul>

<table class=ch10>
<tr>
<td>
<pre><code class="lang-js">var p1 = compile(gl, vshader1, fshader1);
var p2 = compile(gl, vshader2, fshader2);

(...)

gl.useProgram(p1);

// Draw things with the first shader

gl.useProgram(p2);

// Draw things with the second shader</code></pre>
<td>
<iframe width=430 height=430 style="max-width:420px;" src="https://xem.github.io/webgl-guide/book/ch10/ProgramObject.html"></iframe>
</table>

<br><br><hr><br>


<h4 id=6b>Build shaders</h4>
<p>todo

<br><br><hr><br>
<h2>Interesting subjects to study next</h2>
<br><hr><br>

<h4 id=7a>3D physics</h4>
<p>todo

<h4 id=7b>Tessellation and decimation</h4>
<p>todo


<h4 id=7c>Interpolation, animation and rigging</h4>
<p>todo


<h4 id=7d>VR</h4>
<p>todo


<h4 id=7e>Field of view</h4>
<p>todo


<h4 id=7f>Other WebGL features</h4>
<p>todo


<h4 id=7g>Raycasting and distance fields</h4>
<p>todo


<h4 id=7h>Raytracing and Physics Based Rendering</h4>
<p>todo


<h4 id=7i>NURBS</h4>
<p>todo


<h4 id=7j>WebGPU</h4>
<p>todo


<h4 id=7k>WebGL and Gamedev</h4>
<p>todo


<h4 id=7l>Use WebGL to compute stuff</h4>
<p>todo

<h4 id=7m>Visualizing the camera</h4>
<p>todo (more info <a href="https://webglfundamentals.org/webgl/lessons/webgl-visualizing-the-camera.html">here</a>)


</div>

</main>

</div>

<footer></footer>

<script src="../ui.js?v=2022"></script>

<script>
if(navigator.userAgent.includes("WebKit")){

scr = document.createElement("SCRIPT");
scr.src = 'https://polyfill.io/v3/polyfill.min.js?features=es6';
document.body.appendChild(scr);

scr = document.createElement("SCRIPT");
scr.id = 'MathJax-script';
scr.setAttribute('async', true); 
scr.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
document.body.appendChild(scr);
}
</script>

<script>
header();
footer();
menu();
</script>

</body>
</html>
