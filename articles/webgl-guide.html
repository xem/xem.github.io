<!doctype html>
<meta charset=utf-8>
<meta name="viewport" content="width=device-width, user-scalable=no">
<html>
<head>
<link rel=stylesheet href="../style.css?v=4">
<title>Maxime Euzière</title>
<base target=_blank>
</head>
<body class=large>

<div class="wrapper">

<header></header>

<div id=menu></div>

<main>

<style>
table { border-spacing: 0; border-collapse: collapse; width: 100% }
th, td { padding: 5px; width: 200px }
th { background: #eee }
h4 { margin-bottom: 0; }
h1 { font-size: 30px }
h2 { font-size: 24px; line-height: 40px; }
h3 { font-size: 20px }
h4 { font-size: 18px }
h5 { font-size: 16px }
ul, ol { padding-left: 15px }
li { line-height: 25px }
pre { margin: 3px; font-size: 12px; }
pre.inline, pre.inline code { display: inline; padding: 4px 2px; background: #333; font-size: 11px;}
.math { margin: 15px 0 }
.section iframe { height: 40vw; min-height: 400px; }
.ch10 { border: 1px solid #000 }
.ch10 * { border: none }
.ch10 td { max-width: 430px; width: auto; vertical-align: top }
.ch10 td + td { max-width: 450px; }
.newWindow { float: right; margin-top: -60px; left: -10px; position: relative; z-index: 2; padding: 5px; border: 1px solid #555; border-radius: 5px; color: #000; font-size: 20px; width: 40px; height: 40px; background: url('images/new_window.svg') no-repeat center center #def; }
.section p {line-height: 32px; }
.grey, .grey td, iframe { border: 3px solid #999 }
.token.comment, .token.prolog, .token.doctype, .token.cdata { color: #bbb; }
summary { cursor: pointer }
.toc li { line-height: 15px; }
.toc p { line-height: 13px; }
sub { color: #888; position: relative; top: -35px; z-index: 2; background: #fff; padding: 5px 5px 0; left: 2px; }
</style>

<div class=section id=webgl_guide>
<h2>WebGL guide (part 1/2)</h2>
<h3>May 2020 - July 2021</h3>

<br><hr>
<div style="background:#fff4e1; border-radius: 20px; padding: 10px 20px 20px; margin: 20px 0;">
<h4>News</h4>
<ul>
<li><b>2020-05-29</b>: Hello <a href="//mailchi.mp/64b327c9a1ef/gamedevjsweekly334?e=25f0928e3d">GameDevJS Weekly</a> readers!
<li><b>2020-05-27</b>: Hello <a href="//frontendfoc.us/issues/442">Frontend Focus</a> readers!
<li><b>2020-05-22</b>: Hello <a href="//javascriptweekly.com/issues/489">JS Weekly</a> readers!
<li><b>2020-05-17</b>: Hello <a href="https://www.reddit.com/r/javascript/comments/gliqro/a_full_summarized_interactive_webgl_tutorial/">r/JavaScript</a>, <a href="https://www.reddit.com/r/webgl/comments/glissl/a_full_summarized_interactive_webgl_tutorial/">r/WebGL</a> and <a href="https://www.reddit.com/r/Frontend/comments/gq7tku/webgl_guide_part_12/">r/FrontEnd</a>!
</ul>
<!--p>The <a href="https://docs.google.com/spreadsheets/d/1YR68hC-3dDi70h8xQHT0FOpBJiuaQA1pc0fLTjJbF8E/edit?usp=sharing">visits</a> of my website are skyrocketing thanks to you! <3-->
<b>The part 2</b> will talk about <a href="https://xem.github.io/webgl-guide/book/ch10/Shadow.html">Shadowing</a>, <a href="https://xem.github.io/webgl-guide/obj/">3D files loading</a>, and many other advanced WebGL techniques!
<br><b>Feedbacks</b> are welcome! You can contact me on <a href="//twitter.com/MaximeEuziere">Twitter</a> or <a href="https://github.com/xem/xem.github.io/issues/new">Github</a><!--, or follow me to be notified when it's released :)
<br>Would you be interested by a <b>WebGL book</b> based on this guide? Please tell me!-->.
</div>
<hr>
<br>

<h2 id="0">Introduction</h2>

<p>This guide is a complete, summarized WebGL tutorial, with tiny interactive demos in each chapter.
<br>It's mainly inspired by the book <a href="https://www.oreilly.com/library/view/webgl-programming-guide/9780133364903/ch01.html">WebGL Programming Guide</a> and the websites <a href="https://webgl2fundamentals.org/">Webgl2Fundamentals</a>, <a href="http://learnwebgl.brown37.net/index.html">LearnWebgl</a> &amp; <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">MDN</a>. 
<br>Starting nearly from scratch, you'll be able to create your own 3D interactive scenes without needing to use any <a href="https://fr.wikipedia.org/wiki/Liste_de_frameworks_WebGL">library or framework</a>: only vanilla JS &amp; WebGL.
<br>My goal was to gather all the information and tricks about WebGL I found scattered everywhere, and present them in a short and helpful way. I hope you'll enjoy it!
<br>The demos, files and tools presented in this guide are all available <a href="https://github.com/xem/webgl-guide">on Github</a> (including my helper functions placed in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/webgl.js">webgl.js</a>, <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/shapes.js">shapes.js</a> and <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/webgl.js">matrix.js</a>).
<br>If you're interested in WebGL code golfing, raymarching and signed distance functions, check out <a href="webgl_quest.html">Webgl quest</a> and <a href="webgl_quest_2.html">Webgl quest 2</a>, that I made with the <a href="//xem.github.io/codegolf/intro.html">Codegolf Team</a>.
<br>Special thanks to <a href="https://twitter.com/iquilezles">Inigo Quilez</a>, <a href="https://twitter.com/kchplr">Kevin Chapelier</a>, <a href="https://twitter.com/FreyaHolmer/">Freya Holmér</a>, <a href="https://twitter.com/adriengueret">Adrien Guéret</a>, <a href="https://damienallonsius.github.io/">Damien Allonsius</a>, <a href="https://www.savinel.name/">Sampson Savinel</a> and <a href="https://bugshake.tumblr.com/">Stijn Raaijmakers</a> for their tips, gifs and proofreading!

<br><br><hr><br>
<h2>Table of contents</h2>
<div class=toc>
<br><a href="#0" target="_self"><b>Introduction</b></a>
<p><a href="#1" target="_self"><b>What is WebGL?</b></a>
<ul>
<li><a href="#1a" target="_self">Presentation</a>
<li><a href="#1b" target="_self">The GLSL language</a>
<li><a href="#1c" target="_self">Communication between JS and WebGL</a>
</ul>

<a href="#1d" target="_self"><b>Maths required to follow this guide</b></a>

<p><a href="#2" target="_self"><b>2D graphics</b></a>
<ul>
<li><a href="#2a" target="_self">Hello, point</a>
<li><a href="#2b" target="_self">Custom values: attributes and uniforms</a>
<li><a href="#2c" target="_self">Drawing many points, a matter of continuity</a>
<li><a href="#2d" target="_self">Drawing lines and triangles</a>
<li><a href="#2e" target="_self">Multi-attribute buffer &amp; varyings</a>
<li><a href="#2f" target="_self">Translate, rotate, scale</a>
<li><a href="#2g" target="_self">Texturing</a>
</ul>

<a href="#3" target="_self"><b>3D graphics</b></a>
<ul>
<li><a href="#3a" target="_self">The 3D camera</a>
<li><a href="#3b" target="_self">Indexed vertices</a>
<li><a href="#3c" target="_self">Hello cube </a>
<li><a href="#3d" target="_self">How to color each face of the cube</a>
<li><a href="#3e" target="_self">Lighting and shading</a>
<li><a href="#3f" target="_self">How to transform a 3D model</a>
<li><a href="#3g" target="_self">Drawing many cubes</a>
<li><a href="#3h" target="_self">Hierarchical objects</a>
</ul>

<a href="#4" target="_self"><b>Debugging</b></a>
<p><a href="#5" target="_self"><b>WebGL 2.0</b></a>
<p><a href="#6" target="_self"><b>To be continued...</b></a>
<p><a href="#7" target="_self"><b>Bonus: WebGL and code-golfing</b></a>
</div>

<br><hr><br>
<h2 id="1">What is WebGL?</h2>

<h4 id="1a">Presentation</h4>

<p>WebGL is a JavaScript API designed to process and draw 2D and 3D graphics very fast in a Web browser, by using the processing power of the GPU.
<br>It's based on <b>OpenGL ES</b> and is programmed using <b>shaders</b> coded in <b>GLSL</b> (OpenGL Shading Language), a language similar to C and C++.
<br>A scene rendered by WebGL is mainly made of <b>vertices</b> (points in 3D space, with coordinates X, Y, Z), which can be drawn as points, lines or triangles (colored, shaded or textured),
<br>but it's possible to go way further and display interactive 3D scenes with effects like shadows, reflections, particles, fog, blur, etc.
<br>However, WebGL doesn't have ready-to-use functions to place a camera, render points, text, polygons or special effects on a canvas. You need to tell it how to do that at a much lower level.
<p>Two versions of the WebGL API exist: <b>WebGL 1.0</b>, supported by 98% of browsers, and its evolution <b>WebGL 2.0</b>, supported by 77% of browsers as of july 2021, according to <a href="https://caniuse.com/#search=webgl">caniuse</a>.
<br>This guide will focus on WebGL 1.0, but all the features added in WebGL 2.0 will be explained at the end if you want to take the plunge.
<br>
<p>The workflow of a WebGL program can be summarized like this:
<ol>
<li>The JavaScript code initializes the WebGL program and pilots it to draw graphics on the <b>webgl context</b> of a <b>HTML5 canvas</b>.
<li>A first GLSL script called <b>vertex shader</b> is executed for every vertex of the scene. It computes an abstract, mathematical model of the scene and hands it to a second GLSL script.
<li>The second GLSL script, called <b>fragment shader</b>, is executed for every visible fragment (pixel) of the canvas. It computes each fragment's color, in a process called <b>rasterization</b>.
<li>The fragments constitute a bitmap image stored in a <b>color buffer</b>, which is finally displayed on the canvas.
<br><br><img src="images/webgl-guide/workflow.png" width=800>
</ol>

<br>
<br>
<hr style="width:500px">
<br>

<h4 id="1b">The GLSL language</h4>

<p>The shaders source code can be placed in a JavaScript string (or loaded from separate files).
<br>Here are the key features of their <a href="https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.1.20.pdf">syntax</a>:

<ul>
<li>An <b>int</b> is a whole number: <b>0</b>, <b>1</b>, <b>2</b>, <b>-10</b>,...
<li>A <b>float</b> is a number written with at least one decimal: <b>0.0</b>, <b>0.1</b>, <b>1.0</b>, <b>-10.5</b>,...
<li>A <b>bool</b> is a boolean number. Its possible values are <b>true</b> and <b>false</b>.
<li>A <b>vec4</b> is an array of 4 floats representing vertex coordinates or a 3D vector (x, y, z, w), or a color (r, g, b, alpha). The types <b>vec2</b> (x, y) and <b>vec3</b> (x, y, z / r, g, b) exist too.
<li>A <b>mat4</b> is a matrix (a grid) of 4 x 4 floats, useful for transforming vertex coordinates and vectors in 3D. The types mat2 (2x2) and mat3 (3x3) exist too.
<li>A <b>sampler2D</b> is a reference to a texture image; a <b>samplerCube</b> is a reference to a "3D texture" (a set of 6 textures mapped on a cube).
<li>A <b>variable</b> is declared with its type, for example: <pre class=inline><code class="lang-js">int i = -1;</code></pre>, <pre class=inline><code class="lang-js">float f = 2.0</code></pre> or <pre class=inline><code class="lang-js">vec4 v = vec4(1.0, 2.0, 3.0, 4.0);</code></pre>.
<li>A <b>constant</b> is a variable with a fixed value: <pre class=inline><code class="lang-js">const int c = 100;</code></pre>.
<li>The xyzw / rgba components of a vector can be extracted or swizzled (recomposed) in another vector, for example: <pre class=inline><code class="lang-js">float f = v.x;</code></pre>, <pre class=inline><code class="lang-js">vec3 rgb = v.rgb;</code></pre>, <pre class=inline><code class="lang-js">vec4 w = v.zxxy;</code></pre>.
<li>Semicolons <pre class=inline><code class="lang-js">;</code></pre> are mandatory at the end of each instruction (variable declaration or math operation).
<li><b>Math functions</b>: cos, sin, tan, pow, exp, log, log2, sqrt, abs, sign, floor, ceil, round, trunc, fract, mod, min, max, clamp, mix, step, length, distance, dot, cross, reflect, normalize...
<li><b>Math operators</b> (=, +, -, *, /, &amp;&amp;, ||, ==, !=, >, >=, &lt;, &lt;=, ++, --, ^^, +=, -=, *=, /=) only work between variables of the same type or same length (ex: int + int, float / float, mat4 * vec4 ...).
<li><b>Type casting</b> allows to convert a type into another, when it's possible. Ex: <pre class=inline><code class="lang-js">bool b = true; int i = int(b); /* i = 1 */ float f = float(i); /* f = 1.0 */</code></pre>.
<li><b>Tests and loops</b> are also available (if, else, switch, for, while), but loops must have a constant limit. (you can't do <pre class=inline><code class="lang-js">for(int i = 0; i &lt; j; i++){...}</code></pre> if j is variable).
<li>The <b>entry point</b> of each shader (where their execution starts) is a <pre class=inline><code class="lang-js">void main(){...}</code></pre> function.
<li>Custom functions can also be created and called by main() or by each other, but recursion isn't allowed.
<li>The <b>precision</b> of ints, floats and Sampler2Ds (lowp / mediump / highp) can be set in each shader with a directive, like <pre class=inline><code class="lang-js">precision highp int;</code></pre> or <pre class=inline><code class="lang-js">precision mediump float;</code></pre>
<br>These directives must be at the beginning of the shader's code, however only the float precision is mandatory in the fragment shader, all the others have values by default.
<br>Lowp corresponds to 8-bit values, mediump: 10-bits, and highp: 16-bits. Lowp is very limited, <b>mediump is fine in most cases</b>, and highp is better but not supported on all devices.
<li>To work properly, the vertex shader must set a global variable <b>gl_Position</b> containing the coordinates of the current vertex (plus <b>gl_PointSize</b> if it's rendering individual points).
<li>The fragment shader must set a global variable <b>gl_FragColor</b> containing the color of the current fragment.
<br>It has access to 3 global variables: <b>gl_FragCoord</b> (window coordinates),  <b>gl_PointCoord</b> (coordinates inside a point) and <b>gl_FrontFacing</b> (current triangle orientation).
</ul>

<br>
<br>
<hr style="width:500px">
<br>

<h4 id="1c">Communication between JavaScript and WebGL</h4>

<br><br><img src="images/webgl-guide/schema2.png" width=800>
<br>
<p>Four main mechanisms exist to send data between the different scripts:
<ul>
<li><b>Attributes</b> are global variable passed by JavaScript to the vertex shader. Their value can change for each vertex (ex: vertex coordinates).
<li><b>Uniforms</b> are global variables passed by JavaScript to both vertex and fragment shaders (ex: a color). Their value stays constant for an entire frame.
<li><b>Varyings</b> are not accessible by JavaScript. They can only be set by the vertex shader and read by the fragment shader.
<li><b>Data buffers</b> are big arrays of numbers passed by JS to the vertex shader, which will read and process it one little chunk at a time.
</ul>
<p>Each attribute, uniform and varying must be declared before <b>main()</b> in the shaders that use them.

<p>Don't worry, these features will be explained and illustrated in the next chapters.

<br>
<br>
<hr>
<br>

<h3 id="1d">Maths required to follow this guide</h3>

<p>If you're not friend with maths, don't worry! 3D programming actually requires a very limited subset of maths, which is summarized below:

<p><b>The basics of geometry</b>:
<br>- A point in 2D has two spatial coordinates (X horizontally, Y vertically).
<br>- A point in 3D has a third Z coordinate for depth.
<br>- The origin is the point where all the coordinates are equal to 0.
<br><img src="images/webgl-guide/xyz.png" width=700>

<p><b>The basics of trigonometry</b>:
<ul>
<li>An angle can measure between 0 and 360 degrees, which is equivalent to: 0 to 2π radians (π radians equals half a turn).
<li>An angle in degrees can be converted in radians by multiplying it with <b>π/180</b>.
<li>An angle in radians can be converted in degrees by multiplying it with <b>180/π</b>.
<li>The <b>trigonometric circle</b> or "unit circle" is a circle of radius 1, centered on the origin of a 2D plane. Every point of this circle corresponds to an angle, measured anti-clockwise:
<br>The rightmost point represents the angle 0 (or 2π rad), the topmost point is π/2 rad, the leftmost is π rad, and the bottom is 3π/2 rad.
<br><br><img src="images/webgl-guide/unitcircle.png" width=400 style="border: 1px solid #ddd">
<li>An angle bigger than 2π or smaller than 0 is equal to the same angle modulo 2π (ex: 5π rad = π rad; -π/2 rad = 3π/2 rad).
<li>The <b>cosine</b> of an angle "α" is the X coordinate of the corresponding point on the trigonometric circle, and oscillates between -1 and 1.
<li>The <b>sine</b> is the Y coordinate of the same point, and also oscillates between -1 and 1.
<li>The <b>tangent</b> is the length of the segment perpendicular to the radius, between this point and the X axis. Its value goes between -∞ and +∞, and is equal to tan(α) = sin(α) / cos(α).
<br><br><a href="https://twitter.com/freyaholmer/status/1173376419168247810"><img src="images/webgl-guide/trigo.gif" width=400 style="border: 1px solid #ddd"></a>
<br><sub>GIF by Freya Holmér</sub>
</ul>

<p><b>Vectors</b>:
<ul>
<li>A vector is an array of numbers. It can represent either a point in space (a vertex), or a direction (an offset).
<li>When it represents a point, it's a list of coordinates.
<br>For example, [2,4] can represent the X and Y coordinates of a 2D point, and [3,5,2] the X, Y and Z coordinates of a 3D point.
<li>When it's a direction (from a position in space to another position), it represents how the offset is applied in each coordinate. You can imagine it like an arrow.
<br>for example [1,2,3] corresponds to an X offset of 1 unit, a Y offset of 2 units and a Z offset of 3 units.
<li>Contrary to vertices, direction vectors don't have a position. They only represent an offset, and this offset can start from anywhere.
<li>For two points A and B, you can build a vector AB (going from a point A to a point B) like this: <b>AB = [xB - xA, yB - yA, zB - zA]</b>.
<br><br><img src="images/webgl-guide/vector.png" width=700>
</ul>

<p><b>Operations on vectors</b>:
<ul>
<li>Adding two vectors consists in adding their terms one by one: <b>V + W = [xV + xW, yV + yW, zV + zW]</b>. 
<li>Scaling a vector consists in multiplying all its terms by a given amount: <b>V * n = [xV * n, yV * n, zV * n]</b>.
<li>Measuring the length (or magnitude) of a vector is similar to measuring the distance between two points with Pythagore's theorem:
<b>||V|| = sqrt(xV² + yV² + zV²)</b>.
<li>Normalizing a vector consists in adjusting its length to 1 unit, without changing its direction. It's equivalent to scaling it by <b>1 / ||V||</b>.
<li>The relative angle between two normalized vectors V and W can be computed using the dot product: <b>V.W = xV * xW + yV * yW + zV * zW</b>.
<br>The dot product is equal to the cosine of the angle between the vectors. For example, it's 1 if they're equal, 0 if they're perpendicular, -1 if they're opposite.
<br><br><a href="https://twitter.com/FreyaHolmer/status/1200807790580768768?ref_src=twsrc%5Etfw"><img src="images/webgl-guide/dot.gif" width=350 style="border: 1px solid #ddd;"></a>
<br><sub>GIF by Freya Holmér</sub>
<br>
<br>
<li>The cross-product of two vectors V and W is a vector perpendicular to both vectors.
<br>It can be computed like this: <b>V×W = [yV*zW - zV*yW, zV*xW - xV*zW, xV*yW - yV*xW]</b>.

<!--table style=width:800px>
<tr>
<td>
<td>
</table-->
<br><br><a href="https://twitter.com/FreyaHolmer/status/1203059678705602562?ref_src=twsrc%5Etfw"><img src="images/webgl-guide/cross.gif" width=450 style="border: 1px solid #ddd;"></a>
<br><sub>GIF by Freya Holmér</sub>
<br>
<br>

<li>The normal of a triangle ABC is a vector perpendicular to its surface, more precisely, perpendicular to any vector inside the triangle.
<br>It can be computed as the cross-product of the vectors AB and BC, if the points A, B and C are arranged counter-clockwise. (if clockwise, the normal will point to the opposite direction).
<br>The normal of a triangle, as its name suggests, must be normalized, because it will often be involved in dot products.
<br><br><img src="images/webgl-guide/normal.png" width=350>
</ul>

<p><b>Matrices</b>:
<p>A matrix is a grid of numbers. It represents a system of linear equations that can be applied to any vector with a multiplication.
<br>Multiplying a matrix and a vector consists in computing the dot product of the vector with each line of the matrix.
<br>For example, in 3D, the "identity" matrix below transforms a vector into itself (it's a neutral operation):
<br>
<table style="width:500px">
<tr>
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>
 = 
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>

<td>

1 * x + 0 * y + 0 * z = x
<br>0 * x + 1 * y + 0 * z = y
<br>0 * x + 0 * y + 1 * z = z
</table>
<br>
If you use values different than 1 on the diagonal, the vector will be scaled:
<br>
<br>

<table style="width:500px">
<tr>
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>2</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>3</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>
 = 
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>2x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>3y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>-z</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>

<td>
2 * x + 0 * y + 0 * z = 2x
<br>0 * x + 3 * y + 0 * z = 3y
<br>0 * x + 0 * y + -1 * z = -z

</table>

<p>And if you use the appropriate values in the other fields, you can perform a rotation:

<ul>
<li>Along the X axis (angle φ in radians):
<br>
<br>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>cos φ</mn></mtd>
            <mtd><mn>-sin φ</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>sin φ</mn></mtd>
            <mtd><mn>cos φ</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>
 = 
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y cos φ - z sin φ </mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y sin φ + z cos φ </mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
<br>
<br>

<li>Along the Y axis (angle θ in radians):
<br>
<br>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>cos θ</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>sin θ</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>-sin θ</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>cos θ</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>
 = 
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x cos θ + z sin θ</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>-x sin θ + z cos θ</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
<br>
<br>

<li>Along the Z axis (angle ψ in radians):

<br>
<br>

<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>cos ψ</mn></mtd>
            <mtd><mn>- sin ψ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>sin ψ</mn></mtd>
            <mtd><mn>cos ψ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>
 = 
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x cos ψ – y sin ψ</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>x sin ψ + y cos ψ</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
</ul>
<br>
<p><b>Operations on matrices</b>:
<ul>
<li>A matrix can be transposed by inverting its horizontal and vertical axis (the diagonal stays unchanged):
<br>

<table style=width:300px>
<tr>
<td>
A = <math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>2</mn></mtd>
            <mtd><mn>3</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>4</mn></mtd>
            <mtd><mn>5</mn></mtd>
            <mtd><mn>6</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>7</mn></mtd>
            <mtd><mn>8</mn></mtd>
            <mtd><mn>9</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>

<td>
A<sup>T</sup> = <math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>4</mn></mtd>
            <mtd><mn>7</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>2</mn></mtd>
            <mtd><mn>5</mn></mtd>
            <mtd><mn>8</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>3</mn></mtd>
            <mtd><mn>6</mn></mtd>
            <mtd><mn>9</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
</table>
<li>Two or more matrices of equal size can be multiplied together to combine (accumulate) their transformations.
<br>The result of a matrix multiplication is a new matrix containing the dot products of each line of the first matrix with each column of the second matrix.
<br>The combination order is important, and is from right to left. For example, a matrix that performs a translation T, then a rotation R, then a scale S is equal to <b>S * R * T</b>.

<li>Finally, a matrix can be inversed. An inversed matrix cancels the transformation made by the original matrix:
<br>
A * A<sup>-1</sup> = identity
<br>
A * A<sup>-1</sup> * V = V
</ul>

<p><b>Homogeneous coordinates:</b>
<p>Finally, a little extension of the 3D vectors and matrices above, consists in giving them a fourth dimension, called <b>W</b>.
<br>The goal is not to draw 4-dimensional objects, but to allow more operations on vertices, like translations and <a href="#3a">camera projections</a>.
<br>Those 4D vectors are called homogeneous coordinates and are noted <b>[X, Y, Z, 1]</b> for vertices, and <b>[X, Y, Z, 0]</b> for normals.
<br>For example, here's the translation matrix that moves a point 2 units along X, 3 units along Y, and -1 unit along Z:
<br>

<table style="width:550px">
<tr>
<td>

<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>2</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>3</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>-1</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>
 = 
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x + 2</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y + 3</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z - 1</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
<td>

1 * x + 0 * y + 0 * z + 2 * 1 = x + 2
<br>0 * x + 1 * y + 0 * z + 3 * 1 = y + 3
<br>0 * x + 0 * y + 1 * z + -1 * 1 = z - 1
<br>0 * x + 0 * y + 0 * z + 1 * 1 = 1

</table>

<br>Remarks:
<ul>
<li>The (4D) transformation matrix performing a translation is an identity matrix, with the X, Y and Z offsets encoded on the last column.
<li>These offsets are multiplied by the fourth element of the 4D vector, that's why a point can be translated (W = 1) and a normal cannot (W = 0).
<li>The 3x3 matrix on the top left corner can still be used to perform rotations and scalings.
<li>When a vertex is rendered on the screen, only its X, Y and Z coordinates matter. It's W coordinate, only useful for computing translations and projections, is discarded.
</ul>
<br>
<p>Enough introduction, let's start this guide with our first WebGL demo!
<br><br><hr><br>
<center><h2 id="2">2D graphics</h2></center>
<br><hr><br>


<h4 id="2a">Hello, point</h4>

<p>Here's the simplest possible WebGL program, drawing a red, square point in the middle of the canvas.

<p>It's a live demo, feel free to play with the code and change some values!


<h5>Demo</h5>
<iframe id=i1 loading=lazy src="../../webgl-guide/editor/?demo=1"></iframe>

<h5>What happens here?</h5>
<ul>
<li>Two JavaScript objects are essential in a WebGL app: the canvas context <b>gl</b>, returned by <pre class=inline><code class="lang-js">canvas.getContext('webgl')</code></pre>, and <b>program</b> returned by <pre class=inline><code class="lang-js">gl.createProgram()</code></pre> (lines 4 &amp; 37).
<li>JavaScript also uses the functions <b>createShader</b>, <b>shaderSource</b>, <b>compileShader</b>, <b>attachShader</b>, <b>linkProgram</b> and <b>useProgram</b> to set up and run the WebGL app (lines 27-41),
<br>and the functions <b>clearColor</b>, <b>clear</b> and <b>drawArrays</b> to set the default background color, clear the canvas and draw a point on it (lines 48-59).
<li>The vertex shader (lines 7-15) sets the vec4 <b>gl_Position</b> (x, y, z, 1.0), and <b>gl_PointSize</b> (in pixels).<br>It is executed once, as there's only one vertex.
<br>Since we're drawing in 2D, the point's Z coordinate is 0, while X and Y are in the range [-1 : 1]: within the bounds of the canvas, even if the canvas is not square!
<br>The 4th vertex coordinate (W) is fixed to 1.0, and allows many transformations detailed in the next chapters.
<li>The fragment shader (lines 18-24) sets the vec4 <b>gl_Fragolor</b> (r, g, b, alpha), where each component is in the range [0 : 1].<br>It is executed 100 times (once for each pixel inside the point).
<br>It starts with a mandatory directive, used to define the precision of its floating numbers: <pre class=inline><code class="lang-js">precision mediump float;</code></pre> (lowp and highp are also available, but less useful). 
<li>If an error occurs during the compilation, it's caught by <b>getShaderInfoLog</b> or <b>getProgramInfoLog</b> (lines 44-46) and logged in the browser's JS console.
</ul>

<h5>Tips & tricks</h5>
<ul>
<li>On some devices, the biggest supported point size is 62px (more info on <a href="http://webglstats.com/webgl/parameter/ALIASED_POINT_SIZE_RANGE">webglstats</a>).
<li>On some devices, the points may disappear entirely if their center is outside of the canvas (more info on <a href="https://webglfundamentals.org/webgl/lessons/webgl-drawing-without-data.html#pointsissues">webglfundamentals</a>).
<li>The shaders' source code is placed in JS strings for simplicity. If you want to fraction your source code, it's possible to declare them in a separate JS files.
<br>You can get rid of the JS strings by placing your shaders' code in text files (ex: shader.vert / shader.frag), load these files (with XHR / fetch), and pass their content to <b>gl.shaderSource</b>.
<li>The program creation (lines 26 to 46) is always the same and pretty verbose, so we can put it in a <b>compile()</b> helper function and reuse it in the next chapters (see <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/webgl.js">webgl.js</a>):
</ul>
<pre style="font-size:11px"><code class="lang-js">// Compile a WebGL program from a vertex shader and a fragment shader
compile = (gl, vshader, fshader) => {
  
  // Compile vertex shader
  var vs = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vs, vshader);
  gl.compileShader(vs);
  
  // Compile fragment shader
  var fs = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fs, fshader);
  gl.compileShader(fs);
  
  // Create and launch the WebGL program
  var program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  gl.useProgram(program);
  
  // Log errors (optional)
  console.log('vertex shader:', gl.getShaderInfoLog(vs) || 'OK');
  console.log('fragment shader:', gl.getShaderInfoLog(fs) || 'OK');
  console.log('program:', gl.getProgramInfoLog(program) || 'OK');
  
  return program;
}</code>
</pre>

<br><br><hr><br>

<h4 id="2a">Custom values: attributes and uniforms</h4>

<p>Of course, WebGL wouldn't be interesting if it could just draw one hard-coded point.
<br>To make it less rigid, we can give it custom values. This can be done with <b>attributes</b> (readable by the vertex shader) and <b>uniforms</b> (readable by both shaders).
<ul>
<li>an <b>attribute</b> is variable and can contain a float or a vector (vec2, vec3, vec4). Your program should not exceed <a href="http://webglstats.com/webgl/parameter/MAX_VERTEX_ATTRIBS">16 attributes</a> to work on all devices.
<li>An <b>uniform</b> is constant can contain an int, a float, a vector or a matrix (mat2, mat3, mat4). Your program should not exceed <a href="http://webglstats.com/webgl/parameter/MAX_VERTEX_UNIFORM_VECTORS">128 vertex uniforms</a> and <a href="http://webglstats.com/webgl/parameter/MAX_FRAGMENT_UNIFORM_VECTORS">64 fragment uniforms</a>.
</ul>

<h5>Demo</h5>
<iframe id=i2 loading=lazy src="../../webgl-guide/editor/?demo=2"></iframe>

<h5>What happens here?</h5>

<ul>
<li>Position is declared with <pre class=inline><code class="lang-js">attribute vec4 position;</code></pre>, targeted with <pre class=inline><code class="lang-js">position = gl.getAttribLocation(program, 'position')</code></pre> and set with <pre class=inline><code class="lang-js">gl.vertexAttrib4f(position, 0, 0, 0, 1)</code></pre>.
<li>Point size is declared with <pre class=inline><code class="lang-js">attribute float size;</code></pre>, targeted with <pre class=inline><code class="lang-js">size = gl.getAttribLocation(program, 'size')</code></pre> and set with <pre class=inline><code class="lang-js">gl.vertexAttrib1f(size, 10)</code></pre>.
<li>Point color is declared with <pre class=inline><code class="lang-js">uniform float color;</code></pre>, targeted with <pre class=inline><code class="lang-js">color = gl.getUniformLocation(program, 'color')</code></pre> and set with <pre class=inline><code class="lang-js">gl.uniform1f(color, 1, 0, 0, 1)</code></pre>.
</ul>
<br>
<h5>Binding attributes and uniforms</h5>

<p>Attributes can be set like this:
<br>
<table border style="table-layout:fixed;max-width:900px">
<tr>
<th style="max-width:100px">Type<th style="max-width:200px">GLSL declaration<th style="min-width:460px">How to set its value in JS

<tr>
<td>float
<td><pre><code class="lang-js">attribute float f;</code></pre>
<td><pre><code class="lang-js">var f = gl.getAttribLocation(program, 'f');
gl.vertexAttrib1f(f, 1.0);</code></pre>

<tr>
<td>vec4
<td><pre><code class="lang-js">attribute vec4 v;</code></pre>
<td><pre><code class="lang-js">var f = gl.getAttribLocation(program, 'f');
gl.vertexAttrib4f(f, 1.0, 2.0, 3.0, 4.0); // list
gl.vertexAttrib4fv(f, [1.0, 2.0, 3.0, 4.0]); // or array</code></pre>

</table>

<br>

<p>And uniforms can be set like this:
<br>
<table border style="table-layout:fixed;max-width:900px">
<tr>
<th style="max-width:100px">Type<th style="max-width:200px">GLSL declaration<th style="min-width:460px">How to set its value in JS
<tr>

<td>int
<td><pre><code class="lang-js">uniform int i;</code></pre>
<td><pre><code class="lang-js">var i = gl.getUniformLocation(program, 'i');
gl.uniform1i(i, 1);</code></pre>

<tr>
<td>float
<td><pre><code class="lang-js">uniform float f;</code></pre>
<td><pre><code class="lang-js">var f = gl.getUniformLocation(program, 'f'):
gl.uniform1f(f, 1.0);</code></pre>

<tr>
<td>vec4
<td><pre><code class="lang-js">uniform vec4 v;</code></pre>
<td><pre><code class="lang-js">var f = gl.getUniformLocation(program, 'f');
gl.uniform4f(f, 1.0, 2.0, 3.0, 4.0); // list
gl.uniform4fv(f, [1.0, 2.0, 3.0, 4.0]); // or array</code></pre>

<tr>
<td>mat4
<td><pre><code class="lang-js">uniform mat4 m;</code></pre>
<td><pre><code class="lang-js">var m = gl.getUniformLocation(program, 'm');
gl.uniformMatrix4fv(
  m,
  false, // transpose (always false)
  new Float32Array([
    1.0, 2.0, 3.0, 4.0,
    5.0, 6.0, 7.0, 8.0,
    9.0, 10.0, 11.0, 12.0,
    13.0, 14.0, 15.0, 16.0
  ])
);</code></pre>
</table>

<br>(vec2 and vec3 are declared similarly to vec4, mat2 and mat3 similarly to mat4).
<br>
<br>

<h5>Tips & tricks</h5>
<ul>
<li>The fourth value of a vec4 attribute is <b>1.0</b> by default, so it's frequent to encounter some code that only sets x, y and z with <pre class=inline><code class="lang-js">gl.vertexAttrib3f(position, 0, 0, 0)</code></pre>.
<li>Boolean uniforms also exist in the language's specs, but don't work on all devices. If you need one, consider replacing it with an int or a float.
<li>Matrix attributes also exist in the language's specs, but JavaScript doesn't have a convenient method to set their value, and they're not very useful anyways.
<li>You can draw as many points as you want by setting new attributes / uniforms values and calling <b>drawArrays</b> again.
<br>The same shaders will be executed each time but with different inputs.
<br>For example, you can add these lines to add 2 other points:
</ul>
<pre><img src="images/webgl-guide/rgb.png" style=float:right><code class="lang-js">gl.vertexAttrib3f(position, 0.25, 0, 0);
gl.uniform4f(color, 0, 1, 0, 1); // green
gl.drawArrays(gl.POINTS, 0, 1);

gl.vertexAttrib3f(position, 0.5, 0, 0);
gl.uniform4f(color, 0, 0, 1, 1); // blue
gl.drawArrays(gl.POINTS, 0, 1);</code></pre>
<ul><li>Inside the fragment shader, you have access to a <b>gl_PointCoord</b> vec2 telling where the fragment is placed in the point (x and y coordinates are between 0 and 1).
<br>Moreover, in GLSL, you can prevent a fragment from being rendered using the <b>discard;</b> statement, and measure a distance between two points with <b>distance()</b>.
<br>As a result, you can make a rounded point by discarding every fragment further than a radius of 0.5 from the center:
</ul>
<pre><img src="images/webgl-guide/rounded.png" width=60 style=float:right><code class="lang-js">float d = distance(gl_PointCoord, vec2(0.5, 0.5));
if(d &lt; .5) { gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); }
else { discard; }</code></pre>

<br><br><hr><br>
<h4 id="2c">Drawing many points, a matter of continuity</h4>

<p>By default, WebGL has no problems calling <b>gl.drawArrays</b> many times in a row, but only if these calls happen in the same timeframe.
<br>Here's a program trying to draw a new random point every 500ms:

<h5>Demo</h5>

<iframe id=i3 loading=lazy src="../../webgl-guide/editor/?demo=3"></iframe>

<h5>What happens here?</h5>
<p>As you can see, the canvas is not cleared (in black), but completely reset each time drawArrays() is called. This is the standard behavior when the draws happen at different moments.
<br>To solve this, there are two solutions:
<ol>
<li>Save the positions and colors of every new point in a JS array or object.<br>Then every 500ms, clear the canvas (to make the background black) and redraw all the saved points;
<li>Force <pre class=inline><code class="lang-js">{ preserveDrawingBuffer: true }</code></pre> when creating the WebGL context, as you can see by removing the commented code on line 4.
<br>In this case, you won't have to clear the canvas if you want the old points to stay visible and immobile.
</ol>

<p>In both cases, the result will look like this:

<br><br><img src="images/webgl-guide/points.gif" width=300 loading=lazy>

<br>Both solutions are okay in this example, but in real conditions (animated WebGL scenes with moving objects), you don't want the previous frames to stay visible.
<br>So the only solution will be to clear the canvas and redraw everything at each new frame.

<br><br><hr><br>

<h4 id="2d">Drawing lines and triangles</h4>

<p>The next step consists in declaring many points at once, and telling WebGL how to display them: as points, as lines or as triangles.
<br>To do this, we'll use a <b>data buffer</b> (an array of binary numbers) to send vertex properties from JS to the fragment shader, via an attribute. The following types are supported:
</ul>
<br>
<table border style="table-layout:fixed">
<tr>
<th>Name
<th>Bounds
<th style="max-width:100px">Bytes
<th>JS container
<th>WebGL type

<tr>
<td>Unsigned byte
<td>0 ... 255
<td>1
<td>new Uint8Array([...])
<td>gl.UNSIGNED_BYTE

<tr>
<td>Signed short integer
<td>−32,768 ... 32,767
<td>2
<td>new Int16Array([...])
<td>gl.SHORT

<tr>
<td>Unsigned short integer
<td>0 ... 65,535
<td>2
<td>new Uint16Array([...])
<td>gl.UNSIGNED_SHORT

<tr>
<td>Signed integer
<td>-2,147,483,648 ... 2,147,483,647
<td>4
<td>new Int32Array([...])
<td>gl.INT

<tr>
<td>Unsigned integer
<td>0 ... 4,294,967,295
<td>4
<td>new Uint32Array([...])
<td>gl.UNSIGNED_INT

<tr>
<td>Floating point number
<td>-2<sup>128</sup> ... 2<sup>127</sup>
<td>4
<td>new Float32Array([...])
<td>gl.FLOAT
</table>
<br>
<p>Then, <b>gl.drawArrays</b> can render these vertices as points, lines and triangles in 7 different ways, by changing its first parameter:
<br>
<br>
<img src="images/webgl-guide/modes.png" width=800 style="border:2px solid #ddd">

<h5>Demo</h5>
<p>Here's the simplest way to draw a colored triangle:
<br>
<br>
<iframe id=i4 loading=lazy src="../../webgl-guide/editor/?demo=4"></iframe>

<h5>What happens here?</h5>
<ul>
<li>A data buffer is filled with 3 points coordinates and bound to a <b>position</b> attribute with <b>createBuffer</b>, <b>bindBuffer</b>, <b>bufferData</b>, <b>vertexAttribPointer</b> &amp; <b>enableVertexAttribArray</b> (lines 32-50).
<li>At the end, we tell <b>gl.drawArrays</b> to render these points as a triangle. As a result, every fragment inside the triangle will automatically reuse the "color" uniform variable (red).
<li>If you replace <b>gl.TRIANGLES</b> with <b>gl.LINE_LOOP</b>, only the lines between points 0-1, 1-2, and 2-0 will be rendered, with a <b>line width</b> of 1px (1 fragment).
<br>You can also try <b>gl.LINE_STRIP</b> to trace lines between points 0-1 and 1-2, and <b>gl.LINES</b> to draw a line between points 0 and 1, as it only works on consecutive pairs of points.
<br>Unfortunately, the line width can't be changed on most devices, so we have to "cheat" with triangles to make thicker lines (more info on <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/lineWidth">MDN</a> and <a href="https://mattdesl.svbtle.com/drawing-lines-is-hard">mattdesl's website</a>).
<li>Lines and triangles do not need <b>gl_PointSize</b> to be set in the vertex shader. If you replace <b>gl.TRIANGLES</b> with <b>gl.POINTS</b>, you'll have to set gl_PointSize again or they won't appear.
</ul>

<h5>Tips &amp; tricks</h5>

<ul>
<li>You can draw as many triangles as you want by adding vertex coordinates on line 33 and updating the vertex count on line 61.
<li>Remember that the X and Y vertex coordinates are in the range [-1:1], whatever the size of the canvas.
<br>If the canvas is not square, you can compute its <b>aspect ratio</b> (width / height) and multiply all your X coordinates with it to cancel the distorsion.
<li>In all the following chapters' demos, you can replace <b>gl.TRIANGLES</b> with <b>gl.LINE_LOOP</b> to see the scene in <b>wireframe</b>.
<li>WebGL does <b>antialiasing</b> (pixel smoothing) by default. This can be disabled with <pre class=inline><code class="lang-js">canvas.getContext('webgl', {antialias: false});</code></pre>, to save resources, especially on retina screens.
<li>The buffer creation and binding is also quite verbose, so let's put it in the function <b>buffer()</b>, in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/webgl.js">webgl.js</a>:
</ul>
<pre style="font-size:11px"><code class="lang-js">// Bind a data buffer to an attribute, fill it with data and enable it
buffer = (gl, data, program, attribute, size, type) => {
  gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
  var a = gl.getAttribLocation(program, attribute);
  gl.vertexAttribPointer(a, size, type, false, 0, 0);
  gl.enableVertexAttribArray(a);
}</code>
</pre>

<br><hr><br>

<h4 id="2e">Multi-attribute buffer and varying color</h4>

<p>Now, we want to give a different color to our three vertices, and draw a triangle with them.
<br>The vertex colors can be transmitted to the fragment shader via a <b>varying</b> variable, to produce a gradient (this process is called <b>color interpolation</b>).
<br>The X/Y/Z and R/G/B values for each vertex can be stored in two data buffers, or in an <b>interleaved data buffer</b>, like here:
<h5>Demo</h5>

<iframe id=i6 loading=lazy src="../../webgl-guide/editor/?demo=5"></iframe>

<h5>What happens here?</h5>
<ul>
<li>A buffer of 3 x 6 floats is initialized and bound to the program (lines 27-43).
<li>Then, for every chunk of 6 floats in the data buffer,
<br>- <pre class=inline><code class="lang-js">gl.vertexAttribPointer(position, 3, gl.FLOAT, false, FSIZE*6, 0);</code></pre> reserves the first 3 values for the attribute <b>position</b> (line 48),
<br>- <pre class=inline><code class="lang-js">gl.vertexAttribPointer(color, 3, gl.FLOAT, false, FSIZE*6, FSIZE*3);</code></pre> reserves the last 3 values for the attribute <b>color</b> (line 60).
<li>The last two params of vertexAttribPointer (stride and offset) are counted in bytes, and the size of a data buffer item can be retrieved using <b>BYTES_PER_ELEMENT</b> (line 40).
<li><b>gl.enableVertexAttribArray</b> (lines 56 and 68) finish binding the attributes to the <b>verticesColors</b> data buffer. 
<br>The data buffer is not named explicitly though (the last buffer bound to the WebGL program is used automatically).
<li>The varying <b>v_color</b> is declared in both shaders.
<br>- In the vertex shader, it receives the color of the current vertex.
<br>- In the fragment shader, its value is automatically interpolated from the three vertices around it:
</ul>


<img src="images/webgl-guide/interpolation.gif" width=350 style="border:2px solid #ddd">
<br>
<h5>Tips and tricks</h5>

<ul>
<li>It's a good practice to prefix every varying name with "v_".
<li>A WebGL program should not exceed <a href="http://webglstats.com/webgl/parameter/MAX_VARYING_VECTORS">6 varyings</a> to work on all devices.
<li>Color interpolation also works in <b>LINES</b>, <b>LINE_STRIP</b> and <b>LINE_LOOP</b> modes.
<li>Fun fact: most WebGL tutorials online stop when they reach this famous "tricolor triangle", but this one is different: we have much more to cover! ;)
<li>Contrary to POINTS mode (that has gl_PointCoords), in TRIANGLES mode there is no global variable indicating where the current fragment is situated inside the triangle.
<br>But you have access to <b>gl_FragCoords</b> telling where the fragment is positioned on the canvas.
</ul>

<br><br><hr><br>

<h4 id="2f">Translate, rotate, scale</h4>

<p>If we want to move, rotate or scale a triangle, we need to know how to transform each of its vertices.
<ul>
<li><b>Translation</b> consists in moving all the vertices in a given direction (by increasing or decreasing their X/Y/Z coordinates).
<li><b>Rotation</b> consists in moving the vertices around a <b>pivot point</b>, with a given angle (a full turn clockwise is 360 degrees or 2π radians).
<li><b>Scaling</b> consists in making the triangle smaller or bigger by bringing the vertices closer or further from a pivot point.
</ul>
<p>These operations can be done component per component (compute the new value of X, then Y, then Z), but we generally use a much powerful tool: <b>matrix transformations</b>:
<br>Each transformation can be written as a mat4 (a matrix of 4x4 floats), and applied to a vertex's <b>homogeneous coordinates</b> (vec4(X, Y, Z, 1.0)) with a multiplication.

<p>
<table border style='max-width:700px'>
<tr>
<th style="min-width:300px">Transformation
<th style=min-width:250px>Transformation applied to each vertex coordinates
<th><div style="min-width: 260px">transformation via a matrix</div>

<tr>
<td>Identity (no change)
<td>x' = x
<br>y' = y
<br>z' = z
<td style=padding:10px>

<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr>
<td>Translation along X, Y and Z axis
<td>x' = x + Tx
<br>y' = y + Ty
<br>z' = z + Tz
<td style=padding:10px>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Tx</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Ty</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>Tz</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr>
<td>Rotation around the X with an angle φ
<br>(φ is in radians)
<td>x' = x
<br>y' = y cos φ - z sin φ
<br>z' = y sin φ + z cos φ
<td style=padding:10px>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>cos φ</mn></mtd>
            <mtd><mn>-sin φ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>sin φ</mn></mtd>
            <mtd><mn>cos φ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr style=padding:10px>
<td>Rotation around the Y with an angle θ
<td>x' = x cos θ + z sin θ
<br>y' = y
<br>z' = -x sin θ + z cos θ
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>cos θ</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>sin θ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>-sin θ</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>cos θ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr style=padding:10px>
<td>Rotation around the Z axis with an angle ψ
<td>x' = x cos ψ – y sin ψ
<br>y' = x sin ψ + y cos ψ
<br>z' = z
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>cos ψ</mn></mtd>
            <mtd><mn>-sin ψ</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>sin ψ</mn></mtd>
            <mtd><mn>cos ψ</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr style=padding:10px>
<td>Scaling along X, Y and Z axis
<td>x' = Sx * x
<br>y' = Sy * y
<br>z' = Sz * z
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>Sx</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Sy</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Sz</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

</table>

<h5>Demo</h5>

<iframe id=i5 loading=lazy src="../../webgl-guide/editor/?demo=6"></iframe>

<h5>What happens here?</h5>
<ul>
<li>This demo performs 3 transformations on the same triangle: translate, then rotate, then scale.
<li>These transformations can be done in this order by multiplying their matrices from right to left, and multiplying the resulting <b>matrix product</b> with the vertex coordinates (see line 15).
<li>These 3 matrices are declared in JS and sent to the fragment shader using uniforms (see lines 42 to 73).
<li>WebGL only accepts uniform matrices that are <b>transposed</b> (matrices with the horizontal and vertical axis inverted), so they were transposed manually in the JS code.
<li>The matrix multiplication is done in the vertex shader, which is very simple but not efficient, because it's recomputed for each vertex of the scene.
<br>The best practice is to prepare the transformation matrix once, in the JS program, then send it to the vertex shader.
</ul>

<h5>Tips: manipulating matrices in JS</h5>

<p>As I said, the best practice is to declare and compute the global transformation matrix in JS, before sending it to the shader.
<br>For many years, the best practice was to compute all the transformations manually, term by term, inside a <b>Float32Array</b>.
<br>Many JS libraries can help you do that, the most famous is <a href="https://github.com/toji/gl-matrix">glMatrix</a>.
<br>However, in this guide, I will use a more recent JS API called <a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix">DOMMatrix</a>, designed to handle transformations for DOM elements, SVG graphics, and 2D/3D canvas.
<br>This API has been considered absolutely too slow for WebGL for a long time (3 to 30 times slower than JS alone), but it's not the case anymore:
<br>According to my perf tests, DOMMatrix is only 5-20% slower than JS at worst, and can still perform more than 30,000 matrix transformations per second, which is largely enough!

<p>Here are the DOMMatrix methods that will interest us in this guide:
<ul>
<li><b>A = new DOMMatrix()</b> creates a 4x4 identity matrix.
<li><b>A = new DOMMatrix([m11, m21, m31, m41, m12, m22, m32, m42, m13, m23, m33, m43, m14, m24, m34, m44])</b> creates a 4x4 matrix from a list of 16 numbers.
<li><b>A.multiplySelf(B)</b> computes A = A x B.
<li><b>A.preMultiplySelf(B)</b> computes A = B x A.
<li><b>A.translateSelf(x, y, z)</b> adds a translation to A.
<li><b>A.scaleSelf(sx, sy, sz, ox, oy, oz)</b> adds a scaling to A, centered on the origin point o.
<li><b>A.rotateSelf(rx, ry, rz)</b> adds a rotation to A. Rotates around Z, then Y, then X. The angles are in <b>degrees</b>.
<li><b>A.invertSelf()</b> inverts A (if the inversion is impossible, the matrix is filled with NaN values).
<li><b>A.toFloat32Array()</b> returns a Float32Array useable by the WebGL shders.
</ul>

<p>Unfortunately, the method <b>transposeSelf</b> doesn't exist yet, but can be replaced by this:
<br><pre class="language-js"><code>// Transpose a DOMMatrix
transpose = m => {
  return new DOMMatrix([
    m.m11, m.m21, m.m31, m.m41,
    m.m12, m.m22, m.m32, m.m42,
    m.m13, m.m23, m.m33, m.m43,
    m.m14, m.m24, m.m34, m.m44,
  ]);
};</code></pre>

<p>This function and a few others that we'll see later, are present in my helper file <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/matrix.js">matrix.js</a>.

<h5>Tips: How to change the pivot point of a rotation</h5>

<p>The <b>rotateSelf</b> method only allows to use the world's origin [0, 0, 0] as pivot point.
<br>Imagine a triangle that is not centered on the origin, that you need to rotate 90 degrees (π/2 radians) around its center, for example the point [0.5, 0.5, 0].
<br>The solution is to apply 3 transformations to this triangle's vertices:
<ol>
<li>Translate them to place the pivot point at the origin [0, 0, 0].
<li>Apply a 90 degrees rotation.
<li>Translate them back to have the pivot point at the original position [0.5, 0.5, 0].
</ol>

<img src="images/webgl-guide/pivot.png" width=850-->

<p>It can be implemented like this:

<br><pre class="language-js"><code>// Transformation matrix for a rotation around a pivot point
rotate = (rx, ry, rz, ox, oy, oz) => {
  var ret = new DOMMatrix();
  return ret.translateSelf(-ox, -oy, -oz).rotateSelf(rx, ry, rz).translateSelf(ox, oy, oz);
};</code></pre>

<br><br><hr><br>

<h4 id="2g">Texturing</h4>

<p>As we saw earlier, a fragment's color inside a triangle can be interpolated from the colors of each vertex around it.
<br>The same principle can be used with a texture image (it's called <b>sampling</b> in this case).
<br>A WebGL texture (whatever its size in pixels) has a local coordinates system (U,V) between 0 and 1, and any vertex can have <b>texture coordinates</b> in this system.
</ul>
<br><br><img src="images/webgl-guide/texture.png">

<h5>Demo</h5>

<p>Here's an example of texture applied to a <b>quad</b> (a square made of two triangles):
<br>
<br>
<iframe id=i7 loading=lazy src="../../webgl-guide/editor/?demo=7"></iframe>

<h5>What happens here?</h5>

<ul>
<li>An image is loaded and a WebGL <b>texture sampler</b> is created from it, using the functions <b>createTexture</b>, <b>pixelStorei</b>, <b>activeTexture</b>, <b>bindTexture</b>, <b>texParameteri</b> (lines 60 to 86).
<br>Most of these steps plus <b>clear</b> and <b>drawArrays</b> are executed after the image has finished loading (line 64).
<li>Special texture behaviors (wrap / mirror / clamp on edges, minimize / magnify filters, etc) can be configured with <b>texParameteri</b> (more info on <a href="https://developer.mozilla.org/en/docs/Web/API/WebGLRenderingContext/texParameter">MDN</a>).
<br>In particular, <b>gl.TEXTURE_WRAP_S</b> and <b>gl.TEXTURE_WRAP_T</b> can be set to <b>gl.REPEAT</b> (default), <b>gl.CLAMP_TO_EDGE</b> or <b>gl.MIRRORED_REPEAT</b>.
<br>This tells WebGL what to do if a texture coordinate is not between 0 and 1:
</ul>
<br><img src="images/webgl-guide/wrap.png" width=550>

<ul>
<li>The Y axis flip (on line 67) puts the image's UV origin at the top left corner, and avoids having to work with an upsise-down image.
<li>The vertices positions are interleaved with the texture coordinates in the data buffer (lines 31 to 36).
<br>The vertex shader receives the vertex positions and texture coordinates as <b>attributes</b> (lines 9 and 10), and sends the latter to the fragment shader using a <b>varying</b> (lines 11, 14, 21).
<li>The fragment shader receives the coordinates as a varying, the texture image as a <b>uniform sampler2D</b> (line 20), and calls <pre class="language-js inline"><code>texture2D(sampler, v_TexCoord)</code></pre> to interpolate it (line 23).
</ul>
<br>

<h5>Tips and tricks</h5>


<ul>
<li>The U and V axis are sometimes called <b>S and T</b> in literature and 3D projects, but it's exactly the same thing.
<li>The "pixels" inside a texture are called <b>texels</b>.
<li>Since UV coordinates are between 0 and 1, the vast majority of texture images are square to avoid being distorted when they're mapped on a 3D shape.
<li>In WebGL 1.0, the textures width and height in pixels need (in most cases) to be a power of two (2, 4, 8, 16, 32, 64, 128, 256, 1024, 2048, 4096...).
<br>It's recommended to always use power-of-two sizes, but if you really need textures of different sizes, you can fix them by adding wrap on S and T axis:
<br><pre class="language-js"><code>gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);</code></pre>
<li>In this demo, we're using a single texture (TEXTURE0). You can use more, but you can't exceed 8 on some devices (more info on <a href="http://webglstats.com/webgl/parameter/MAX_TEXTURE_IMAGE_UNITS">webglstats</a>).
<br>You can call <pre class="language-js inline"><code>gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)</code></pre> to know the limit on your device.
<li>The maximum texture size also varies with the device used. To be safe, width and height shouldn't exceed 4096px (more info on <a href="http://webglstats.com/webgl2/parameter/MAX_TEXTURE_SIZE">webglstats</a>).
<br>You can call <pre class="language-js inline"><code>gl.getParameter(gl.MAX_TEXTURE_SIZE)</code></pre> to know the limit on your device.
<li>You can overwrite textures after a <b>draw call</b> (after calling drawArrays or drawElements) if they're not used anymore. Swapping textures can help having more than 8 textures per frame.
<li>If you need more than 8 textures without constantly switching between them, you can gather them into a <b>texture atlas</b> (a mosaic), and pick coordinates in the regions you want.
<br>Warning: <a href="https://answers.unity.com/questions/1009926/texture-bleeding-on-mesh.html">texture bleeding</a> can occur if you use texture coordinates at the fronteer between two "sub-textures" of an atlas, due to antialiasing. Leave a bit of padding to avoid it.
<li>SVG files can't be used as textures (unless you use a library that converts SVG into a bitmap or a list of polygons).
<li>To enable support for PNG images with transparency, you need to add the following line: <pre class="language-js inline"><code>gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);</code></pre>,
<br>otherwise, the transparent pixels will remain white (more info in the <a href="webgl-guide-part-2.html#1a">part 2</a> of this guide). 

</ul>
<br>
<h5>Changing the texture's appearance</h5>
<p>Remember that the values you're manipulating in the fragment shader are rgba colors, so you can do anything you want with them, like:
<ul>
<li>inverting the colors (r = 1 - r; g = 1 - g; b = 1 - b).
<li>greyscaling (compute the average of r, g and b, and apply it to r, g and b).
<li>exchanging color components (ex: gl_FragColor = color.brga).
<li>playing with <b>gl_FragCoord</b> (the current canvas coordinates, in pixels, which is available as a global vec2).
<li>Darken or lighten a texture by making the rgb values lower or higher.
<li>etc...
</ul>
<br><img src="images/webgl-guide/textures0.png" width=900>

<br>
<br>

<h5>Combining multiple textures</h5>
<p>Two or more textures can be used on a triangle at the same time. For example, you can initialize two samplers, and add or multiply them in the fragment shader:
<pre class="language-js"><code>vec4 color0 = texture2D(sampler0, v_TexCoord);
vec4 color1 = texture2D(sampler1, v_TexCoord);
gl_FragColor = color0 + color1;

// or

gl_FragColor = color0 * color1;</code></pre>

<br><img src="images/webgl-guide/textures.png" width=600>

<p>Or blend them together, using the <b>mix()</b> function:

<pre class="language-js"><code>gl_FragColor = mix(color0, color1, 0.25); // color0 * 0.25 + color1 * 0.75;</code></pre>

<br><img src="images/webgl-guide/textures2.png" width=600>
<br>
<br>
<p>NB: since WebGL can't display text natively, a common approach is to put text in an image or on a 2D canvas and use it as a texture.
<br>More info in the <a href="webgl-guide-part-2.html#4b">second part of this guide</a>!

<br>
<br>
<br><br><hr><br>
<center><h2 id="3">3D graphics</h2></center>
<br><hr><br>

<h4 id="3a">The 3D camera</h4>
<p>WebGL doesn't do "3D" natively. Even if you declare a bunch of 3D vertices and triangles, the browser doesn't have a 3D representation of your scene ready to be displayed on the canvas.
<br>Your program will have to do all the computing to simulate the camera, the perspective, and how they affect each polygon, so the scene can <i>look like</i> it's in 3D.
<br>Fortunately, the API we use (WebGL) provides helpful tools to render complex scenes without too much effort.
<br>
<p><b>The perspective camera</b>
<br>
<br><img src="images/webgl-guide/frustum.png">
<p>In 3D, the "camera", with its position, angle and perspective, is defined by nothing more than a 4x4 matrix.
<br>When the scene is rendered, every vertex fed to the vertex shader can be multiplied by this matrix to simulate these camera properties and appear at the right position on the canvas.
<br>The camera's <b>frustum</b>, also called <b>clipping volume</b>, defines an area in which the triangles will be rendered. (all the rest is ignored)
<br>For a camera with perspective, it is defined by an angle (the field of view), an aspect ratio, a near clip plane and a far clip plane, and can be set with this matrix:
<br>
<br>
<div class=math>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1/(aspect*tan(fov/2))</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1/tan(fov/2)</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-(far+near)/(far-near)</mn></mtd>
            <mtd><mn>-(2*far*near)/(far-near)</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-1</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>
</div>
<br>
<br>

<p>Then, the camera can be translated, rotated and scaled (zoomed) similarly to the vertices, by using the matrices multiplications we saw earlier.
<br>A slightly more advanced LookAt() function is often used by developers to set the camera's position, angle and target all at once.

<p>Here are the perspective() and lookAt() functions I added in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/matrix.js">matrix.js</a>:

<pre><code class="lang-js">// Create a perspective matrix
// options: fov in degrees, aspect, near, far
// return: DOMMatrix
perspective = options => {
  var fov = options.fov || 85;
  fov = fov * Math.PI / 180;       // fov in radians
  var aspect = options.ratio || 1; // canvas.width / canvas.height
  var near = options.near || 0.01; // can't be 0
  var far = options.far || 100;
  var f = 1 / Math.tan(fov);
  var nf = 1 / (near - far);
  return new DOMMatrix([
    f / aspect, 0, 0, 0, 
    0, f, 0, 0, 
    0, 0, (far + near) * nf, -1,
    0, 0, (2 * near * far) * nf, 0
  ]);
}

// LookAt generates a matrix corresponding to a camera placed at a given point and looking at a target point.
// options: camera position (cameraX, cameraY, cameraZ), target (targetX, targetY, targetZ), up vector (upX, upY, upZ, optional, verticl by default)
// return: DOMMatrix.
lookAt = (cameraX, cameraY, cameraZ, targetX, targetY, targetZ, upX = 0, upY = 1, upZ = 0) => {
  var e, fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;
  fx = targetX - cameraX;
  fy = targetY - cameraY;
  fz = targetZ - cameraZ;
  rlf = 1 / Math.hypot(fx, fy, fz);
  fx *= rlf;
  fy *= rlf;
  fz *= rlf;
  sx = fy * upZ - fz * upY;
  sy = fz * upX - fx * upZ;
  sz = fx * upY - fy * upX;
  rls = 1 / Math.hypot(sx, sy, sz);
  sx *= rls;
  sy *= rls;
  sz *= rls;
  ux = sy * fz - sz * fy;
  uy = sz * fx - sx * fz;
  uz = sx * fy - sy * fx;
  var ret = new DOMMatrix([
    sx, ux, -fx, 0,
    sy, uy, -fy, 0,
    sz, uz, -fz, 0,
    0,  0,  0,   1
  ]);
  return ret.translateSelf(-cameraX, -cameraY, -cameraZ);
}</code>
</pre>

<p>(Note that the canvas' aspect ratio is part of the perspective matrix, which means that all canvas sizes are supported out-of-the-box!)
<br>
<p><b>The orthogonal camera</b>
<br>
<br><img src="images/webgl-guide/orthogonal.png">
<br>
<p>It's also possible to make a camera with no perspective, also called "orthogonal", "orthographic", "isometric" or "2.5D".
<br>In this case, the clipping volume is a box with no "field of view" angle.
<p>Here are the matrix and the corresponding source code:
<br>
<br>
<div class=math>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>2/(right-left))</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-((right+left)/(right-left))</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>2/(top-bottom)</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-((top+bottom)/(top-bottom))</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-2/(far-near)</mn></mtd>
            <mtd><mn>-((tar+near)/(far-near))</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>
</div>
<br>
<br>

<pre><code class="lang-js">// Create an orthogonal matrix
// options: top, bottom, left, right, near, far
// return: DOMMatrix
orthogonal = options => {
  var top = options.top;
  var bottom = options.bottom;
  var left = options.left;
  var right = options.right;
  var near = options.near || 0;
  var far = options.far || 100;
  var rw = 1 / (right - left);
  var rh = 1 / (top - bottom);
  var rd = 1 / (far - near);
  return new DOMMatrix([
    2 * rw, 0, 0, 0,
    0, 2 * rh, 0, 0,
    0, 0, -2 * rd, 0,
    -(right + left) * rw, -(top + bottom) * rh, -(far + near) * rd, 1
  ]);
}</code>
</pre>

<p>NB: in 2D, there's no such thing as a "camera", but you can simulate panning and zooming by applying offsets and scale to all the elements in the scene. 

<br><br><hr><br>

<h4 id="3b">Reduce repetitions with indexed vertices</h4>

<p>Before starting to draw <b>meshes</b> (3D objects) that contain a lot of triangles, we need to learn an optimized way to write our data buffers.
<br>As we have seen before, data buffers (with the type gl.ARRAY_BUFFER) can hold vertex properties (position, color, texture coordinates...).
<br>These properties can be placed into multiple buffers or interleaved into a single one.
<p>In 3D, vertices are often shared between multiple triangles.
<br>Instead of repeating the same vertices many times in the same buffer, it's possible to write each vertex only once in a data buffer,
<br>and use a second buffer with the type <b>gl.ELEMENT_ARRAY_BUFFER</b> that declares all our triangles by using indices of the first object.
<p>Even if many data buffers exist in your program (positions, colors, texture coordinates...), only one index buffer can be used, and it will list indices from all the data buffers at the same time,
<br>so they all need to be stored in the same order (the 1st item of every buffer must belong to the 1st vertex, etc...).
<p>Finally, to draw indexed vertices, you need you replace gl.drawArrays with <b>gl.drawElements(type, count, type, offset)</b>.
<p>The indices stored in the index buffer have integer values (N = 0, 1, 2...), and you can choose their size in bytes depending on the number of vertices you want to index:
<br>
<table border style="max-width:600px">
<tr>
<th>Number of vertices to index
<th>Index buffer type
<th>drawElements type
<tr>
<td>0 ... 256
<td>Uint8Array([...])
<td>gl.UNSIGNED_BYTE
<tr>
<td>0 ... 65,536
<td>Uint16Array([...])
<td>gl.UNSIGNED_SHORT
<tr>
<td>0 ... 4,294,967,296
<td>Uint32Array([...])
<td>gl.UNSIGNED_INT (*)
</table>

<p>(*) In WebGL 1.0, this type needs to be enabled with <b>gl.getExtension('OES_element_index_uint');</b>. In WebGL2, it's enabled by default.

<br><br><hr><br>

<h3 id="3c">Hello cube</h3>

<p>The easiest shape to render in 3D is a cube composed of 8 points and 12 triangles.

<h5>Demo</h5>

<iframe id=i8 loading=lazy src="../../webgl-guide/editor/?demo=8"></iframe>

<h5>What happens here?</h5>

<ul>
<li>Here we are, finally drawing in 3D!
<li>To render the scene correctly, we had to enable WebGL's <b>depth sorting</b>.
<br>This mechanism ensures that only the fragments that are the closest to the camera are drawn, in order to avoid, for example, seeing the back face of the cube on top of the front face.
<br>To do that, we add <pre class="language-js inline"><code>gl.enable(gl.DEPTH_TEST);</code></pre> and update the clearing: <pre class="language-js inline"><code>gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);</code></pre> (see lines 91 and 102).
<li>Notice the index buffer (lines 56-63 + 74-76), and the use of <b>drawElements</b> (line 103) with matching types (Uint8Array / gl.UNSIGNED_BYTE).
<li>You may have noticed that the cube appears to rotate on itself, but it's actually the camera that rotates around it (see lines 93-96 + 100).
</ul>

<h5>Tips and tricks</h5>

<ul>
<li>In this demo, a 60-fps loop is made using a simple call to <pre class="language-js inline"><code>setInterval( /* loop's code */, 16);</code></pre>.
<br>This can be enhanced by syncing to the screen's refresh rate with <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">requestAnimationFrame</a>.
<br>Ex: <pre class="language-js inline"><code>var loop = function(){ requestAnimationFrame(loop); /* loop's code */}; loop();</code></pre>
<li>Remember that in every demo, you can see the triangles in wireframe by changing the first parameter of gl.grawElements to <b>gl.LINE_LOOP</b>, which makes the face diagonals visible:
</ul>
<br>

<br><img src="images/webgl-guide/wire.png" width=250>




<br><br><hr><br>

<h3 id="3d">How to color each face of the cube</h3>

<p>To color each face individually, each vertex can't have an unique color like we did above. Its color needs to vary depending on which face is being rendered.
<br>The solution is to declare all the possible combinations of vertices positions and colors in two data buffers, and use an index buffer to create the corresponding triangles.
<br>Its indeed a bit more verbose, but still the simplest way to achieve it.

<br>The same principle applies if you want to make a cube with different textures on each face (each combination of vertex position and texture coordinates must be declared separately).

<h5>Demo</h5>

<iframe id=i9 loading=lazy src="../../webgl-guide/editor/?demo=9"></iframe>

<h5>What happens here?</h5>

<p>The vertex positions and colors are split in two data buffers to improve readability. Each line declares the 4 vertices composing one (square) face of the cube (lines 34-51).
<br>Then, the index buffer makes two triangles from the vertices of each face, and recycles the vertices placed on the diagonal (lines 53-60).
<br>With this indexing, we only need to declare 24 vertices (4 per face) instead of 36 (3 per triangle x 12 triangles).
<br>
<h5>Tips and tricks</h5>

<p>I added the cube declaration in a helper file called <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/shapes.js">shapes.js</a> to avoid repeating it in the next demos:

<pre><code class="lang-js">// Declare a cube (2x2x2)
// Returns [vertices (Float32Array), normals (Float32Array), indices (Uint16Array)] 
//
//    v6----- v5
//   /|      /|
//  v1------v0|
//  | |     | |
//  | |v7---|-|v4
//  |/      |/
//  v2------v3

cube = (r = 1, g = 1, b = 1) => {

  var vertices = new Float32Array([
     1.0, 1.0, 1.0,  -1.0, 1.0, 1.0,  -1.0,-1.0, 1.0,   1.0,-1.0, 1.0, // front
     1.0, 1.0, 1.0,   1.0,-1.0, 1.0,   1.0,-1.0,-1.0,   1.0, 1.0,-1.0, // right
     1.0, 1.0, 1.0,   1.0, 1.0,-1.0,  -1.0, 1.0,-1.0,  -1.0, 1.0, 1.0, // up
    -1.0, 1.0, 1.0,  -1.0, 1.0,-1.0,  -1.0,-1.0,-1.0,  -1.0,-1.0, 1.0, // left
    -1.0,-1.0,-1.0,   1.0,-1.0,-1.0,   1.0,-1.0, 1.0,  -1.0,-1.0, 1.0, // down
     1.0,-1.0,-1.0,  -1.0,-1.0,-1.0,  -1.0, 1.0,-1.0,   1.0, 1.0,-1.0  // back
  ]);

  var normals = new Float32Array([
    0.0, 0.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0, 1.0,  // front
    1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0,  // right
    0.0, 1.0, 0.0,   0.0, 1.0, 0.0,   0.0, 1.0, 0.0,   0.0, 1.0, 0.0,  // up
   -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  // left
    0.0,-1.0, 0.0,   0.0,-1.0, 0.0,   0.0,-1.0, 0.0,   0.0,-1.0, 0.0,  // down
    0.0, 0.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,-1.0   // back
  ]);

  var indices = new Uint16Array([
    0, 1, 2,   0, 2, 3,  // front
    4, 5, 6,   4, 6, 7,  // right
    8, 9, 10,  8, 10,11, // up
    12,13,14,  12,14,15, // left
    16,17,18,  16,18,19, // down
    20,21,22,  20,22,23  // back
  ]);
  
  return [vertices, normals, indices];
};</code></pre>

<p>In bonus, <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/shapes.js">shapes.js</a> also contains the models for a plane, a sphere and a pyramid.
<br>You can try them in all the following demos by replacing cube() with <b>plane()</b>, <b>sphere()</b> or <b>pyramid()</b>.

<br><br><img src="images/webgl-guide/othershapes.png" width=750>

<br><br>NB: all the shapes in shapes.js use Uint16Array's for indices, so if you use them, be sure to use the type <b>gl.UNSIGNED_SHORT</b> in drawElements().

<br><br><hr><br>

<h4 id="3e">Lighting and shading</h4>
<p>The terms lighting and shading are often used without distinction but they actually represent two different things:
<ul>
<li><b>Lighting</b> is a physics notion, representing how the light affects an object in the real world or in a 3D scene.
<li><b>Shading</b> is specific to computer graphics, and indicate how the pixels are rendered on a screen according to lighting.
</ul>
<p>Sometimes, lighting is also referred to as <b>coloring</b>, and it makes sense when you think about it, as the apparent color of an object is produced by the lightwaves it absorbs and/or reflects.
<p>Most 3D scenes need a minimum of shading to avoid looking flat and confusing, even a simple colored cube:
<p>
<img src="images/webgl-guide/shading.png" width=500>
<br>In the first case, all the pixels are the same color, which doesn't look natural.<br>In the second case, every face has a different color, but our brains interpret in as a shaded, red cube.

<p>There are many different ways to light a 3D scene, here are the five main ones:

<h5>1) Diffuse light</h5>
<p>Diffuse light (also called <b>directional light</b>) is the equivalent of the sun's light on Earth: all the rays are parallel and have the same intensity everywhere in the scene.
<br>When it hits a surface, it is reflected in all directions, but the intensity of the reflexion decreases proportionally to the angle in which the light hits the surface:
<br><br><img src="images/webgl-guide/diffuse.png">
<br>To simulate this, we need to define a light source with a color (for example, white), and a direction (for example, vec3(0.5, 3.0, 4.0)).

<br>The color set by the fragment shader is equal to the light's color (rgb) * the face color (rgb) * the dot product of the triangle's normal and the light. The color's alpha is fixed to 1.0.
<br>If the dot product is negative, we set it to zero (there can't be a negative amount of light). This is done with <b>max(dot(lightDirection, normal), 0.0);</b> (see line 24 below).
<br>Note: it's a good practice to re-normalize the normals in the shaders to ensure they have the right length. This is done with <b>normalize()</b>. (also on line 24).
<p>
<b>Demo</b>
<p>
<iframe id=i10 loading=lazy src="../../webgl-guide/editor/?demo=10"></iframe>

<br><h5>2) Ambient light</h5>

<p>With diffuse lighting alone, some faces are too dark, like the rightmost one in the previous demo. To fix that, we can add an ambient light reflexion.
<br>It's a light that is applied equally to all the triangles in the scene, regardless to their normal vector.
<br>To simulate it, we need to set a light color (not too bright, for example: vec3(0.2, 0.2, 0.2)), multiply it with the surface color, and add it to the diffuse light (see line 34 below):
<p>
<b>Demo</b>
<p>
<iframe id=i11 loading=lazy src="../../webgl-guide/editor/?demo=11"></iframe>

<br>
<h5>3) Point light</h5>

<p>We can also have a <b>point light</b> representing a light bulb, with a specific position and color.
<br>It's similar to diffuse light, except that the light rays are not parallel, because the light source is not "infinitely" far away: it's in the scene and emits lights in all directions.
<br>With a point light, the shading intensity will vary according to the angle of the light rays, but also according the distance from the light source to the object: it's called <b>light attenuation</b>.
<br>In the real world, the light attenuation is proportional to the distance squared (d²), but in computer graphics, it usually looks better to make it proportional to the distance (not squared).
<br>When a point light reflexion is computed per vertex, it looks a bit nicer than the flat colors above, but the triangles are still visible:
<br>
<br><img src="images/webgl-guide/per_vertex.png" width=500>
<br>
<br>The best solution consists in computing the right color for every fragment of the scene (i.e. every pixel) according to its distance from the light source,<br>and that's exactly what the fragment shader is here for:
<br><br><img src="images/webgl-guide/sphere.png" width=500>
<!--p>It looks better (less polygonal) like that because each fragment interpolates the normal vector from the neighbour vertices, the same way it interpolates colors and texture coordinates:

<br><br><img src="images/webgl-guide/normal-inter.png" width=400-->

<br>

<p>The following demo shows how a point light can be computed per fragment.
<br>The vertex shader sends the vertices positions, colors and normals to the fragment shader using three varyings, and the fragment shader computes everything.
<p><b>Demo</b>
<p>
<iframe id=i12 loading=lazy src="../../webgl-guide/editor/?demo=12"></iframe>

<h4>4) Spot light</h4>

<br><br><img src="images/webgl-guide/spot.jpg" width=200>

<p>A <b>spot light</b> is very similar to a point light, except that it does not emit light rays in all directions, but rather inside a given "cone".
<br>When this cone hits a surface, the resulting lighting is elliptic, like a spot. In the real world, this is similar to a torchlight.
<p>To implement it, we can start from a point light, to which we add a direction (like we had in the diffuse light) and an angle (like the camera's "field of view" angle, but for the light source).
<br>Then, the diffuse light is only computed for the fragments where the dot product of the spot direction and the spot-to-surface vector is bigger than the cosine of the spot's angle.
<br>(If the dot product is smaller than the angle's cosine, it means that we're outside of the light cone.)

<p>Here's the code added to the point light demo to transform it into a 20° spot light:

<table border style="table-layout:fixed" class=grey>
<tr>
<td style=width:auto;padding:15px>
Fragment shader:

<pre><code class=lang-js>uniform vec3 spotDirection;
uniform float spotAngle;

(...)

// Compute diffuse light
vec3 diffuse = vec3(0.0, 0.0, 0.0);
float dotSpotLight = dot(normalize(spotDirection), -normalize(lightDirection));

// Apply the diffuse light inside the spot's "field of view"
if(dotSpotLight > spotAngle){
  diffuse = lightColor * v_color.rgb * nDotL;
}

// Outside of the spot's fov, also apply the diffuse light, but attenuated (optional)
else {
  diffuse = lightColor * v_color.rgb * nDotL * vec3(0.2, 0.2, 0.2);
}</code></pre>

<br>JavaScript:

<pre><code class=lang-js>// Set the spot direction and angle
var spotdirection = gl.getUniformLocation(program, 'spotDirection');
gl.uniform3f(spotdirection, -1, -1, -1);

var spotAngle = gl.getUniformLocation(program, 'spotAngle');
gl.uniform1f(spotAngle, Math.cos(deg2rad(20)));</code></pre>

<td style="width:400px;max-width:400px;padding:15px;vertical-align: top">
Demo:
<p>
<a href="../../webgl-guide/editor/?demo=12/spot"><img src="images/webgl-guide/spot.png" width=350></a>

<br>(click the image to open the full editor)
</table>

<h5>5) Specular light</h5>

<img src="images/webgl-guide/specular.png" width=600>
<img src="images/webgl-guide/spec.gif" width=250>
<br>
<br>
<p>When an object is shiny, it can reflect a point light like a mirror under a certain angle. The result looks like a spot light, but it's very different.
<br>Specular light is actually the only light in this list that relies on the camera's position to be computed: when the camera moves, the reflect moves too.
<br>To implement it, we need to:
<ul>
<li>Create a new uniform vector containing the camera's coordinates.
<li>Compute the vector between the current fragment and the camera.
<li>Compute the vector between the current fragment and the light source (like in the previous demos).
<li>Choose a level of "shininess" (the intensity of the reflect), for example around 100 for a metallic object.
<li>Reflect the fragment-to-light vector on the triangle's surface, i.e. compute its symmetric vector according to the surface's normal.
<br><b>reflect(vector, mirror)</b> is a native GLSL function that mirrors a vector based on another vector, and it's exactly what we need here, in order to check if the reflect hits the camera.
<li>Compute the dot product between the reflect and the fragment-to-camera vector, powered to the surface's "shininess": <b>pow(dot(reflect, toCamera))</b>
<li>Multiply the result with the light's color and add it to the other (ambient / diffuse) lights.
</ul>

<p>Here's a demo that combines diffuse, ambient and specular lighting.
<br>This combination is also called <b>Phong reflection</b>.
<p><b>Demo</b>
<p>
<iframe id=i13 loading=lazy src="../../webgl-guide/editor/?demo=13"></iframe>

<br><br><hr style="width:500px"><br>

<h5>Smooth shading</h5>

<p>By default, the normal vector of a triangle is reused by all its vertices.
<br>This provokes a <b>facetted</b> (or polygonal) rendering, where neighbour triangles are separated by a visible "hard edge".
<br><b>Smooth shading</b> (or "Phong shading"), consists in computing a different normal for each vertex, equal to the mean of the normals of all the triangles around it.

<br><br><a href="https://www.toptal.com/javascript/3d-graphics-a-webgl-tutorial"><img src="images/webgl-guide/softshading.png" width=600></a>

<p>This computation can be done outside of your WebGL program, and if you work with 3D models, most 3D editors allow to export them with or without smooth shading.
<br>The only difference you'll see is that each vertex will have a specific normal vector, instead of the faces normals.

<p>Fun fact: there's no need to use divisions to obtain this mean value! Just normalize the sum of all the neighbour faces normals and you're good! (more info on <a href="https://www.iquilezles.org/www/articles/normals/normals.htm">iquilezles's website</a>)
<br>Also, since the normal is now a varying vector interpolated for each fragment, the fragment shader needs to re-normalize it to stay accurate at each pixel.
<br>Example: here's the same 3D model with smooth shading disabled / enabled (more info about loading 3D models in the <a href="webgl-guide-part-2.html#5a">part 2</a> of this guide!):
<br><br><img src="images/webgl-guide/w5.gif" width=650>

<br><br><hr style="width:500px"><br>

<h5>How about raytracing?</h5>

<p>You may have heard about <b>raytracing</b> as a way to produce protorealistic lights and reflections in 3D scenes, but this is actually a whole other domain of computer graphics.

<br><br><img src="images/webgl-guide/emissive.png">

<br><br>Raytracing can be done with WebGL, but not with a bunch of triangles.
<br>Like <b>raycasting</b>, it consists in rendering a scene by casting a virtual light ray for every pixel of the canvas, and let it reflect, refract and cast shadows according to real world's physics.
<br>It also enables more advanced lighting modes, such as <b>Emissive lighting</b>, where an object is self-illuminated, glows and affects the the surrounding objects like a light source.

<p>I won't cover it in this guide but you can find more info on <a href="https://www.shadertoy.com/results?query=tag%3Draytracer">codepen</a> and in <a href="<a href="http://www.pbr-book.org/">this e-book about physics based rendering</a>.

<br><br><hr><br>

<h4 id="3f">How to transform a 3D model</h4>

<p>So far, we've only transformed the camera matrix to make it revolve around the cube, which created an illusion of cube rotation.
<br>Now that we learned how to place a fixed light in the scene, if we want to rotate, translate or scale a cube without touching the rest of the scene, we need to do three things:
<ul>
<li>Introduce a <b>model matrix</b> (the transformation matrix of the cube), aside from the camera matrix.
<li>Compute <b>gl_Position</b> in the vertex shader by multiplying each vertex with the camera matrix (as we did before) <i>AND</i> with the model matrix.
<li>Now that the model has been modified, all its face normals must be recomputed in order to apply lighting correctly.
</ul>
<p><b>How to update the normals efficiently</b>
<p>It's possible to recompute all the faces normals from scratch in (with a cross product) but it would represent a huge amount of processing power.
<br>In practice, the best approach is to keep the original normals unchanged, and provide the vertex shader with a single transformation matrix that can be used to update all of them.
<br>This matrix is called the <b>inverse transpose</b> of the model matrix (in other words, the transpose ob the inverse of the model matrix).
<ul>
<li>In JS, you can create it by doing:
<pre class="language-js"><code>var inverseTransposeMatrix = new DOMMatrix(modelMatrix);
inverseTransposeMatrix = transpose(inverseTransposeMatrix.invertSelf());</code></pre>

<li>And in the fragment shader, you can apply it by doing:
<pre class="language-js"><code>vec3 v_normal = vec3(inverseTranspose * normal)</code></pre>
</ul>

<p>If you're doing an animation, the inverse transpose matrix must be computed once per frame, for each object in the scene, in JS, and passed to the vertex shader.

<h5>Demo</h5>

<p>Here's a cube rotating on itself with a fixed camera and a fixed point light:

<br><br>

<iframe id=i14 loading=lazy src="../../webgl-guide/editor/?demo=14"></iframe>

<h5>What happens here?</h5>

<ul>
<li>When the page loads, the cube, the light and the camera matrix are set as usual. (lines 65-102).
<li>Three new matrices are introduced: <b>model</b> (the model matrix), <b>inverseTranspose</b> and <b>mvp</b> (the model view projection matrix, equal to cameraMatrix * modelMatrix).
<li>In the loop executed 60 times per second, we update the cube's Y angle (line 114), then recompute the model matrix (lines 116-119), the mvp matrix (lines 122-124),<br>the inverse transpose matrix (lines 127-129), and send them to WebGL as uniforms, before rendering the scene.
<li>A new model matrix is created at each frame to represent the cube's angle (line 120). Wou may wonder why we don't use a single matrix that we rotate a little at each frame?
<br>It's a better practice to start from scratch at each frame to avoid piling up rounding errors after each little angle increment, which can lead to big imprecisions in the long run.
<li>The vertex shader applies the mvp matrix to the current vertex (line 23), and sends three varyings (position, normal and color) to the fragment shader.
<li>The fragment shader does nothing new. As far as it is concerned, its task is still to compute a shading from the variables at its disposal.
</ul>

<!--h5>Tips and tricks</h5>

<ul>
<li>The mvp matrix introduced above is precomputed in JavaScript to avoid recomputing it for every vertex, just like we did for combined transformation matrices.
<li>Here are the inverse() and inverseTranspose() functions added in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/matrix.js">matrix.js</a>:
</ul>

<pre><code class="lang-js" style=font-size:10px>// Get the inverse of a mat4
inverse = m => {
  var inv = new Float32Array([
     m[5]*m[10]*m[15] - m[5]*m[11]*m[14] - m[9]*m[6]*m[15] + m[9]*m[7]*m[14] + m[13]*m[6]*m[11] - m[13]*m[7]*m[10],
    -m[1]*m[10]*m[15] + m[1]*m[11]*m[14] + m[9]*m[2]*m[15] - m[9]*m[3]*m[14] - m[13]*m[2]*m[11] + m[13]*m[3]*m[10],
     m[1]*m[6]*m[15]  - m[1]*m[7]*m[14]  - m[5]*m[2]*m[15] + m[5]*m[3]*m[14] + m[13]*m[2]*m[7]  - m[13]*m[3]*m[6],
    -m[1]*m[6]*m[11]  + m[1]*m[7]*m[10]  + m[5]*m[2]*m[11] - m[5]*m[3]*m[10] - m[9]*m[2]*m[7]   + m[9]*m[3]*m[6],
    -m[4]*m[10]*m[15] + m[4]*m[11]*m[14] + m[8]*m[6]*m[15] - m[8]*m[7]*m[14] - m[12]*m[6]*m[11] + m[12]*m[7]*m[10],
     m[0]*m[10]*m[15] - m[0]*m[11]*m[14] - m[8]*m[2]*m[15] + m[8]*m[3]*m[14] + m[12]*m[2]*m[11] - m[12]*m[3]*m[10],
    -m[0]*m[6]*m[15]  + m[0]*m[7]*m[14]  + m[4]*m[2]*m[15] - m[4]*m[3]*m[14] - m[12]*m[2]*m[7]  + m[12]*m[3]*m[6],
     m[0]*m[6]*m[11]  - m[0]*m[7]*m[10]  - m[4]*m[2]*m[11] + m[4]*m[3]*m[10] + m[8]*m[2]*m[7]   - m[8]*m[3]*m[6],
     m[4]*m[9]*m[15]  - m[4]*m[11]*m[13] - m[8]*m[5]*m[15] + m[8]*m[7]*m[13] + m[12]*m[5]*m[11] - m[12]*m[7]*m[9],
    -m[0]*m[9]*m[15]  + m[0]*m[11]*m[13] + m[8]*m[1]*m[15] - m[8]*m[3]*m[13] - m[12]*m[1]*m[11] + m[12]*m[3]*m[9],
     m[0]*m[5]*m[15]  - m[0]*m[7]*m[13]  - m[4]*m[1]*m[15] + m[4]*m[3]*m[13] + m[12]*m[1]*m[7]  - m[12]*m[3]*m[5],
    -m[0]*m[5]*m[11]  + m[0]*m[7]*m[9]   + m[4]*m[1]*m[11] - m[4]*m[3]*m[9]  - m[8]*m[1]*m[7]   + m[8]*m[3]*m[5],
    -m[4]*m[9]*m[14]  + m[4]*m[10]*m[13] + m[8]*m[5]*m[14] - m[8]*m[6]*m[13] - m[12]*m[5]*m[10] + m[12]*m[6]*m[9],
     m[0]*m[9]*m[14]  - m[0]*m[10]*m[13] - m[8]*m[1]*m[14] + m[8]*m[2]*m[13] + m[12]*m[1]*m[10] - m[12]*m[2]*m[9],
    -m[0]*m[5]*m[14]  + m[0]*m[6]*m[13]  + m[4]*m[1]*m[14] - m[4]*m[2]*m[13] - m[12]*m[1]*m[6]  + m[12]*m[2]*m[5],
     m[0]*m[5]*m[10]  - m[0]*m[6]*m[9]   - m[4]*m[1]*m[10] + m[4]*m[2]*m[9]  + m[8]*m[1]*m[6]   - m[8]*m[2]*m[5]
  ]);
  det = m[0]*inv[0] + m[1]*inv[4] + m[2]*inv[8] + m[3]*inv[12];
  if(!det) return m;
  det = 1 / det;
  for(var i = 0; i < 16; i++) {
    inv[i] *= det;
  }
  return inv;
};

// Get the inverse transpose of a mat4
inverseTranspose = m => transpose(inverse(m));</code></pre>
<br>As you can see, the inversion algorithm is a bit hairy, so it's better to do it the as few times per second as possible.  (Once per frame, in JS, is the best solution)
<br>Nevertheless, this inverse transpose is very useful for other life-saving tricks, as we will see in the part 2 of this guide!-->

<br><br><hr><br>

<h4 id="3g">Drawing many cubes</h4>

<p>To draw many cubes at once, it's of course possible to declare the vertices coordinates, colors and normals of each cube separately, but that would be very verbose.
<br>Instead, we can consider the cube we already declared as a reusable model.
<br>For each cube we want to draw, we simply need to transform it (by giving it a new model matrix, mvp matrix and inverse transpose matrix), and render it.
<br>

<h5>Demo</h5>

<p>Here's a demo with 3 red <b>cuboids</b> (deformed cubes)
<br><br>
<iframe id=i15 loading=lazy src="../../webgl-guide/editor/?demo=15"></iframe>

<h5>What happens here?</h5>

<ul>
<li>A function <b>renderCube()</b> (lines 108-127) prepares and render a cube from the data buffer defined above (lines 65-79)
<li>This function has translate and scale parameters, that it applies to the modelMatrix. It also creates a mvp matrix and an inverse transform matrix.
<li>The finction is called three times (after the canvas clear) to render the three cuboids.
</ul>

<h5>Tips and tricks</h5>

<p>I added a generic drawShape() function in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/shapes.js">shapes.js</a>, with optional transformation. It is able to (re)render the same model many times.

<pre><code class="lang-js">// Draw a model
drawModel = (gl, program, cameraMatrix, modelMatrix, n, transform) => {
  
  // Set the model matrix (add the custom scale if any)
  var model = gl.getUniformLocation(program, 'model');
  modelMatrix = (new DOMMatrix(modelMatrix)).preMultiplySelf(transform));
  gl.uniformMatrix4fv(model, false, modelMatrix);

  // Set the cube's mvp matrix (camera x model)
  var mvpMatrix = (new DOMMatrix(modelMatrix).preMultiplySelf(cameraMatrix);
  var mvp = gl.getUniformLocation(program, 'mvp');
  gl.uniformMatrix4fv(mvp, false, mvpMatrix);

  // Set the inverse transpose of the model matrix
  var inverseTransposeMatrix = transpose((new DOMMatrix(modelMatrix)).invertSelf());
  var inverseTranspose = gl.getUniformLocation(program, 'inverseTranspose');
  gl.uniformMatrix4fv(inverseTranspose, false, inverseTransposeMatrix);

  // Render
  gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_SHORT, 0);
};</code></pre>

<br><br><hr><br>


<h4 id="3h">Hierarchical objects</h4>

<p>A <b>hierarchical object</b> is a 3D model made of several basic objects (called <b>segments</b>), for example a robotic arm.
<br><b>Joints</b> are where the segments are linked and rotate relatively to each other, like an elbow or a wrist.
<br>To keep the segments linked to each other, the transformation matrix is inherited from segment to segment (ex: a hand will apply its own transformation matrix on top of the arm's one). 
<p>The following demo shows an robotic arm made of three cuboids (click the buttons below to make it move).
<br>

<h5>Demo</h5>

<iframe id=i16 loading=lazy src="../../webgl-guide/editor/?demo=16"></iframe>

<h5>What happens here?</h5>

<ul>
<li>You can see on lines 143-146 that the vertical "arm" cuboid can rotate around its X axis, and once it's rotated, we perform a "-2" translation along Y.
<br>As described in the "transformations" chapter, this allows to make the cuboid rotate around a pivot point placed at its extremity (the "elbow", 2 units higher) instead of its center.
<li>Then, on lines 148-150, the hand cuboid, which is attached at the end of the arm cuboid, inherits its model matrix, and updates it to add its own rotation and translation.
<br>(the rotation happens along the Y axis, and the translation places the hand at the end of the arm).
</ul>

<h5>Tips and tricks</h5>
<ul>
<li>The matrix inheritance hierarchy is also called <b>scene graph</b>.
<li>This process can be repeated many times to make a multi-joint object, like an entire robot or a rope made of many segments!
<li>If many segments are attached to the same parent (for example, the fingers of a hand), they must all reuse their parent's matrix (for example, see <a href="https://xem.github.io/webgl-guide/book/ch09/MultiJointModel.html">multi-joint demo</a>).
</ul>

<br><img src="images/webgl-guide/6cubes.gif" width=250> 


<br><br><hr><br>

<h4 id="4">Debugging</h4>

<p>Many kinds of errors can be present in your WebGL shaders or occur on runtime. The most frequent I've encountered are:
<ul>
<li>Missing semicolon at the end of a line.
<li>Missing decimal part in a float number (1 is an int, 1.0 is a float).
<li>Trying to change the value of a const variable.
<li>Trying to set a value already set by an uniform or a varying (they are read-only).
<li>Trying to set a non-constant limit in a for-loop.
<li>Trying to use a function recursively (recursivity is not allowed).
<li>Trying to use === or !== operators (they don't exist).
<li>Mismatching int or float precision for a variable read by both shaders.
</ul>
<br>
<p>Other errors can be made in the JS program, and can sometimes fail silently. especially:
<ul>
<li>Using the bad count parameter for gl.drawArrays or gl.drawElements (it must be the number of vertices to draw, not the number of triangles).
<li>Using the wrong combination of types for an index buffer and gl.drawElements (ex: Uint16Array only work with gl.UNSIGNED_SHORT).
<li>Not passing the right amount of data in attributes or uniforms (ex: 4 floats in a vec3).
</ul>
<br>
<p>Finally, if no syntax errors were made but nothing appears, check if:
<ul>
<li>The camera looks in the right direction (and with a correct fov angle if there's a perspective matrix, usually around 50 degrees).
<li>The light source is not too dark or trapped inside a 3D object.
<li>Your normals are not inverted (they must point "outside" to let the object reflect the light correctly).
<li>You didn't accidentally set any color's alpha to 0.0.
<li>You're not drawing gl.POINTS that are too big or have their center placed outside of the canvas.
</ul>


<br><br><hr><br>

<h4 id="5">WebGL 2.0</h4>
<p>
As I said in the introduction, WebGL 2.0 brings new features and changes a few things compared to WebGL 1.0.
<br>I decided to not write a WebGL 2.0 guide due to its limited browser support and its new syntax rules that I personally find more confusing than useful.</p>
Anyway, if you want to enable it, you need to change the canvas context creation: <pre class=inline><code class="lang-js">canvas.getContext("webgl2");</code></pre> and add <pre class=inline><code class="lang-js">#version 300 es</code></pre> on the very first line of your shaders.
<br>
<br>Here are the most important changes:
<br><ul>
<li><b>attribute</b> must be renamed as <b>in</b> inside the shaders (ex: <b>in vec4 a_position;</b>).
<li><b>varyings</b> must be renamed as <b>out</b> in the vertex shader and <b>in</b> in the fragment shader.
<li><b>gl_FragColor</b> doesn't exist anymore. Instead, the fragment shader needs to declare its own <b>out vec4 fragColor;</b> before main() and set its value inside main().
<li>The fragment shader can edit the depth buffer directly using the global <b>gl_FragDepth</b>.
<li>New <b>types</b>: uint, bvec2/3/4 (boolean vectors), ivec2/3/4 (integer vectors), uvec2/3/4 (uint vectors), mat2x3, mat2x4, mat3x4, mat4x3, mat4x2, mat3x2 and a bunch of new Samplers.
<li>New boolean <b>operators</b>: %, &lt;&lt;, >>, &amp;, ^, |, &lt;&lt;=, >>=, &=, ^=, |=.
<li>New <b>matrix functions</b>: inverse(), transpose().
<li>Loops bounds do not need to be constant anymore. 
<li>The functions <b>texture2D</b> and <b>textureCube</b> are now simply called <b>texture</b>.
<li>Mipmapping now works on textures even if their width and height are not a power of 2.
<br>In summary, mipmaps are smaller versions of a 2D texture (size/4, size/8 size/16 ...), used by WebGL when a textured object is moving away from the camera.
<br>They can be generated with <b>gl.generateMipmap(gl.TEXTURE_2D)</b> or provided by the developer/artist.
<br>The GLSL function <b>textureSize(sampler, lod)</b> gives you the mipmap texture size for a given level of detail.
<br>And the function <b>texelFetch(sampler, ivec2(x,y), lod)</b> gives you the value of a given texel in this texture.
<li>Most <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getExtension">extensions</a> don't need to be loaded anymore, as they are enabled by default.
<li>In particular, <b>Vertex array objects</b> are now available natively and allow to cache the attributes binding, leading to a performance boost in programs doing many draw calls per frame:
<pre><code class="lang-js">// Just after WebGL setup
var vao = gl.createVertexArray();
gl.bindVertexArray(vao);

// (bind attributes as usual: floats, vec4, buffers...)

// Then, before each draw call:
gl.bindVertexArray(vao);</code></pre>
<li>Similarly, <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext#Uniform_buffer_objects">Uniform Buffer Objects</a> can be used to cache uniforms, but it's harder to setup and generally less useful as uniforms tend to be rarely updated.
</ul>

<br><br><hr><br>

<h4 id="6">To be continued...</h4>

<p>At this point we've covered all the basis of 2D and 3D rendering in WebGL 1.0 and 2.0!
<br>For the record, this single page contained more information than 430 pages of <a href="https://www.oreilly.com/library/view/webgl-programming-guide/9780133364903/ch01.html">the book</a> and 3/4 of the <a href="https://webgl2fundamentals.org/">site</a> that inspired it at the beginning. Did I invent tutorial golfing? :D
<br>I could have made it longer but unfortunately, most browsers can't display more than 16 WebGL canvas contexts in the same page...
<br>so all the advanced techniques will be in the upcoming part 2... and maybe a book one day?



<br><br><hr><br>

<div style="background:#fff4e1; border-radius: 20px; padding: 10px 20px 20px">

<h4 id="7">Bonus: WebGL and code-golfing</h4>
<br>
<details>
<summary>If you're interested in extreme minification and compression, click here to open!</summary>

<br>
<p><b>Introduction</b>
<p>Despite my efforts to make the demos of this guide as short as possible, you may have noticed that the WebGL API and the GLSL language are extremely verbose.
<br>Though, if you're into code-golfing like me, you may be interested in making tiny WebGL programs, or even games that fit in <a href="//js1k.com">1kb</a>, or <a href="//js13kgames.com">13kb</a>...
<br>As I said in the intro, the Codegolf Team and I already golfed a Shadertoy-like boilerplate in <a href="https://xem.github.io/articles/webgl_quest.html">242 bytes</a> and a raymarching algorithm for Signed Distance Functions (SDF) in <a href="https://xem.github.io/articles/webgl_quest_2.html">135 bytes</a>.
<br>Keep in mind that SDF are by far the shortest way to display geometrical and fractal shapes (cubes, spheres, torus, mandelboxes, ...) without any triangle.
<br>Nevertheless, here's a list of tricks you can use to golf a "real" WebGL app, with vertices, triangles, normals, matrices, textures, etc...!
<br>
<br>
<p><b>1. Writing less lines of code</b>
<p>If you're on a tight byte budget, there are a number of optimizations that you can remove from your code:
<ul>
<li>Remove all unnecessary HTML: <b>&lt;!doctype html></b>, <b>&lt;meta charset=utf-8></b>, <b>&lt;html></b>, <b>&lt;head></b>, <b>&lt;title></b>, <b>&lt;body></b>, ...
<li>Remove quotes around HTML attributes: <b>&lt;canvas id=canvas width=400 height=400></b> ...
<li>Put all your JavaScript code in a single <b>&lt;script></b> tag.
<li>Remove error logs:
<pre class=lang-js><code>// console.log('vertex shader:', gl.getShaderInfoLog(vs) || 'OK');
// console.log('fragment shader:', gl.getShaderInfoLog(fs) || 'OK');
// console.log('program:', gl.getProgramInfoLog(program) || 'OK');</code></pre>
<li>Don't set a "clear color" for your WebGL canvas (the background will be transparent by default and <b>gl.enable(gl.DEPTH_TEST)</b> will still work):
<pre class=lang-js><code>// gl.clearColor(0, 0, 0, 1);
// gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);</code></pre>
Note: black background can still be obtained with css: <pre class="lang-html inline"><code>&lt;canvas id=canvas style=background:#000></code></pre>
<!--li>Use radians directly for angles, to avoid the conversion from degrees (you can even avoid using the constant Math.PI, and round the result a little):
<pre class=lang-js><code>// deg2rad = angle => Math.PI * angle / 180;
// perspective({fov: deg2rad(30)})
// perspective({fov: Math.Pi / 6})
perspective({fov: .5}) /* ~28.6deg */</code></pre-->
<li>Get rid of the "mvp" matrix by multiplying modelMatrix and cameraMatrx natively in the vertex shader:
<pre class=lang-js><code>/* GLSL */
// uniform mat4 mvp;
// gl_Position = mvp * position;
gl_Position = model * camera * position;
</code></pre>
<li>Use the model matrix instead of the inverse transpose matrix to update the normals (in general they're identical. The inverse transform is only useful for complex transformations).
<!--li>If you really need the inverse transpose, you can compute it in the fragment shader directly to avoid implementing inverse() / transpose() in JavaScript (<b>WebGL 2.0 only</b>):
<pre class=lang-js><code>/* GLSL */
// uniform mat4 inverseTranspose;
mat4 inverseTranspose = transpose(inverse(model));

(...)


/* JS */
// var inverseTranspose = gl.getUniformLocation(program, 'inverseTranspose');
// var inverseTransposeMatrix = transpose(inverse(modelMatrix));
// gl.uniformMatrix4fv(inverseTranspose, false, inverseTransposeMatrix);</code></pre>
<li>You can also get rid of the JavaScript implementation of multMat4Mat4() by sending all your transformation matrices to the fragment and multiplying them natively there:
<pre class=lang-js><code>/* GLSL */
// uniform mat4 model;
uniform mat4 rotate;
uniform mat4 translate;
uniform mat4 scale;

(...)

/* JS */
// v_position = vec3(model * camera * position);
v_position = vec3(scale * rotate * translate * camera * position);</code></pre>
<li>You can remove the transform() helper function too, and put the matrices you want directly in your code.-->
<li>Don't re-normalize the varying normals in the fragment shader. The only risk is having a normal that doesn't measure exactly 1, but the shading difference might not be visible.
<li>Only use <b>uniforms</b> for ints / floats / vectors / matrices inputs.
<li>If gzip compression is allowed, get rid of indices. You can use <b>drawArrays</b> (unindexed vertices), as repeated coordinates, colors, etc... compress very well.
</ul>
<br>
<p><b>2. Writing less characters (a bit dirtier)</b>
<ul>
<li>Use ints instead of floats when it's possible.
<li>Use <b>lowp</b> float precision for the fragment shader.
<li>Remove redundant variables (vshader, fshader, attribute/uniform locations...):
<pre class=lang-js><code>// Put shader source code directly inside shaderSource
var vs = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vs, `void main(){...}`);

(...)

// Don't use a temp var for attribute location
gl.vertexAttrib1f(gl.getAttribLocation(program, 'size'), 10);</code></pre>
<li>Remove parenthesis in functions that have a single string as parameter (more info <a href="//xem.github.io/articles/webspeech.html">in this golfing tricks page</a>):
<pre class=lang-js><code>var gl = canvas.getContext`webgl`;</code></pre>
<li>Make <b>gl.</b> implicit:
<pre class=lang-js><code>with(canvas.getContext`webgl`){ /* JS program without any "gl." */ }</code></pre>
<li>Make all JavaScript variables global (no var/let/const).
<li>Use a minifier to remove every redundant whitespace and line break, and rename every variable / shader input into 1 character (see <a href="http://www.ctrl-alt-test.fr/glsl-minifier/">GLSL minifier</a>, <a href="https://xem.github.io/terser-online/">JS minifier</a>).
<li>Rename the canvas's id as "c", and remove the closing tag <b>&lt;/canvas></b>
</ul>
<br>
<p><b>3. Extra golfing (super dirty)</b>
<ul>
<li>Replace all the WebGL constants with their numerical value. Here are the most used ones (full list available on <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants">MDN</a>):
<pre class=lang-js style="columns:2;column-gap:10px;"><code>// Shaders
gl.FRAGMENT_SHADER       // = 35632
gl.VERTEX_SHADER         // = 35633
...

// Clear
gl.DEPTH_BUFFER_BIT      // = 256
gl.COLOR_BUFFER_BIT      // = 16384

// drawArrays / drawElements
gl.POINTS                // = 0
gl.LINES                 // = 1
gl.LINE_LOOP             // = 2
gl.LINE_STRIP            // = 3
gl.TRIANGLES             // = 4
gl.TRIANGLE_STRIP        // = 5
gl.TRIANGLE_FAN          // = 6

// Blend (more details in part 2)
gl.ZERO                  // = 0
gl.ONE                   // = 1
gl.SRC_ALPHA             // = 770
gl.ONE_MINUS_SRC_ALPHA   // = 771
...

// Buffers
gl.STATIC_DRAW           // = 35044
gl.ARRAY_BUFFER          // = 34962
gl.ELEMENT_ARRAY_BUFFER  // = 34963
gl.BUFFER_SIZE           // = 34660
...
// Enable
gl.BLEND                 // = 3042
gl.DEPTH_TEST            // = 2929
...

// Data types
gl.BYTE                  // = 5120
gl.UNSIGNED_BYTE         // = 5121
gl.SHORT                 // = 5122
gl.UNSIGNED_SHORT        // = 5122
gl.INT                   // = 5124
gl.UNSIGNED_INT          // = 5125
gl.FLOAT                 // = 5126

// Textures
gl.TEXTURE_2D            // = 3553
gl.TEXTURE_MAG_FILTER    // = 10240
gl.TEXTURE_MIN_FILTER    // = 10241
gl.TEXTURE_WRAP_S        // = 10242
gl.TEXTURE_WRAP_T        // = 10243
gl.NEAREST               // = 9728
gl.LINEAR                // = 9729
gl.RGB                   // = 6407
gl.RGBA                  // = 6408
gl.REPEAT                // = 10497
gl.CLAMP_TO_EDGE         // = 33071
gl.MIRRORED_REPEAT       // = 33648
gl.UNPACK_FLIP_Y_WEBGL   // = 37440
gl.TEXTURE0-gl.TEXTURE31 // = 33984 - 34015
...</code></pre>

<li>Hashing WebGL functions (make a short alias for many functions and constants of "gl").
<br>A popular hash consists in using the chars 0 and 6 of each WebGL context property as aliases. You can try other hashes <a href="//xem.github.io/webgl-guide/hash">on this interactive page</a>!

<pre class=lang-js><code>for(i in g=canvas.getContext`webgl`){
  g[i[0]+[i[6]]]=g[i];
}

// Functions
g.createShader              ==  g.cS       
g.shaderSource              ==  g.sS       
g.compileShader             ==  g.ce       
g.createProgram             ==  g.cP       
g.attachShader              ==  g.aS       
g.linkProgram               ==  g.lo       
g.useProgram                ==  g.ug       
g.clearColor                ==  g.co
g.enable                    ==  g.e        
g.getAttribLocation         ==  g.gr       
g.getUniformLocation        ==  g.gf       
g.createBuffer              ==  g.cB       
g.bindBuffer                ==  g.bf       
g.bufferData                ==  g.bD       
g.vertexAttribPointer       ==  g.vA       
g.enableVertexAttribArray   ==  g.eV       
g.drawArrays                ==  g.dr       
g.drawElements              ==  g.de

// Constants      
g.FRAGMENT_SHADER           ==  g.FN
g.VERTEX_SHADER             ==  g.FN+1
g.COLOR_BUFFER_BIT          ==  g.CB
g.DEPTH_TEST                ==  g.DT
g.SHORT                     ==  g.S
g.FLOAT                     ==  g.F
g.LINEAR                    ==  g.L
g.MIRRORED_REPEAT           ==  g.ME
g.TEXTURE31                 ==  g.TE

// This hash can't alias properly the functions clear, vertexAttribXf, uniformXf, and a bunch of constants.
// The solution is to either use a stronger hash, or write the missing functions in their long form and the missing constants as numbers.</code></pre>
<li>Abuse function slotting. A function that returns <b>undefined</b> can be used where a <b>0</b> is expected. Examples:
<pre class=lang-js><code>// Unhashed
drawArrays(linkProgram(p=createProgram()),useProgram(p), n) // = drawArrays(0, 0, n)

// Hashed
dr(lo(p=cP()),ug(p),n)</code></pre>
<pre class=lang-js><code>// Unhashed
shaderSource(S=createShader(FRAGMENT_SHADER), `...vertex shader...`),compileShader(S),attachShader(p,S);
shaderSource(S=createShader(VERTEX_SHADER), `...fragment shader...`),compileShader(S),attachShader(p,S);

// Hashed
sS(S=cS(FN),`...vertex shader...`),ce(S),aS(p,S);
sS(S=cS(FN+1),`...fragment shader...`),ce(S),aS(p,S);

// Factorized
A=s=>sS(S=cS(FN^=1),s)|ce(S)|aS(p,S);
A`...vertex shader...`;
A`...fragment shader...`;</code></pre>

</details>

</div>

<br><br><hr><br>

</div>

</main>

</div>

<footer></footer>

<script src="../ui.js"></script>

<script>
header();
footer();
menu();
</script>

<script>
if(navigator.userAgent.includes("WebKit")){

scr = document.createElement("SCRIPT");
scr.src = 'https://polyfill.io/v3/polyfill.min.js?features=es6';
document.body.appendChild(scr);

scr = document.createElement("SCRIPT");
scr.id = 'MathJax-script';
scr.setAttribute('async', true); 
scr.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
document.body.appendChild(scr);
}

ifrs = document.querySelectorAll(".section iframe");
for(ifr of ifrs){
  ifr.insertAdjacentHTML('afterEnd', '<a class=newWindow title="Open in a new window" href="'+ifr.src+'"> </a>');
}
</script>

</body>
</html>