<!doctype html>
<meta charset=utf-8>
<meta name="viewport" content="width=device-width, user-scalable=no">
<html>
<head>
<link rel=stylesheet href="../style.css?v=4">
<title>Maxime Euzière</title>
</head>
<body class=large>

<div class="wrapper">

<header></header>

<div id=menu></div>

<main>

<style>
table { border-spacing: 0; border-collapse: collapse }
th, td { padding: 5px; width: 200px }
th { background: #eee }
h4 { margin-bottom: 0; }
ul { padding-left: 15px }
pre { margin: 3px; font-size: 12px; }
.math { margin: 15px 0 }
</style>

<div class=section id=webgl_guide>
<h2>WebGL guide</h2>
<h3>october 2019 - WIP</h3>
  
<h4>Introduction</h4>

<p>This page summarizes the book <a href="https://www.oreilly.com/library/view/webgl-programming-guide/9780133364903/ch01.html">WebGL Programming Guide</a> with my own tiny, simplified, editable demos. 
<p>The playground is available <a href="https://xem.github.io/webgl-guide/visualizer/#PGNhbnZhcyBpZD0iY2FudmFzIiB3aWR0aD00MDAgaGVpZ2h0PTQwMD48L2NhbnZhcz4KPHNjcmlwdD4KLy8gR2V0IHRoZSBXZWJHTCByZW5kZXJpbmcgY29udGV4dAovLyBUaGUgWCBhbmQgWSBjb29yZGluYXRlcyBhcmUgZGVmaW5lZCBiZXR3ZWVuIC0xLjAgYW5kIDEuMAp2YXIgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgid2ViZ2wiKTsKCi8vIFZlcnRleCBzaGFkZXI6Ci8vIERlc2NyaWJlcyB0aGUgYXR0cmlidXRlcyBvZiBwb2ludHMgaW4gc3BhY2VzIChwb3NpdGlvbiwgc2l6ZSwgLi4uKQovLyAtIGdsX1Bvc2l0aW9uOiB2ZWM0KHgsIHksIHosIDEuMCkKLy8gLSBnbF9Qb2ludFNpemUgZmxvYXQKdmFyIHZzaGFkZXIgPSBgCnZvaWQgbWFpbigpIHsKICBnbF9Qb3NpdGlvbiA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKTsKICBnbF9Qb2ludFNpemUgPSAxMC4wOwp9YDsKCi8vIEZyYWdtZW50IHNoYWRlcjoKLy8gRGVzY3JpYmVzIGhvdyBlYWNoIHBpeGVsIGlzIHJlbmRlcmVkIChjb2xvciwgbGlnaHRpbmcsIC4uLikKLy8gLSBnbF9mcmFnQ29sb3I6IHZlYzQociwgZywgYiwgYWxwaGEpCnZhciBmc2hhZGVyID0gYApwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKdm9pZCBtYWluKCkgewogIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAwLjAsIDAuMCwgMS4wKTsKfWA7CgovLyBNYWtlIGEgcHJvZ3JhbSBmcm9tIHRoZXNlIHNoYWRlcnMgYW5kIHVzZSBpdCAKdmFyIHZzID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpOwpnbC5zaGFkZXJTb3VyY2UodnMsIHZzaGFkZXIpOwpnbC5jb21waWxlU2hhZGVyKHZzKTsKCnZhciBmcyA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpOwpnbC5zaGFkZXJTb3VyY2UoZnMsIGZzaGFkZXIpOwpnbC5jb21waWxlU2hhZGVyKGZzKTsKCnZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpOwpnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdnMpOwpnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnMpOwpnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTsKZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTsKCi8vIENsZWFyIHRoZSBjYW52YXMncyBjb2xvciBidWZmZXIsIGluIGJsYWNrCmdsLmNsZWFyQ29sb3IoMC4wLCAwLjAsIDAuMCwgMS4wKTsKZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7CgovLyBEcmF3IHBvaW50cyBvbiB0aGUgY2FudmFzJ3MgY29sb3IgYnVmZmVyCmdsLmRyYXdBcnJheXMoCiAgZ2wuUE9JTlRTLCAvLyBtb2RlCiAgMCwgICAgICAgICAvLyBzdGFydGluZyBwb2ludAogIDEsICAgICAgICAgLy8gbnVtYmVyIG9mIHBvaW50cyB0byBkcmF3Cik7Cjwvc2NyaXB0Pg==">here</a> and all the code is available <a href="https://github.com/xem/webgl-guide">on Github</a>.
<p>Helper files created while making this: <a href=https://github.com/xem/webgl-guide/blob/gh-pages/me/webgl.js">webgl.js</a>, <a href=https://github.com/xem/webgl-guide/blob/gh-pages/me/matrix.js">matrix.js</a> and <a href=https://github.com/xem/webgl-guide/blob/gh-pages/me/shapes.js">shapes.js</a>.
<p>If you're interested in Shadertoy, WebGL raymarching and signed distance functions, check out <a href="webgl_quest.html">Webgl quest</a> and <a href="webgl_quest_2.html">Webgl quest 2</a>.

<br><br><hr><br>
<h2>2D graphics</h2>
<br>
<h4>How to draw points</h4>
<i>(from chapter 2 of the book)</i>

<ul>
<li>A vertex is a point in 3D space (coordinates: X, Y, Z)
<li>A fragment is where the scene is rendered (the pixels on your screen)
<li>In a WebGL app, two programs (vertex shader and fragment shader) are written in HLSL language and controlled by JS to render a scene on a canvas
<li>The vertex shader is executed for every vertex, and sets the variable <b>gl_Position</b> (and gl_PointSize, if we want to draw points)
<li>The fragment shader is executed for every fragment, and sets the variable <b>gl_FragColor</b>
<li>The X and Y coordinates in a WebGL canvas context go from -1 to 1, whatever the size of the canvas
<br><img src="images/webgl-guide/webgl.png">
<li>In HLSL, a float is a number written with at least one decimal (ex: 0.0, 0.1, 1.0, ...)
<li>A vec4 is an array of 4 floats representing either vertex coordinates (x, y, z, 1.0), a color (r, g, b, alpha), or anything you want. (vec2 and vec3 exist too)
<li>A mat4 is a matrix (a grid) of 4 x 4 floats. (mat2 and mat3 exist too)
</ul>

<p>Here's the simplest possible WebGL program, drawing a red point in the middle of the canvas.
<br>
<br>
<iframe id=i1 height=770 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?url=1-hello%20point.html&id=i1"></iframe>

<p>The program compilation is always the same, so I've put it in a compile() function that will be used in the next chapters (see webgl.js):

<pre style="font-size:11px"><code class="lang-js">// Compile a WebGL program from a vertex shader and a fragment shader
compile = (gl, vshader, fshader) => {
  
  var vs = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vs, vshader);
  gl.compileShader(vs);
  
  var fs = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fs, fshader);
  gl.compileShader(fs);
  
  var program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  gl.useProgram(program);
  
  console.log('vertex shader:', gl.getShaderInfoLog(vs) || 'OK');
  console.log('fragment shader:', gl.getShaderInfoLog(fs) || 'OK');
  console.log('program:', gl.getProgramInfoLog(program) || 'OK');
  
  return program;
}</code>
</pre>



<br><br><hr><br>

<h4>Attributes and uniforms</h4>

<ul>
<li>Of course, WebGL is not just for drawing hardcoded points. There are many ways to send it custom values: attributes, uniforms, and buffer objects (we'll see them later)
<li>An attribute is a global variable passed by JS to the vertex shader. Its value can change for each vertex (ex: vertex coordinates)
<li>An uniform is a global variable passed by JS to all the shaders. Its value is constant for an entire draw call (ex: a color)
<li>For the record, some browsers (like Safari) can only draw points that are set by JS, and can't run the previous demo at all
</ul>
<p>


<table border style="table-layout:auto">
<tr>
<th style="max-width:50px">Qualifier<th style="max-width:50px">Type<th>GLSL<th style="width:55%">How to set its value in JS

<tr>
<td rowspan=2>attribute
<td>float
<td><pre>attribute float f;</pre>
<td><pre>gl.vertexAttrib1f(gl.getAttribLocation(program, 'f'), 1.0);</pre>

<tr>
<td>vec4
<td><pre>attribute vec4 v;</pre>
<td><pre>gl.vertexAttrib4f(gl.getAttribLocation(program, 'f'), 1.0, 2.0, 3.0, 4.0);
// or
gl.vertexAttrib4fv(gl.getAttribLocation(program, 'f'), [1.0, 2.0, 3.0, 4.0]);</pre>

<tr>
<td rowspan=3>uniform
<td>float
<td><pre>uniform float f;</pre>
<td><pre>gl.uniform1f(gl.getUniformLocation(program, 'f'), 1.0);</pre>

<tr>
<td>vec4
<td><pre>uniform vec4 v;</pre>
<td><pre>gl.uniform4f(gl.getUniformLocation(program, 'f'), 1.0, 2.0, 3.0, 4.0);
// or
gl.uniform4fv(gl.getUniformLocation(program, 'f'), [1.0, 2.0, 3.0, 4.0]);</pre>

<tr>
<td>mat4
<td><pre>uniform mat4 m;</pre>
<td><pre>gl.uniformMatrix4fv(
  gl.getUniformLocation(program, 'm'), false, new Float32Array([...])
);</pre>

</table>
<br>
<p>Here's the same demo as before, but the position, size and color of the point are now set by the JS code.
<br>
<br>
<iframe id=i2 loading=lazy height=650 src="https://xem.github.io/webgl-guide/visualizer/?url=2-point%20defined%20with%20js.html&id=i2"></iframe>

<p>The next demo shows how to add a new point with a different color every time the canvas is clicked.
<br>After each click, the only things to do are: reset canvas, set the attributes/uniforms, and call drawArrays.
<br>
<br>
<iframe id=i3 loading=lazy height=980 src="https://xem.github.io/webgl-guide/visualizer/?url=3-points added on click.html&id=i3"></iframe>

<br><br><hr><br>

<h4>How to draw lines and triangles</h4>
<i>(from chapter 3 of the book)</i>

<ul>
<li>An array buffer can be used to pass binary data from JS to the shaders (ex: a list of vertices, a list of colors, ...)
<li>This buffer is always read as a list of numbers, formatted as one of these types:
<br>
<br>
<table border>
<tr>
<th>Name
<th>JS container
<th>WebGL type
<tr>
<td>Unsigned byte
<td>Uint8Array
<td>gl.UNSIGNED_BYTE

<tr>
<td>Signed short integer
<td>Int16Array
<td>gl.SHORT

<tr>
<td>Unsigned short integer
<td>Uint16Array
<td>gl.UNSIGNED_SHORT

<tr>
<td>Signed integer
<td>Int32Array
<td>gl.INT

<tr>
<td>Unsigned integer
<td>Uint32Array
<td>gl.UNSIGNED_INT

<tr>
<td>Floating point number
<td>Float32Array
<td>gl.FLOAT
</table>
<br>
<li>drawArrays can render points, lines and triangles in 7 different ways:
<br>
<br>
<img src="images/webgl-guide/modes.png" width=800 style="border:2px solid #ddd">
</ul>

<p>Here's the simplest way to draw a triangle. You can edit the mode on line 53 to render points or lines instead of a triangle (ex: gl.POINTS / gl.LINE_LOOP)
<br>
<br>
<iframe id=i4 loading=lazy height=800 src="https://xem.github.io/webgl-guide/visualizer/?url=4-hello triangle.html&id=i4"></iframe>

<p>The "basic" array buffer setup is always the same, so I included it in webgl.js:
<pre style="font-size:11px"><code class="lang-js">// Bind an array buffer to an attribute and enable it
arraybuffer = (gl, data, program, attribute, size, type) => {
  gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
  var a = gl.getAttribLocation(program, attribute);
  gl.vertexAttribPointer(a, size, type, false, 0, 0);
  gl.enableVertexAttribArray(a);
}</code>
</pre>

<br><br><hr><br>

<h4>Translate, rotate, scale</h4>
<i>(from chapters 3 & 4 of the book)</i>

<ul>
<li>Vertices coordinates are represented on vec4's (x, y, z, 1.0) to ease matrix-based transformations. They're called homogeneous coordinates

<p>

<table border>
<tr>
<th>Transformation
<th>Transformation applied to each vertex coordinates
<th>transformation via a matrix

<tr>
<td>Identity (no change)
<td>x' = x
<br>y' = y
<br>z' = z
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;=&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;×&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>


<tr>
<td>Translation along X, Y and Z axis
<td>x' = x + Tx
<br>y' = y + Ty
<br>z' = z + Tz
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;=&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Tx</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Ty</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>Tz</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;×&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr>
<td>Rotation around X with an angle φ (in radians)
<td>x' = x
<br>y' = y cos φ - z sin φ
<br>z' = y sin φ + z cos φ
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;=&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>cos φ</mn></mtd>
            <mtd><mn>-sin φ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>sin φ</mn></mtd>
            <mtd><mn>cos φ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;×&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr>
<td>Rotation around Y with an angle θ
<td>x' = x cos θ + z sin θ
<br>y' = y
<br>z' = -x sin θ + z cos θ
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;=&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>cos θ</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>sin θ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>-sin θ</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>cos θ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;×&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr>
<td>Rotation around Z axis with an angle ψ
<td>x' = x cos ψ – y sin ψ
<br>y' = x sin ψ + y cos ψ
<br>z' = z
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;=&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>cos ψ</mn></mtd>
            <mtd><mn>-sin ψ</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>sin ψ</mn></mtd>
            <mtd><mn>cos ψ</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;×&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr>
<td>Scaling along X, Y and Z axis
<td>x' = Sx * x
<br>y' = Sy * y
<br>z' = Sz * z
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;=&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>Sx</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Sy</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Sz</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;×&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

</table>

<li>Multiple transformations can be accumulated by multiplying their matrices
<li>To translate then rotate a point, multiply in this order: (〈 rotation matrix 〉 × 〈 translation matrix 〉) × 〈 original coordinates 〉
<li>Matrices and vectors can be multiplied together natively in GLSL. In JS, each term must be computed separately
<br>
<br>
<iframe id=i5 loading=lazy height=1150 src="https://xem.github.io/webgl-guide/visualizer/?url=5-transformed triangle.html&id=i5"></iframe>

<p>Note: in this example, the transformation matrix (translation x rotation x scale) is computed in the fragment shader.
<br>This is easy to code, but it's not efficient in real conditions, as the computation is performed for every fragment of the program.
<br>In the next examples, it will be computed once (in JS) and passed to the shader.
</ul>

<p>Functions added in matrix.js:
<pre style="font-size:11px"><code class="lang-js">// Create an identity mat4
identity = () => {
  return new Float32Array([
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
  ]);
}

// Compute the multiplication of two mat4
multMat4Mat4 = (a, b) => {
  var i, e, a, b, ai0, ai1, ai2, ai3;
  var c = new Float32Array(16);
  for (i = 0; i &lt; 4; i++) {
    ai0 = a[i];
    ai1 = a[i+4];
    ai2 = a[i+8];
    ai3 = a[i+12];
    c[i]    = ai0 * b[0]  + ai1 * b[1]  + ai2 * b[2]  + ai3 * b[3];
    c[i+4]  = ai0 * b[4]  + ai1 * b[5]  + ai2 * b[6]  + ai3 * b[7];
    c[i+8]  = ai0 * b[8]  + ai1 * b[9]  + ai2 * b[10] + ai3 * b[11];
    c[i+12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
  }
  return c;
};

// Transform a mat4
// options: x/y/z (translate), rx/ry/rz (rotate), sx/sy/sz (scale)
transform = (mat, options) => {
  var x = options.x || 0;
  var y = options.y || 0;
  var z = options.z || 0;
  
  var sx = options.sx || 1;
  var sy = options.sy || 1;
  var sz = options.sz || 1;
  
  var rx = options.rx;
  var ry = options.ry;
  var rz = options.rz;
  
  // translate
  if(x || y || z){
    mat[12] += mat[0] * x + mat[4] * y + mat[8]  * z;
    mat[13] += mat[1] * x + mat[5] * y + mat[9]  * z;
    mat[14] += mat[2] * x + mat[6] * y + mat[10] * z;
    mat[15] += mat[3] * x + mat[7] * y + mat[11] * z;
  }
  
  // Rotate
  if(rx) mat.set(multMat4Mat4(mat, new Float32Array([1, 0, 0, 0, 0, Math.cos(rx), Math.sin(rx), 0, 0, -Math.sin(rx), Math.cos(rx), 0, 0, 0, 0, 1])));
  if(ry) mat.set(multMat4Mat4(mat, new Float32Array([Math.cos(ry), 0, -Math.sin(ry), 0, 0, 1, 0, 0, Math.sin(ry), 0, Math.cos(ry), 0, 0, 0, 0, 1])));
  if(rz) mat.set(multMat4Mat4(mat, new Float32Array([Math.cos(rz), Math.sin(rz), 0, 0, -Math.sin(rz), Math.cos(rz), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])));
  
  // Scale
  if(sx !== 1){
    mat[0] *= sx;  
    mat[1] *= sx;
    mat[2] *= sx;
    mat[3] *= sx;
  }
  if(sy !== 1){
    mat[4] *= sy;
    mat[5] *= sy;
    mat[6] *= sy;
    mat[7] *= sy;
  }
  if(sz !== 1){
    mat[8] *= sz;
    mat[9] *= sz;
    mat[10] *= sz;
    mat[11] *= sz;
  }
};</code>
</pre>


<br><br><hr><br>

<h4>Multi-attribute buffer and varying color</h4>
<i>(from chapter 5 of the book)</i>

<p><ul><li>A single array buffer can hold interleaved data, for example X/Y/R/G/B values, recurring every 5 floats
<li>A varying is a global variable writable by the vertex shader and readable by the fragment shader
<li>Every fragment (pixel) inside the triangle, if it's bound to a varying color variable, will be interpolated from the color of each vertex around it
</ul>
<iframe id=i6 loading=lazy height=920 src="https://xem.github.io/webgl-guide/visualizer/?url=6-multi attribute and varying.html&id=i6"></iframe>

<br><br><hr><br>

<h4>Texturing</h4>
<i>(from chapter 5 of the book)</i>

<ul>
<li>Fragment interpolation can be done on a set of colors, but also on a texture image (it's called sampling in this case)
<li>Any texture (square or rectangle) has a local coordinates system that goes from 0 to 1, and every associated vertex will have texture coordinates in this system
<li>An Image object can be bound to an <b>uniform sampler2D</b> to create a texture, which is applied to the current fragment using <b>gl_FragColor = texture2D(sampler,coord);</b>
<li>The "pixels" of the texture are called texels
<br><img src="images/webgl-guide/texture.png">
</ul>

<p>Here's an example of textured quad (a square made of two triangles). Play with the numbers to change the way the vertices and texture are mapped:
<p>
<iframe id=i7 loading=lazy height=1200 src="https://xem.github.io/webgl-guide/visualizer/?url=7-texture.html&id=i7"></iframe>

<p>Similarly, multiple textures can be used at once. For example, initialize two samplers, and multiply them in the fragment shader (<a href="https://xem.github.io/webgl-guide/book/ch05/MultiTexture.html">DEMO</a>)
<pre class="language-js"><code>vec4 color0 = texture2D(sampler0, v_TexCoord);
vec4 color1 = texture2D(sampler1, v_TexCoord);
gl_FragColor = color0 * color1;</code></pre>

<br><br><hr><br>

<h2>3D graphics</h2>
<br>
<h4>3D camera</h4>
<i>(from chapter 7 of the book)</i>
<ul>
<li>In WebGL (and 3D graphics in general), the "camera" is abstract: its position, angle and perspective are defined by a matrix
<li>On render, every vertex in the scene is multiplied by this matrix to simulate these camera properties
<li>First, the camera's perspective (including field of view, aspect ratio, near clip plane and far clip plane) can be set with:

<div class=math>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1/(aspect*tan(fov/2))</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1/tan(fov/2)</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-(far+near)/(far-near)</mn></mtd>
            <mtd><mn>-(2*far*near)/far-near</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-1</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>
</div>

<li>Then, the camera can be translated, rotated and scaled (zoomed) by multiplying the corresponding matrices (see "Translate, rotate, scale" above)
<li>A LookAt() function is often used by developers to set the camera's position, angle and target all at once. It's included in the book's file <a href="https://github.com/xem/webgl-guide/blob/gh-pages/book/lib/cuon-matrix.js">cuon-matrix.js</a>
<li>I find the lookAt function too heavy though, so I only added the perspective function in matrix.js:

<pre><code class="lang-js">// Set perspective
// options: fovy, aspect, near, far
perspective = (mat, options) => {
  var fovy = options.fovy || 1.5;
  var aspect = options.ratio || 1;
  var near = options.near || 1;
  var far = options.far || 100;
  var s = Math.sin(fovy);
  var rd = 1 / (far - near);
  var ct = Math.cos(fovy) / s;
  mat.set([
    ct / aspect, 0, 0, 0, 
    0, ct, 0, 0, 
    0, 0, -(far + near) * rd, -1,
    0, 0, -2 * near * far * rd, 0
  ]);
}</code>
</pre>

</ul>

<br><br><hr><br>

<h3>Hello cube</h3>
<i>(from chapter 7 of the book)</i>

<ul>
<li>As seen before, buffer objects with the type gl.ARRAY_BUFFER can hold vertex properties (position, color)
<li>Though, in 3D models, vertices are often shared between multiple triangles
<li>Instead of repeating the same vertices many times, we can write each vertex once, and use another buffer object with the type <b>gl.ELEMENT_ARRAY_BUFFER</b> that makes triangles simply by using indices of the first object
<li>In 3D, depth-sorting must be enabled with <b>gl.enable(gl.DEPTH_TEST);</b> and the screen is cleaned with <b>gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);</b>
<li>Also, gl.drawArrays is replaced with <b>gl.drawElements</b>
</ul>

<iframe id=i8 loading=lazy height=1530 src="https://xem.github.io/webgl-guide/visualizer/?url=8-cube.html&id=i8"></iframe>

<br><br><hr><br>

<h3>Color each face of the cube</h3>

<ul>
<li>In this case, each vertex doesn't have a single color: it has a different color depending on which face is rendered
<li>Thus, we need to declare the vertices of each face separately in an array buffer, then the colors of each vertex of each face in another array buffer, and finally, use an index buffer that references both vertices and colors
<li>The indices have small integer values, so we represent them with a Uint8Array. For more than 256 values, use Uint16Array. For more than 65536 values, use Uint32Array
</ul>

<iframe id=i9 loading=lazy height=1330 src="https://xem.github.io/webgl-guide/visualizer/?url=9-cube faces.html&id=i9"></iframe>

<p>I've added the cube declaration in the cube() function of shapes.js to avoid repeating it in the next demos

<br><br><hr><br>

<h4>Lighting and shading</h4>

<i>(from chapter 8 of the book)</i>

<ul>
<li>First, we can make <b>diffuse light reflexion</b>, where the light is reflected equally in all directions when it hits a face of the cube
<li>To do that, we need to define a light with a color (for example, white), and a direction (for example, vec3(0.5, 3.0, 4.0))
<li>Each face has <b>normal</b>: a vec3 pointing to the outside of the cube, with a length of 1, i.e. "normalized"
<li>In the fragment shader, we perform a <b>dot product</b> between the light vector and the face normal, to determine how much the light is diffused
<br><blockquote class="twitter-tweet"><p lang="en" dir="ltr">dot product - visualized ⚪<br><br>the dot of two normalized vectors, as shown here, can say how similar they are<br><br>a • b = 1, same direction<br>a • b = 0, perpendicular<br>a • b = -1, opposite directions<br><br>you might also be able to see why it&#39;s sometimes called scalar projection~ <a href="https://t.co/vg8TwNZ8qs">pic.twitter.com/vg8TwNZ8qs</a></p>&mdash; Freya Holmér (@FreyaHolmer) <a href="https://twitter.com/FreyaHolmer/status/1200807790580768768?ref_src=twsrc%5Etfw">November 30, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 
<li>If the dot product is negative, we set it to "0" (there can't be a negative amount of light). This is done with <b>max(dot(light, normal), 0.0);</b>
<li>The color sent to the fragment shader is: the light's color (rgb) × the face color (rgb) × the dot product of the normal and the light, and the color's alpha is set to 1.0
<li>In HLSL, the composants of a vec4 can be accessed with .x/y/z/t (if it's a position) or .r/g/b/a (if it's a color). Composants can be composed too (ex: <b>vec3 rgb = col.rgb</b>).
</ul>

<iframe id=i10 loading=lazy height=1180 src="https://xem.github.io/webgl-guide/visualizer/?url=10-diffuse lighting.html&id=i10"></iframe>

<p>With diffuse lighting alone, some faces are too dark, like the rightmost one here. To fix that, we can add an <b>ambient light</b> (added equally to every vertex's color):
<br>
<br>
<iframe id=i11 loading=lazy height=1280 src="https://xem.github.io/webgl-guide/visualizer/?url=11-diffuse ambient lighting.html&id=i11"></iframe>

<p>With these two techniques, the color is computed per-face, which doesn't look super natural (each face has a flat color).
<p>This can be improved using a <b>point light</b>, that has a specific position and color. The shading will vary with the distance between each point of the cube and the point light
<p>It can be computed per-vertex, which looks better but still doesn't look perfect due to imprecise linear color interpolation (see the book's demos: <a href="https://xem.github.io/webgl-guide/book/ch08/PointLightedCube.html">cube</a> / <a href="https://xem.github.io/webgl-guide/book/ch08/PointLightedSphere.html">sphere</a>)...
<p><img src="images/webgl-guide/per_vertex.png">
<p>... so the best solution is to compute point light shading for every fragment of the cube (i.e. every pixel), and that's exactly what the fragment shader is here for:
<br><br>

<iframe id=i12 loading=lazy height=1460 src="https://xem.github.io/webgl-guide/visualizer/?url=12-point light per fragment.html&id=i12"></iframe>

<p>You can also see a sphere shaded per-fragment in <a href="http://xem.github.io/webgl-guide/book/ch08/PointLightedSphere_perFragment.html">this example from the book</a>.

<br><br><hr><br>

<h4>Transforming the shaded cube</h4>

<ul>
<li>So far, we've only transformed the camera matrix, to make it revolve around the cube
<li>Due to the lack of light or other cubes in the scene, it was equivalent to having the cube rotate on itself
<li>Now that we have a fixed point light in the scene, if we want to rotate, translate or scale the cube, we need to do two things:<br>- introduce a <b>model matrix</b> (the transformation matrix of the cube),<br>- recompute the 6 cube's normals and the lighting of every fragment when the model matrix is updated
<li>Computing a face normal from scratch can be done using a cross-product of two face vectors respecting the right hand rule (AB × BC if the points A, B and C are arranged counterclockwise)
<p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">cross product - visualized ⚔<br><br>the cross product A × B is a super useful way to take two 3D vectors, and get a third vector *perpendicular to both*, shown in blue (with its length shown in gray)! <a href="https://t.co/d3NZoLEUtq">pic.twitter.com/d3NZoLEUtq</a></p>&mdash; Freya Holmér (@FreyaHolmer) <a href="https://twitter.com/FreyaHolmer/status/1203059678705602562?ref_src=twsrc%5Etfw">December 6, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<li>Though, it's simpler to only compute the normals once, on load, and pass them to the vertex shader, along with the vertex position and the face color
<br>
Then, when the model matrix changes, the trick is compute its inverse transpose (in JS) and pass it to the vertex shader
<br>
In the vertex shader, the original normal just needs to be multiplied by this matrix to obtain its new value: <b>vec3 newNormal = oldNormal * inverseTranspose</b>
<li>Here are the functions I added in matrix.js to compute the inverse transpose:

<pre><code class="lang-js">// Get the transposed of a mat4
transpose = m => {
  return new Float32Array([
    m[0], m[4], m[8],  m[12],
    m[1], m[5], m[9],  m[13],
    m[2], m[6], m[10], m[14],
    m[3], m[7], m[11], m[15]
  ]);
}

// Get the inverse of a mat4
// The mat4 is not modified, a new mat4 is returned
inverse = m => {
  var inv = new Float32Array([
     m[5]*m[10]*m[15] - m[5]*m[11]*m[14] - m[9]*m[6]*m[15] + m[9]*m[7]*m[14] + m[13]*m[6]*m[11] - m[13]*m[7]*m[10],
    -m[1]*m[10]*m[15] + m[1]*m[11]*m[14] + m[9]*m[2]*m[15] - m[9]*m[3]*m[14] - m[13]*m[2]*m[11] + m[13]*m[3]*m[10],
     m[1]*m[6]*m[15]  - m[1]*m[7]*m[14]  - m[5]*m[2]*m[15] + m[5]*m[3]*m[14] + m[13]*m[2]*m[7]  - m[13]*m[3]*m[6],
    -m[1]*m[6]*m[11]  + m[1]*m[7]*m[10]  + m[5]*m[2]*m[11] - m[5]*m[3]*m[10] - m[9]*m[2]*m[7]   + m[9]*m[3]*m[6],
    -m[4]*m[10]*m[15] + m[4]*m[11]*m[14] + m[8]*m[6]*m[15] - m[8]*m[7]*m[14] - m[12]*m[6]*m[11] + m[12]*m[7]*m[10],
     m[0]*m[10]*m[15] - m[0]*m[11]*m[14] - m[8]*m[2]*m[15] + m[8]*m[3]*m[14] + m[12]*m[2]*m[11] - m[12]*m[3]*m[10],
    -m[0]*m[6]*m[15]  + m[0]*m[7]*m[14]  + m[4]*m[2]*m[15] - m[4]*m[3]*m[14] - m[12]*m[2]*m[7]  + m[12]*m[3]*m[6],
     m[0]*m[6]*m[11]  - m[0]*m[7]*m[10]  - m[4]*m[2]*m[11] + m[4]*m[3]*m[10] + m[8]*m[2]*m[7]   - m[8]*m[3]*m[6],
     m[4]*m[9]*m[15]  - m[4]*m[11]*m[13] - m[8]*m[5]*m[15] + m[8]*m[7]*m[13] + m[12]*m[5]*m[11] - m[12]*m[7]*m[9],
    -m[0]*m[9]*m[15]  + m[0]*m[11]*m[13] + m[8]*m[1]*m[15] - m[8]*m[3]*m[13] - m[12]*m[1]*m[11] + m[12]*m[3]*m[9],
     m[0]*m[5]*m[15]  - m[0]*m[7]*m[13]  - m[4]*m[1]*m[15] + m[4]*m[3]*m[13] + m[12]*m[1]*m[7]  - m[12]*m[3]*m[5],
    -m[0]*m[5]*m[11]  + m[0]*m[7]*m[9]   + m[4]*m[1]*m[11] - m[4]*m[3]*m[9]  - m[8]*m[1]*m[7]   + m[8]*m[3]*m[5],
    -m[4]*m[9]*m[14]  + m[4]*m[10]*m[13] + m[8]*m[5]*m[14] - m[8]*m[6]*m[13] - m[12]*m[5]*m[10] + m[12]*m[6]*m[9],
     m[0]*m[9]*m[14]  - m[0]*m[10]*m[13] - m[8]*m[1]*m[14] + m[8]*m[2]*m[13] + m[12]*m[1]*m[10] - m[12]*m[2]*m[9],
    -m[0]*m[5]*m[14]  + m[0]*m[6]*m[13]  + m[4]*m[1]*m[14] - m[4]*m[2]*m[13] - m[12]*m[1]*m[6]  + m[12]*m[2]*m[5],
     m[0]*m[5]*m[10]  - m[0]*m[6]*m[9]   - m[4]*m[1]*m[10] + m[4]*m[2]*m[9]  + m[8]*m[1]*m[6]   - m[8]*m[2]*m[5]
  ]);
  det = m[0]*inv[0] + m[1]*inv[4] + m[2]*inv[8] + m[3]*inv[12];
  if(!det) return m;
  det = 1 / det;
  for(var i = 0; i < 16; i++) {
    inv[i] *= det;
  }
  return inv;
}</code></pre>

<li>We also pass a "mvp" (model view projection) matrix to the vertex shader, which is the multiplication of the camera matrix and the model matrix
</ul>

<p>Here's a cube rotating on itself with a fixed camera and a fixed point light:
<br>
<br>

<iframe id=i13 loading=lazy height=1850 src="https://xem.github.io/webgl-guide/visualizer/?url=13-inverse transpose.html&id=i13"></iframe>

<p>Note: if the model matrix is only a rotation or an uniform scaling, the inverse transpose matrix will be equal to the model matrix. But in any other transformation or combination of transformations, it will have a specific value that will let the shader compute the new normals with a simple multiplication (more info <a href="https://stackoverflow.com/questions/13654401/why-transforming-normals-with-the-transpose-of-the-inverse-of-the-modelview-matr">here</a>)


<br><br><hr><br>

<h4>Drawing many cubes</h4>

<ul>
<li>Of course, it's possible to declare the vertices coordinates, colors and normals of each cube, but that would be very verbose
<li>Instead, we can consider the cube we already declared at the center of the scene as a model
<li>For each cube we want to draw, we simply need to transform this model (by setting the model matrix, mvp matrix and inverse transpose matrix) and render it
</ul>

<br><p>Here's a demo with 3 red cuboids (deformed cubes)
<br><br>
<iframe id=ii4 loading=lazy height=2400 src="https://xem.github.io/webgl-guide/visualizer/?url=14-many cubes.html&id=i14"></iframe>

<p>To avoid repetitions, I added a drawShape function in shapes.js:

<pre><code class="lang-js">// Draw the current shape
drawShape = (gl, program, cameraMatrix, modelMatrix) => {
  var model = gl.getUniformLocation(program, 'model');
  gl.uniformMatrix4fv(model, false, modelMatrix);

  // Set the cube's mvp matrix (camera x model)
  var mvpMatrix = multMat4Mat4(cameraMatrix, modelMatrix);
  var mvp = gl.getUniformLocation(program, 'mvp');
  gl.uniformMatrix4fv(mvp, false, mvpMatrix);

  // Set the inverse transpose of the model matrix
  var inverseTransposeMatrix = transpose(inverse(modelMatrix));
  var inverseTranspose = gl.getUniformLocation(program, 'inverseTranspose');
  gl.uniformMatrix4fv(inverseTranspose, false, inverseTransposeMatrix);

  // Render
  gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);
}</code></pre>

<br><br><hr><br>

<h4>Hierarchical objects</h4>
<i>(from chapter 9 of the book)</i>

<ul>
<li>A hierarchical object is a model made of several basic objects (called segments), like a robotic arm made of many cuboids
<li>Joints represent how the segments are linked and rotate relatively to each other, like an elbow and a forearm
<li>These transformations are done by combining model and rotation matrices
</ul>

<p>This simple demo represents a robotic arm made of two cuboids:




</div>

</main>

</div>

<footer></footer>

<script src="../ui.js"></script>
<script>
header();
footer();
menu();
</script>

</body>
</html>
