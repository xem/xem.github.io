<!doctype html>
<meta charset=utf-8>
<meta name="viewport" content="width=device-width, user-scalable=no">
<html>
<head>
<link rel=stylesheet href="../style.css?v=4">
<title>Maxime Euzière</title>
<base target=_blank>
</head>
<body class=large>

<div class="wrapper">

<header></header>

<div id=menu></div>

<main>

<style>
table { border-spacing: 0; border-collapse: collapse; width: 100% }
th, td { padding: 5px; width: 200px }
th { background: #eee }
h4 { margin-bottom: 0; }
h1 { font-size: 30px }
h2 { font-size: 24px }
h3 { font-size: 20px }
h4 { font-size: 18px }
h5 { font-size: 14px }
ul, ol { padding-left: 15px }
pre { margin: 3px; font-size: 12px; }
pre.inline, pre.inline code { display: inline; padding: 2px; background: #444; font-size: 11px;}
.math { margin: 15px 0 }
.section iframe { height: 40vw; min-height: 400px; }
.ch10 { border: 1px solid #000 }
.ch10 * { border: none }
.ch10 td { max-width: 430px; width: auto; vertical-align: top }
.ch10 td + td { max-width: 450px; }
.newWindow { float: right; margin-top: -60px; left: -10px; position: relative; z-index: 2; padding: 5px; border: 1px solid #555; border-radius: 5px; color: #000; font-size: 20px; width: 40px; height: 40px; background: url('images/new_window.svg') no-repeat center center #def; }
.section p {line-height: 30px; }
</style>

<div class=section id=webgl_guide>
<h2>WebGL guide</h2>
<h3>october 2019 - may 2020</h3>

<br><hr>

<h4>Introduction</h4>

<p>This guide is a complete, summarized WebGL tutorial, with tiny interactive demos in each chapter.
<br>It's mainly inspired by the book <a href="https://www.oreilly.com/library/view/webgl-programming-guide/9780133364903/ch01.html">WebGL Programming Guide</a> and the websites <a href="https://webgl2fundamentals.org/">Webgl2Fundamentals</a>, <a href="http://learnwebgl.brown37.net/index.html">LearnWebgl</a> &amp, <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">MDN</a>. 
<br>Starting nearly from scratch, you'll be able to create your own 3D interactive scenes without needing to use any <a href="https://fr.wikipedia.org/wiki/Liste_de_frameworks_WebGL">library or framework</a>: only vanilla JS &amp; WebGL.
<br>My goal was to gather all the information and tricks about WebGL I found scattered everywhere, and present them in a short and helpful way. I hope you'll enjoy it!
<br>The live playground (used for the demos) is available <a href="https://xem.github.io/webgl-guide/visualizer/#PGNhbnZhcyBpZD0iY2FudmFzIiB3aWR0aD00MDAgaGVpZ2h0PTQwMD48L2NhbnZhcz4KPHNjcmlwdD4KLy8gR2V0IHRoZSBXZWJHTCByZW5kZXJpbmcgY29udGV4dAovLyBUaGUgWCBhbmQgWSBjb29yZGluYXRlcyBhcmUgZGVmaW5lZCBiZXR3ZWVuIC0xLjAgYW5kIDEuMAp2YXIgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgid2ViZ2wiKTsKCi8vIFZlcnRleCBzaGFkZXI6Ci8vIERlc2NyaWJlcyB0aGUgYXR0cmlidXRlcyBvZiBwb2ludHMgaW4gc3BhY2VzIChwb3NpdGlvbiwgc2l6ZSwgLi4uKQovLyAtIGdsX1Bvc2l0aW9uOiB2ZWM0KHgsIHksIHosIDEuMCkKLy8gLSBnbF9Qb2ludFNpemUgZmxvYXQKdmFyIHZzaGFkZXIgPSBgCnZvaWQgbWFpbigpIHsKICBnbF9Qb3NpdGlvbiA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKTsKICBnbF9Qb2ludFNpemUgPSAxMC4wOwp9YDsKCi8vIEZyYWdtZW50IHNoYWRlcjoKLy8gRGVzY3JpYmVzIGhvdyBlYWNoIHBpeGVsIGlzIHJlbmRlcmVkIChjb2xvciwgbGlnaHRpbmcsIC4uLikKLy8gLSBnbF9mcmFnQ29sb3I6IHZlYzQociwgZywgYiwgYWxwaGEpCnZhciBmc2hhZGVyID0gYApwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKdm9pZCBtYWluKCkgewogIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAwLjAsIDAuMCwgMS4wKTsKfWA7CgovLyBNYWtlIGEgcHJvZ3JhbSBmcm9tIHRoZXNlIHNoYWRlcnMgYW5kIHVzZSBpdCAKdmFyIHZzID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpOwpnbC5zaGFkZXJTb3VyY2UodnMsIHZzaGFkZXIpOwpnbC5jb21waWxlU2hhZGVyKHZzKTsKCnZhciBmcyA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpOwpnbC5zaGFkZXJTb3VyY2UoZnMsIGZzaGFkZXIpOwpnbC5jb21waWxlU2hhZGVyKGZzKTsKCnZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpOwpnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdnMpOwpnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnMpOwpnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTsKZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTsKCi8vIENsZWFyIHRoZSBjYW52YXMncyBjb2xvciBidWZmZXIsIGluIGJsYWNrCmdsLmNsZWFyQ29sb3IoMC4wLCAwLjAsIDAuMCwgMS4wKTsKZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7CgovLyBEcmF3IHBvaW50cyBvbiB0aGUgY2FudmFzJ3MgY29sb3IgYnVmZmVyCmdsLmRyYXdBcnJheXMoCiAgZ2wuUE9JTlRTLCAvLyBtb2RlCiAgMCwgICAgICAgICAvLyBzdGFydGluZyBwb2ludAogIDEsICAgICAgICAgLy8gbnVtYmVyIG9mIHBvaW50cyB0byBkcmF3Cik7Cjwvc2NyaXB0Pg==">here</a>, my 3D OBJ file parser/viewer is <a href="https://xem.github.io/webgl-guide/">here</a>, and all the source code is available <a href="https://github.com/xem/webgl-guide">on Github</a>.
<br>Helper files created while making this guide: <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/webgl.js">webgl.js</a>, <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/matrix.js">matrix.js</a> and <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/shapes.js">shapes.js</a>.
<br>If you're interested in Shadertoy, WebGL raymarching and signed distance functions, check out <a href="webgl_quest.html">Webgl quest</a> and <a href="webgl_quest_2.html">Webgl quest 2.</a>
<br>Special thanks to <a href="https://twitter.com/iquilezles">Inigo Quilez</a>, <a href="https://twitter.com/kchplr">Kevin Chapelier</a>, <a href="https://twitter.com/FreyaHolmer/">Freya Holmér</a> and <a href="https://twitter.com/adriengueret">Adrien Guéret</a> for their knowledge, tips and proofreading!


<br><br><hr><br>
<h2>What is WebGL?</h2>

<h4>Presentation</h4>

<p>WebGL is a JavaScript API designed to compute and draw 2D and 3D graphics very fast in a Web browser, by using the processing power of the GPU.
<br>It's based on <b>OpenGL ES</b> and is programmed using <b>shaders</b> coded in <b>GLSL</b>, a language similar to C and C++.
<br>A scene rendered by WebGL is made of <b>vertices</b> (points in 3D space, with coordinates X, Y, Z), which can be rendered as points, lines or triangles (colored, shaded or textured).
<p>The workflow of a WebGL program is pretty complex, and can be summarized like this:
<ul>
<li>The JavaScript code initializes the WebGL program and pilots it to draw a 2D or 3D scene on the <b>webgl context</b> of a <b>HTML5 canvas</b>.
<li>A first GLSL script called <b>vertex shader</b> is executed for every vertex of the scene. It computes an abstract, mathematical model of the scene and hands it to...
<li>A second GLSL script called <b>fragment shader</b>, executed for every visible fragment (pixel) of the canvas. It computes each fragment's color, in a process called <b>rasterization</b>.
<li>The fragments constitute a bitmap image stored in a <b>color buffer</b>, which is finally displayed on the canvas.
<br><br><img src="images/webgl-guide/workflow.png" width=800>
</ul>
<br>

<h4>The GLSL language</h4>

<p>The shaders source code can be placed in a string or loaded from a separate file. In WebGL 1.0, their syntax can be summarized like this:

<ul>
<li>An <b>int</b> is a whole number: <pre class=inline><code class="lang-js">0</code></pre>, <pre class=inline><code class="lang-js">1</code></pre>, <pre class=inline><code class="lang-js">2</code></pre>, ...
<li>A <b>float</b> is a number written with at least one decimal: <pre class=inline><code class="lang-js">0.0</code></pre>, <pre class=inline><code class="lang-js">0.1</code></pre>, <pre class=inline><code class="lang-js">1.0</code></pre>, ...
<li>A <b>vec4</b> is an array of 4 floats representing vertex coordinates or a 3D vector (x, y, z, w), or a color (r, g, b, alpha). The types vec2 and vec3 exist too.
<li>A <b>mat4</b> is a matrix (a grid) of 4 x 4 floats, useful for transforming coordinates and vectors in 3D. The types mat2 (2x2) and mat3 (3x3) exist too.
<li>A <b>sampler2D</b> is a reference to a texture image; a <b>samplerCube</b> is a reference to a "3D texture" (a set of 6 textures mapped on a cube).
<li>A <b>variable</b> is declared with its type, for example: <pre class=inline><code class="lang-js">int i = -1</code></pre>, <pre class=inline><code class="lang-js">float f = 2.0</code></pre> or <pre class=inline><code class="lang-js">vec4 v = vec4(1.0, 2.0, 3.0, 4.0)</code></pre>.
<li>A <b>constant</b> is a variable with a fixed value: <pre class=inline><code class="lang-js">const int c = 100;</code></pre>.
<li>The xyzw / rgba components of a vec4 can be extracted and recomposed, for example: <pre class=inline><code class="lang-js">float f = v.x</code></pre>, <pre class=inline><code class="lang-js">vec3 rgb = v.rgb</code></pre>.
<li><b>Math functions</b>: cos, sin, tan, pow, exp, log, log2, sqrt, abs, sign, floor, ceil, round, trunc, fract, mod, min, max, clamp, mix, step, length, distance, dot, cross, normalize...
<li>All the usual <b>operators</b> are available (+ - * / &amp;&amp; || == != > >= &lt; &lt;= ++ -- += ...) but only between variables of the same type (and matrices can be multiplied with vectors of same size).
<li><b>Tests and loops</b> are also available (if, else, switch, for, while), but loops must have a constant limit. (you can't do <pre class=inline><code class="lang-js">for(i=0; i&lt;j; i++){...}</code></pre> if j is variable).
<li>The <b>entry point</b> of each shader is a <pre class=inline><code class="lang-js">void main(){...}</code></pre> function. (<a href="https://relativity.net.au/gaming/glsl/Functions.html">custom functions</a> can also be created and called by main() ).
<li>The <b>precision</b> of ints, floats and Sampler2Ds (lowp / mediump / highp) can be set in each shader with a directive, like <pre class=inline><code class="lang-js">precision highp int;</code></pre> or <pre class=inline><code class="lang-js">precision mediump float;</code></pre>
<br>These directives must be at the beginning of the shader's code, however only the float precision is mandatory in the fragment buffer, all the others have values by default.
<li>The vertex shader must set a global variable <b>gl_Position</b> containing the coordinates of the current vertex. <b>gl_PointSize</b> is also mandatory when rendering individual points.
<li>The fragment shader must set a global variable <b>gl_FragColor</b> containing the color of the current fragment.
<br>It can also read 3 global variables: <b>gl_FragCoord</b> (window coordinates),  <b>gl_PointCoord</b> (coordinates inside a point) and <b>gl_FrontFacing</b> (current triangle orientation).
</ul>

<br>
<h4>Communication between JavaScript and WebGL</h4>
<p>Four main mechanisms exist to send data between the different scripts:
<ul>
<li><b>Attributes</b> are global variable passed by JS to the vertex shader. Their value can change for each vertex (ex: vertex coordinates).
<li><b>Uniforms</b> are global variables passed by JS to both vertex and fragment shaders (ex: a color). Their value stays constant for an entire frame.
<li><b>Varyings</b> are not accessible by JavaScript. They can only be set by the vertex shader and read by the fragment shader.
<li><b>buffer objects</b> are big arrays of floats passed by JS to the vertex shader in chunks of 1 to 4 items.
<br>For example, if a long list of vertex coordinates (X,Y,Z, X,Y,Z, ...) is sent to the vertex buffer 3 by 3, the shader will receive each chunk in the form of an <pre class=inline><code class="lang-js">attribute vec3</code></pre>.
<li>Each attribute, uniform and varying must be declared before main() in the shaders that uses them.
<li>JS can also send commands to the WebGL program to clear the screen, render the scene, etc... and this can be done many times per second to create an animation.
</ul>

<br><img src="images/webgl-guide/schema2.png" width=750>

<br><br>
<p>Don't worry, all these features will be explained and illustrated in the next chapters.

<br><br><hr><br>
<h2>2D graphics</h2>
<br><hr><br>


<h4>Hello, point</h4>

<ul>

</ul>

<p>Here's the simplest possible WebGL program, drawing a red, square point in the middle of the canvas.

<p>It's a live demo, feel free to play with the code and change some values!


<h5>Demo</h5>
<iframe id=i1 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=1"></iframe>

<h5>What happens here?</h5>
<ul>
<li>Two JavaScript objects are essential in a WebGL app: the canvas context <b>gl</b>, returned by <pre class=inline><code class="lang-js">canvas.getContext('webgl')</code></pre>, and <b>program</b>, returned by <pre class=inline><code class="lang-js">gl.createProgram()</code></pre>.
<li>JavaScript also uses the functions <b>createShader</b>, <b>shaderSource</b>, <b>compileShader</b>, <b>attachShader</b>, <b>linkProgram</b> and <b>useProgram</b> to set up and run the app,
<br>and the functions <b>clearColor</b>, <b>clear</b> and <b>drawArrays</b> to set the default background color, clear the canvas and draw a point on it.
<li>The vertex shader sets the vec4 <b>gl_Position</b> (x, y, z, 1.0), and <b>gl_PointSize</b> (in pixels). It is executed once, as there's only one vertex.
<li>Since we're drawing in 2D, the point's Z coordinate is 0.0, while X and Y are in the range [-1 : 1]: within the bounds of the canvas's viewport.
<br>The 4th coordinate of the point is fixed to 1.0, this will be useful to compute transformations in the next chapters.
<li>The fragment shader sets the vec4 <b>gl_Fragolor</b> (r, g, b, alpha), where the four values are in the range [0 : 1]. It is executed 100 times (once for each pixel inside the point).
<br>It starts with a mandatory directive, used to define the precision of its floating numbers: <pre class=inline><code class="lang-js">precision mediump float;</code></pre> (lowp and highp are also available). 
<li>If an error occurs during the compilation, it can be caught by <b>getShaderInfoLog</b> or <b>getProgramInfoLog</b> and logged in the browser's JS console.
</ul>

<h5>Tips & tricks</h5>
<ul>
<li>Depending on your device, the points larger than 62px may not be supported (<a href="http://webglstats.com/webgl/parameter/ALIASED_POINT_SIZE_RANGE">source</a>), and the points may disappear if their center is slightly outside of the canvas (<a href="https://webglfundamentals.org/webgl/lessons/webgl-drawing-without-data.html#pointsissues">source</a>).
<li>The program creation (lines 26 to 46) is always the same and pretty verbose, so we can put it in a <b>compile()</b> function and reuse it in the next chapters (see <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/webgl.js">webgl.js</a>):
</ul>
<pre style="font-size:11px"><code class="lang-js">// Compile a WebGL program from a vertex shader and a fragment shader
compile = (gl, vshader, fshader) => {
  
  // Compile vertex shader
  var vs = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vs, vshader);
  gl.compileShader(vs);
  
  // Compile fragment shader
  var fs = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fs, fshader);
  gl.compileShader(fs);
  
  // Create and launch the WebGL program
  var program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  gl.useProgram(program);
  
  // Log errors (optional)
  console.log('vertex shader:', gl.getShaderInfoLog(vs) || 'OK');
  console.log('fragment shader:', gl.getShaderInfoLog(fs) || 'OK');
  console.log('program:', gl.getProgramInfoLog(program) || 'OK');
  
  return program;
}</code>
</pre>

<br><br><hr><br>

<h4>Custom values: attributes and uniforms</h4>

<p>Of course, WebGL wouldn't be interesting if it could just draw one hard-coded point.
<br>To make it less rigid, we can give it custom values. This can be done with <b>attributes</b> (variable, readable by the vertex buffer) and <b>uniforms</b> (constant, readable by both buffers).
<br>Here are the different types of attributes and uniforms that can be set by JS:
<br>

<table border style="table-layout:auto">
<tr>
<th>Qualifier<th style="min-width:100px">Type<th>GLSL<th style="min-width:460px">How to set its value in JS

<tr>
<td rowspan=2>attribute
<td>float
<td><pre><code class="lang-js">attribute float f;</code></pre>
<td><pre><code class="lang-js">var f = gl.getAttribLocation(program, 'f');
gl.vertexAttrib1f(f, 1.0);</code></pre>

<tr>
<td>vec4
<td><pre><code class="lang-js">attribute vec4 v;</code></pre>
<td><pre><code class="lang-js">var f = gl.getAttribLocation(program, 'f');
gl.vertexAttrib4f(f, 1.0, 2.0, 3.0, 4.0); // list
gl.vertexAttrib4fv(f, [1.0, 2.0, 3.0, 4.0]); // or array</code></pre>
<tr>
<td rowspan=4>uniform

<td>int
<td><pre><code class="lang-js">uniform int i;</code></pre>
<td><pre><code class="lang-js">var i = gl.getUniformLocation(program, 'f');
gl.uniform1i(i, 1);</code></pre>

<tr>
<td>float
<td><pre><code class="lang-js">uniform float f;</code></pre>
<td><pre><code class="lang-js">var f = gl.getUniformLocation(program, 'f'):
gl.uniform1f(f, 1.0);</code></pre>

<tr>
<td>vec4
<td><pre><code class="lang-js">uniform vec4 v;</code></pre>
<td><pre><code class="lang-js">var f = gl.getUniformLocation(program, 'f');
gl.uniform4f(f, 1.0, 2.0, 3.0, 4.0); // list
gl.uniform4fv(f, [1.0, 2.0, 3.0, 4.0]); // or array</code></pre>

<tr>
<td>mat4
<td><pre><code class="lang-js">uniform mat4 m;</code></pre>
<td><pre><code class="lang-js">var m = gl.getUniformLocation(program, 'm');
gl.uniformMatrix4fv(
  m,
  false, // transpose (always false)
  new Float32Array([
    1.0, 2.0, 3.0, 4.0,
    5.0, 6.0, 7.0, 8.0,
    9.0, 10.0, 11.0, 12.0,
    13.0, 14.0, 15.0, 16.0
  ])
);</code></pre>

</table>

<br>(the types vec2 and vec3 can be declared similarly to vec4, and the types mat2 and mat3 similarly to mat4).


<h5>Demo</h5>
<iframe id=i2 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=2"></iframe>

<h5>What happens here?</h5>

<ul>
<li>Position is declared with <pre class=inline><code class="lang-js">attribute vec4 position;</code></pre>, targeted with <pre class=inline><code class="lang-js">position = gl.getAttribLocation(program,'position')</code></pre> and set with <pre class=inline><code class="lang-js">gl.vertexAttrib4f(position,0,0,0,1)</code></pre>.
<li>Point size is declared with <pre class=inline><code class="lang-js">attribute float size;</code></pre>, targeted with <pre class=inline><code class="lang-js">size = gl.getAttribLocation(program,'size')</code></pre> and set with <pre class=inline><code class="lang-js">gl.vertexAttrib1f(size,10)</code></pre>.
<li>Point color is declared with <pre class=inline><code class="lang-js">uniform float color;</code></pre>, targeted with <pre class=inline><code class="lang-js">color = gl.getUniformLocation(program,'color')</code></pre> and set with <pre class=inline><code class="lang-js">gl.uniform1f(color,1,0,0,1)</code></pre>.
</ul>

<h5>Tips & tricks</h5>
<ul>
<li>The fourth value of a vec4 attribute is 1.0 by default, so it's frequent to encounter some code that only sets x, y and z with <pre class=inline><code class="lang-js">gl.vertexAttrib3f(position, 0, 0, 0)</code></pre>.
<li>You can draw as many points as you want by setting new attributes / uniforms and calling <pre class=inline><code class="lang-js">gl.drawArrays(gl.POINTS,0,1)</code></pre> again.
<br>The same shaders will be executed each time but with different inputs.
<br>For example, here's the result if you uncomment the lines 45 to 52:
<br><br><img src="images/webgl-guide/rgb.jpg">
</ul>

<br><br><hr><br>
<h4>Drawing many points, a matter of continuity</h4>

<p>WebGL has no problem calling gl.drawArrays many times in a row, but only if it is in the same timeframe.
<br>Here's a program that tries to draw a new random point every 500ms:

<h5>Demo</h5>

<iframe id=i3 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=3"></iframe>

<h5>What happens here?</h5>
<p>As you can see, the canvas is not only cleared, but completely reset each time drawArrays() is called. This is because the draws happen at different moments.
<br>To solve this, there are two solutions:
<ol>
<li>Save the positions and colors of every new point. Then every 500ms, clear the canvas and redraw them all;
<li>Force <pre class=inline><code class="lang-js">{ preserveDrawingBuffer: true }</code></pre> when creating the WebGL context, as you can see by removing the commented code on line 4.
</ol>

<br><br><img src="images/webgl-guide/points.gif" width=300 loading=lazy>

<br><br><hr><br>

<h4>Drawing lines and triangles</h4>

<p>The next step consists in declaring many points at once, and telling WebGL how to display them: as points, as lines or as triangles.
<br>To do this, we'll use a <b>data buffer</b> (an array of binary numbers) to send vertex properties from JS to the fragment shader, via an attribute. The following types are supported:
</ul>
<br>
<table border>
<tr>
<th>Name
<th>Bounds
<th>JS container
<th>WebGL type

<tr>
<td>Unsigned byte
<td>0 ... 255
<td>new Uint8Array([...])
<td>gl.UNSIGNED_BYTE

<tr>
<td>Signed short integer
<td>−32,768 ... 32,767
<td>new Int16Array([...])
<td>gl.SHORT

<tr>
<td>Unsigned short integer
<td>0 ... 65,535
<td>new Uint16Array([...])
<td>gl.UNSIGNED_SHORT

<tr>
<td>Signed integer
<td>-2,147,483,648 ... 2,147,483,647
<td>new Int32Array([...])
<td>gl.INT

<tr>
<td>Unsigned integer
<td>0 ... 4,294,967,295
<td>new Uint32Array([...])
<td>gl.UNSIGNED_INT

<tr>
<td>Floating point number
<td>(32-bit float precision)
<td>new Float32Array([...])
<td>gl.FLOAT
</table>
<br>
<p>Then, <b>gl.drawArrays</b> can render these vertices as points, lines and triangles in 7 different ways, by changing its first parameter:
<br>
<br>
<img src="images/webgl-guide/modes.png" width=800 style="border:2px solid #ddd">

<h5>Demo</h5>
<p>Here's the simplest way to draw a triangle:
<br>
<br>
<iframe id=i4 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=4"></iframe>

<h5>What happens here?</h5>
<ul>
<li>A data buffer is filled with 3 points coordinates and bound to the <b>position</b> attribute using <b>createBuffer</b>, <b>bindBuffer</b>, <b>bufferData</b>, <b>vertexAttribPointer</b> &amp; <b>enableVertexAttribArray</b>.
<li>The last instruction tells <b>gl.drawArrays</b> to render these points as a triangle.<br>As a result, every fragment placed between these points will be filled with the color present in the "color" uniform variable (red).
<li>If you replace <b>gl.TRIANGLES</b> with <b>gl.LINE_LOOP</b>, only the lines between points 0-1, 1-2, and 2-0 will be rendered, with a <b>line width</b> of 1px (1 fragment).
<br>You can also try <b>gl.LINE_STRIP</b> to trace lines between points 0-1 and 1-2, and <b>gl.LINES</b> to draw   line between points 0 and 1, as it only works on successive pairs of points.
<br>Unfortunately, the line width can't be changed reliably in current WebGL implementations (more info <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/lineWidth">here</a>).
<li>Lines and triangles do not need or use <b>gl_PointSize</b>. If you replace <b>gl.TRIANGLES</b> with <b>gl.POINTS</b>, you'll have to set gl_PointSize again.
</ul>

<h5>Tips &amp; tricks</h5>

<ul>
<li>You can draw as many triangles as you want by adding vertices on line 33 and updating count on line 61.
<li>In all the following chapters' demos, you can replace <b>gl.TRIANGLES</b> with <b>gl.LINE_LOOP</b> to see the scene in <b>wireframe</b>.
<li>The buffer creation and binding is also quite verbose, so let's put it in the function <b>buffer()</b>, in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/webgl.js">webgl.js</a>:
</ul>
<pre style="font-size:11px"><code class="lang-js">// Bind a data buffer to an attribute, fill it with data and enable it
buffer = (gl, data, program, attribute, size, type) => {
  gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
  var a = gl.getAttribLocation(program, attribute);
  gl.vertexAttribPointer(a, size, type, false, 0, 0);
  gl.enableVertexAttribArray(a);
}</code>
</pre>

<br><hr><br>

<h4>Multi-attribute buffer and varying color</h4>

<p>Now, we want to give a different color to our three vertices, and draw a triangle with them.
<br>The vertex colors can be transmitted to the fragment buffer via a <b>varying</b> variable, to produce a gradient (this process is called <b>color interpolation</b>).
<br>The X/Y/Z and R/G/B values for each vertex can be stored in two data buffers, or in an <b>interleaved data buffer</b>, like here:
<h5>Demo</h5>

<iframe id=i6 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=5"></iframe>

<h5>What happens here?</h5>
<ul>
<li>For every chunk of 6 floats in the data buffer,
<br>- <pre class=inline><code class="lang-js">gl.vertexAttribPointer(position,3,gl.FLOAT,false,FSIZE*6,0);</code></pre> binds the first 3 values to the attribute <b>position</b>,
<br>- <pre class=inline><code class="lang-js">gl.vertexAttribPointer(color,3,gl.FLOAT,false,FSIZE*6,FSIZE*3);</code></pre> binds the last 3 values to the attribute <b>color</b>.
<li>The varying v_color is declared in both shaders.
<br>- In the vertex shader, it receives the color of the current vertex.
<br>- In the fragment shader, its value is automatically interpolated from the three vertices around it:
<!--<li>The vertex buffer will receive the positions and colors for each vertex and will need to transmit the colors to the fragment buffer.
<br>To do so, we will use a <b>varying</b>: a global variable that is writable by the vertex shader and readable by the fragment shader.
<br>Varyings are declared at the beginning of both shaders, and set in the code of the vertex shader. It's a good practice to name them with a "v_" prefix.
<br>Every fragment (pixel) inside the triangle, if it's bound to a varying color variable, will be interpolated from the color of each vertex around it!
-->
</ul>


<img src="images/webgl-guide/interpolation.gif" width=350 style="border:2px solid #ddd">
<br>
<h5>Tips and tricks</h5>

<ul>
<li>It's a good practice to prefix every varying name with "v_".
<li>Color interpolation also works in <b>LINES</b>, <b>LINE_STRIP</b> and <b>LINE_LOOP</b> modes.
</ul>

<br><br><hr><br>
<!--

<h4>Translate, rotate, scale</h4>

<ul>
<li>If we want to move, rotate or scale a triangle, we need to know how to transform each of its vertices.
<li><b>Translation</b> consists in moving all the vertices in a given direction (increase or decrease its X/Y/Z coordinates).
<li><b>Rotation</b> consists in moving the vertices around a <b>pivot point</b>, with a given angle (a full turn clockwise is 360 degrees or 2 * Pi radians).
<li><b>Scaling</b> consists in making the triangle smaller or bigger by bringing the vertices closer or further from a pivot point.
<li>These operations can be done component per component (compute X, then Y, then Z), but we generally use a much powerful tool: <b>matrix transformations</b>.
<li>Each transformations can be written as a mat4 (a matrix of 4x4 floats), and applied to a vertex's <b>homogeneous coordinates</b> (vec4(X, Y, Z, 1.0)) with a multiplication.
</ul>

<p>
<table border>
<tr>
<th>Transformation
<th style=min-width:250px>Transformation applied to each vertex coordinates
<th><div style="min-width: 260px">transformation via a matrix</div>

<tr>
<td>Identity (no change)
<td>x' = x
<br>y' = y
<br>z' = z
<td style=padding:10px>

<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr>
<td>Translation along X, Y and Z axis
<td>x' = x + Tx
<br>y' = y + Ty
<br>z' = z + Tz
<td style=padding:10px>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Tx</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Ty</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>Tz</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr>
<td>Rotation around the X with an angle φ
<br>(φ is in radians)
<td>x' = x
<br>y' = y cos φ - z sin φ
<br>z' = y sin φ + z cos φ
<td style=padding:10px>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>cos φ</mn></mtd>
            <mtd><mn>-sin φ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>sin φ</mn></mtd>
            <mtd><mn>cos φ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr style=padding:10px>
<td>Rotation around the Y with an angle θ
<td>x' = x cos θ + z sin θ
<br>y' = y
<br>z' = -x sin θ + z cos θ
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>cos θ</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>sin θ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>-sin θ</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>cos θ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr style=padding:10px>
<td>Rotation around the Z axis with an angle ψ
<td>x' = x cos ψ – y sin ψ
<br>y' = x sin ψ + y cos ψ
<br>z' = z
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>cos ψ</mn></mtd>
            <mtd><mn>-sin ψ</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>sin ψ</mn></mtd>
            <mtd><mn>cos ψ</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr style=padding:10px>
<td>Scaling along X, Y and Z axis
<td>x' = Sx * x
<br>y' = Sy * y
<br>z' = Sz * z
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>Sx</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Sy</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Sz</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

</table>

<ul>
<li>Multiple transformations can be accumulated by multiplying their matrices from right to left.
<br>For example, to translate then rotate a point, multiply in this order: (〈 rotation matrix 〉 × 〈 translation matrix 〉) × 〈 coordinates vector 〉
<li>Matrices and vectors can be multiplied together natively in GLSL:
</ul>

<iframe id=i5 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=6"></iframe>

<ul>
<li>As you can see on line 14 and 41 to 72, the 3 matrices are declared in JS and sent to the fragment shader, which multiplies them with each vertex position.
<br>This is easy to code, but unfortunately not optimal in real conditions, as the multiplications must be hardcoded in glsl and repeated for every fragment of the program.
<br>In the following examples, the compound transformation matrix will be computed only once (in JS) and passed to the shader.
</ul>

<p>Helper functions added in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/matrix.js">matrix.js</a> (because matrices multiplications are not native in JS):
<pre style="font-size:11px"><code class="lang-js">// Create an identity mat4
identity = () => {
  return new Float32Array([
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
  ]);
};

// Compute the multiplication of two mat4 (c = a x b)
multMat4Mat4 = (a, b) => {
  var i, e, a, b, ai0, ai1, ai2, ai3;
  var c = new Float32Array(16);
  for (i = 0; i &lt; 4; i++) {
    ai0 = a[i];
    ai1 = a[i+4];
    ai2 = a[i+8];
    ai3 = a[i+12];
    c[i]    = ai0 * b[0]  + ai1 * b[1]  + ai2 * b[2]  + ai3 * b[3];
    c[i+4]  = ai0 * b[4]  + ai1 * b[5]  + ai2 * b[6]  + ai3 * b[7];
    c[i+8]  = ai0 * b[8]  + ai1 * b[9]  + ai2 * b[10] + ai3 * b[11];
    c[i+12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
  }
  return c;
};

// Transform a mat4
// options: x/y/z (translate), rx/ry/rz (rotate), sx/sy/sz (scale)
transform = (mat, options) => {

  var out = new Float32Array(mat);
  
  var x = options.x || 0;
  var y = options.y || 0;
  var z = options.z || 0;
  
  var sx = options.sx || 1;
  var sy = options.sy || 1;
  var sz = options.sz || 1;
  
  var rx = options.rx;
  var ry = options.ry;
  var rz = options.rz;
  
  // translate
  if(x || y || z){
    out[12] += out[0] * x + out[4] * y + out[8]  * z;
    out[13] += out[1] * x + out[5] * y + out[9]  * z;
    out[14] += out[2] * x + out[6] * y + out[10] * z;
    out[15] += out[3] * x + out[7] * y + out[11] * z;
  }
  
  // Rotate
  if(rx) out.set(multMat4Mat4(out, new Float32Array([1, 0, 0, 0, 0, Math.cos(rx), Math.sin(rx), 0, 0, -Math.sin(rx), Math.cos(rx), 0, 0, 0, 0, 1])));
  if(ry) out.set(multMat4Mat4(out, new Float32Array([Math.cos(ry), 0, -Math.sin(ry), 0, 0, 1, 0, 0, Math.sin(ry), 0, Math.cos(ry), 0, 0, 0, 0, 1])));
  if(rz) out.set(multMat4Mat4(out, new Float32Array([Math.cos(rz), Math.sin(rz), 0, 0, -Math.sin(rz), Math.cos(rz), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])));
  
  // Scale
  if(sx !== 1){
    out[0] *= sx;  
    out[1] *= sx;
    out[2] *= sx;
    out[3] *= sx;
  }
  if(sy !== 1){
    out[4] *= sy;
    out[5] *= sy;
    out[6] *= sy;
    out[7] *= sy;
  }
  if(sz !== 1){
    out[8] *= sz;
    out[9] *= sz;
    out[10] *= sz;
    out[11] *= sz;
  }
  
  return out;
};</code>
</pre>

<h5>How to change the pivot point</h5>

<p>The rotations and scaling matrices, as described above, only allow to use the world's origin (0,0,0) as pivot point.
<br>Imagine a triangle that is not centered on the origin, and needing to rotate 90 degrees (Pi / 2 radins) around its center, for example the point (2,2,0).
<br>The solution is to apply 3 transformation matrices to this triangle's vertices: translate to (0,0,0), then rotate 90 degrees, then translate back to (2,2,0)!

<br><br><hr><br>

<h4>Texturing</h4>

<ul>
<li>As we saw earlier, the colors of the fragments inside a triangle are interpolated from the colors of each vertex around it.
<br>The same principle can be used with a texture image (it's called sampling in this case).
<li>Each texture (square or rectangle) has a local coordinates system (U,V) that goes from 0 to 1, and every vertex can have its own <b>texture coordinates</b> in this system.
<li>A JS Image object can be bound to an <b>uniform sampler2D</b> to create a texture, which is applied to the current fragment using <b>gl_FragColor = texture2D(sampler, coords);</b>
<li>The "pixels" of the texture are called texels. The texture files are generally squared to avoid being stretched in a direction or the other.
<br><img src="images/webgl-guide/texture.png">
</ul>

<p>Here's an example of textured quad (a square made of two triangles). You can edit the numbers to change the way the vertices and texture are mapped:
<p>
<iframe id=i7 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=7"></iframe>

<p>Remember that the values you're manipulating are rgba colors, so you can basically do anything you want with them, like inverting the colors:

<pre class="language-js"><code>vec4 color = texture2D(sampler, v_TexCoord);
gl_FragColor = vec4(vec3(1.0, 1.0, 1.0) - color.rgb, 1.0);</code></pre>

<br><img src="images/webgl-guide/textures0.png">

<h5>Multiple textures</h5>
<p>Two or more textures can also be used at the same time. For example, you can initialize two samplers, and add or multiply them in the fragment shader:
<pre class="language-js"><code>vec4 color0 = texture2D(sampler0, v_TexCoord);
vec4 color1 = texture2D(sampler1, v_TexCoord);
gl_FragColor = color0 + color1;

// or

gl_FragColor = color0 * color1;</code></pre>

<br><img src="images/webgl-guide/textures.png" width=600>

<p>Or blend them together, using the <b>mix()</b> function:

<pre class="language-js"><code>gl_FragColor = mix(color0, color1, 0.25); // color0 * 0.25 + color1 * 0.75;</code></pre>

<br><img src="images/webgl-guide/textures2.png" width=600>

<br><br><hr><br>
<h2>3D graphics</h2>
<br><hr><br>

<br>You should know by now that computers don't do "3D" natively.
<br>You (or your 3D framework) will have to do all the computing to simulate the camera, the perspective and how they affect each polygon, so the scene can seem to be in 3D.
<br>Fortunately, the API we use (WebGL) provides very helpful tools (especially data and depth buffers) to help rendering complex scenes without too much effort.
<br>
<h4>3D camera</h4>
<br><img src="images/webgl-guide/frustum.png">
<ul>
<li>In 3D, the "camera", with its position, angle and perspective, is defined by nothing more than a 4x4 matrix.
<li>During render, every vertex in the scene is multiplied by this matrix to simulate these camera properties and appear at the right position.
<li>The camera's frustum, also called "clipping volume", defines an area in which the scene will be rendered.
<br>For a camera with perspective, it is defined by a field of view angle, an aspect ratio, a near clip plane and a far clip plane, and can be set with this matrix:

<div class=math>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1/(aspect*tan(fov/2))</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1/tan(fov/2)</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-(far+near)/(far-near)</mn></mtd>
            <mtd><mn>-(2*far*near)/(far-near)</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-1</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>
</div>

<li>Then, the camera can be translated, rotated and scaled (zoomed) similarly to the vertices, by using the matrices multiplications we saw earlier.
<li>A slightly more advanced LookAt() function is often used by developers to set the camera's position, angle and target all at once.
</ul>
<p>Here are the perspective() and lookAt() functions I added in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/matrix.js">matrix.js</a>:

<pre><code class="lang-js">// Create a perspective matrix
// options: fov, aspect, near, far
orthogonal = options => {
  var fov = options.fov || 1.5;
  var aspect = options.ratio || 1; // canvas.width / canvas.height
  var near = options.near || 0;
  var far = options.far || 100;
  var f = 1 / Math.tan(fov);
  var nf = 1 / (near - far);
  return new Float32Array([
    f / aspect, 0, 0, 0, 
    0, f, 0, 0, 
    0, 0, (far + near) * nf, -1,
    0, 0, (2 * near * far) * nf, 0
  ]);
}

// Place a camera at the position [cameraX, cameraY, cameraZ], make it look at the point [targetX, targetY, targetZ].
// Optional: a "up" vector can be defined to tilt the camera on one side (vertical by default).  
lookAt = (mat, cameraX, cameraY, cameraZ, targetX, targetY, targetZ, upX = 0, upY = 1, upZ = 0) => {
  var e, fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;
  fx = targetX - cameraX;
  fy = targetY - cameraY;
  fz = targetZ - cameraZ;
  rlf = 1 / Math.sqrt(fx*fx + fy*fy + fz*fz);
  fx *= rlf;
  fy *= rlf;
  fz *= rlf;
  sx = fy * upZ - fz * upY;
  sy = fz * upX - fx * upZ;
  sz = fx * upY - fy * upX;
  rls = 1 / Math.sqrt(sx*sx + sy*sy + sz*sz);
  sx *= rls;
  sy *= rls;
  sz *= rls;
  ux = sy * fz - sz * fy;
  uy = sz * fx - sx * fz;
  uz = sx * fy - sy * fx;
  var l = new Float32Array(
    sx, ux, -fx, 0,
    sy, uy, -fy, 0,
    sz, uz, -fz, 0,
    0,  0,  0,   1
  );
  l = transform(l, {x: -cameraX, y: -cameraY, z: -cameraZ});
  return multMat4Mat4(mat, l); 
}</code>
</pre>

<br>
<p>It's also possible to make a camera with no perspective, also called "orthogonal", "orthographic", "isometric" or "2.5D" view.
<br>In this case, the frustum is a box:
<br><img src="images/webgl-guide/orthogonal.png">
<br>
<p>Here are the matrix and the corresponding source code:

<div class=math>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>2/(right-left))</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-((right+left)/(right-left))</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>2/(top-bottom)</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-((top+bottom)/(top-bottom))</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-2/(far-near)</mn></mtd>
            <mtd><mn>-((tar+near)/(far-near))</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>
</div>
<br>

<pre><code class="lang-js">// Create an orthogonal matrix
// options: top, bottom, left, right, near, far
orthogonal = options => {
  var top = options.top;
  var bottom = options.bottom;
  var left = options.left;
  var right = options.right;
  var near = options.near || 0;
  var far = options.far || 100;
  var rw = 1 / (right - left);
  var rh = 1 / (top - bottom);
  var rd = 1 / (far - near);
  return new Float32Array([
    2 * rw, 0, 0, 0,
    0, 2 * rh, 0, 0,
    0, 0, -2 * rd, 0,
    -(right + left) * rw, -(top + bottom) * rh, -(far + near) * rd, 1
  ]);
}</code>
</pre>

<p>You may have noticed that the matrix is different in the mathematic formula and in the source code.
<br>This is because WebGL requires that all the matrices used in the shaders are transposed (i.e. X and Y axis are inversed).
<br>You don't need to worry about it when using the functions in  <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/matrix.js">matrix.js</a>, but otherwise, you can either write your matrices already transposed, or use this function:

<pre><code class="lang-js">// Get the transposed of a mat4
transpose = m => {
  return new Float32Array([
    m[0], m[4], m[8],  m[12],
    m[1], m[5], m[9],  m[13],
    m[2], m[6], m[10], m[14],
    m[3], m[7], m[11], m[15]
  ]);
};</code>
</pre>

<br><br><hr><br>

<h4>Reduce repetitions with indexed vertices</h4>

<ul>
<li>Before starting to draw 3D objects (that require a lot of triangles), we need to learn an optimized way to write our buffers.
<li>As we have seen before, data buffers (with the type gl.ARRAY_BUFFER) can hold vertex properties (position, color, texture coordinates...).
<li>These properties can be placed into multiple buffers or interleaved into a single one.
<li>In 3D, vertices are often shared between multiple triangles.
<li>Instead of repeating the same vertices many times in the same buffer, it's possible to write each vertex only once in a data buffer,<br>and use a second buffer with the type <b>gl.ELEMENT_ARRAY_BUFFER</b> that declares all our triangles by using indices of the first object.
<li>Even if many data buffers exist in your program, only one index buffer can be used, and it will list indices from all the data buffers at once,<br>so they all need to be stored in the same order (the N'th item of every buffer must belong to the same N'th vertex).
<li>Finally, to draw indexed vertices, you need you replace gl.drawArrays with <b>gl.drawElements(type, count, type, offset)</b>.
<li>The indices stored in the index buffer have integer values (N = 0, 1, 2...), and you can choose their size in bytes depending on the number of vertices you want to index:
<br>
<br>
<table border>
<tr>
<th>Number of vertices to index
<th>Index buffer type
<th>drawElements type
<tr>
<td>0 ... 256
<td>Uint8Array([...])
<td>gl.UNSIGNED_BYTE
<tr>
<td>0 ... 65,536
<td>Uint16Array([...])
<td>gl.UNSIGNED_SHORT
<tr>
<td>0 ... 4,294,967,296
<td>Uint32Array([...])
<td>gl.UNSIGNED_INT (*)
</table>

<p>(*) In WebGL1, an extension must be enabled before using the type UNSIGNED_INT: <b>gl.getExtension('OES_element_index_uint');</b>. In WebGL2, it's enabled by default.
</ul>

<br>
<p>You can see indexed buffers in action in the following demos...


<br><br><hr><br>

<h3>Hello cube</h3>

<p>The easiest 3D shape to render is a cube. But to render it correctly, two new settings must be used:
<ul>
<li>In order to make each triangle appear at the right depth (the front ones in front, the back ones in the back), depth-sorting must be enabled with <b>gl.enable(gl.DEPTH_TEST);</b>
<li>The clear code is also updated to take this depth test into account: <b>gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);</b> (see lines 95 and 106).
</ul>

<iframe id=i8 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=8"></iframe>

<p>You can notice that the cube appears to rotate on itself, but it's actually the camera that rotates around it (see lines 97-100 + 104).

<p>Remember that in every demo, you can see the scene in "wireframe" by changing the first parameter of gl.grawElements to gl.LINE_STRIP:

<br>

<br><img src="images/webgl-guide/wire.png" width=200>

<br><br><hr><br>

<h3>Color each face of the cube</h3>

<ul>
<li>To color each face individually, each vertex can't have an unique color like before. Its color needs to vary depending on which face is being rendered.
<li>The solution is to declare all the possible combinations of vertices positions and colors in two data buffers, and use an index buffer to create the corresponding triangles.
<li>The same principle will apply if you want to make a cube with different textures on each face.
</ul>

<iframe id=i9 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=9"></iframe>

<p>I've added the cube declaration in the cube() function of <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/shapes.js">shapes.js</a> to avoid repeating it in the next demos:

<pre><code class="lang-js">// Declare a cube (2x2x2)
// Returns [vertices (Float32Array), normals (Float32Array), indices (Uint16Array)] 
//
//    v6----- v5
//   /|      /|
//  v1------v0|
//  | |     | |
//  | |v7---|-|v4
//  |/      |/
//  v2------v3

cube = (r = 1, g = 1, b = 1) => {

  var vertices = new Float32Array([
     1.0, 1.0, 1.0,  -1.0, 1.0, 1.0,  -1.0,-1.0, 1.0,   1.0,-1.0, 1.0, // front
     1.0, 1.0, 1.0,   1.0,-1.0, 1.0,   1.0,-1.0,-1.0,   1.0, 1.0,-1.0, // right
     1.0, 1.0, 1.0,   1.0, 1.0,-1.0,  -1.0, 1.0,-1.0,  -1.0, 1.0, 1.0, // up
    -1.0, 1.0, 1.0,  -1.0, 1.0,-1.0,  -1.0,-1.0,-1.0,  -1.0,-1.0, 1.0, // left
    -1.0,-1.0,-1.0,   1.0,-1.0,-1.0,   1.0,-1.0, 1.0,  -1.0,-1.0, 1.0, // down
     1.0,-1.0,-1.0,  -1.0,-1.0,-1.0,  -1.0, 1.0,-1.0,   1.0, 1.0,-1.0  // back
  ]);

  var normals = new Float32Array([
    0.0, 0.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0, 1.0,  // front
    1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0,  // right
    0.0, 1.0, 0.0,   0.0, 1.0, 0.0,   0.0, 1.0, 0.0,   0.0, 1.0, 0.0,  // up
   -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  // left
    0.0,-1.0, 0.0,   0.0,-1.0, 0.0,   0.0,-1.0, 0.0,   0.0,-1.0, 0.0,  // down
    0.0, 0.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,-1.0   // back
  ]);

  var indices = new Uint16Array([
    0, 1, 2,   0, 2, 3,  // front
    4, 5, 6,   4, 6, 7,  // right
    8, 9, 10,  8, 10,11, // up
    12,13,14,  12,14,15, // left
    16,17,18,  16,18,19, // down
    20,21,22,  20,22,23  // back
  ]);
  
  return [vertices, normals, indices];
};</code></pre>

<p>In bonus, <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/shapes.js">shapes.js</a> also contains the models for a sphere and a pyramid.
<br>You can test them in all the following demos by replacing cube() with <b>sphere()</b> or <b>pyramid()</b>.

<br><br><img src="images/webgl-guide/othershapes.png">

<br><br>NB: all the shapes in this file use Uint16Array's for indices, so remember to use <b>gl.UNSIGNED_SHORT</b> in drawArrays().

<br><br><hr><br>

<h4>Lighting and shading</h4>

<h5>Normals and cross-products</h5>

<img src="images/webgl-guide/normal.png" width=300>
<br>

<ul>
<li>Each triangle has a <b>normal</b>: it's a vec3 perpendicular to its surface, and <b>normalized</b> (with a length equal to 1).
<li>A normal can be computed using a <b>cross-product</b> of two edge's vectors: AB × BC if the points A, B and C are in counterclockwise order.

<br><br><a href="https://twitter.com/FreyaHolmer/status/1203059678705602562?ref_src=twsrc%5Etfw"><img src="images/webgl-guide/cross.gif" width=300 style="border: 1px solid #ddd;"></a>
<br><br>

<li>A cross-product can be computed natively in GLSL: <b>cross(AB, BC)</b>.

<br>However, the normals of a 3D model are generally hard-coded or computed in JS when the page loads. Here's the source code:
</ul>
<pre><code class="lang-js">// Cross-product of three points a, b, c.
// Returns the coordinates of a normal vector perpendicular to the side where these points are counter-clockwise.
cross = (a0, a1, a2, b0, b1, b2, c0, c1, c2) => {
  var xAB = b0 - a0, yAB = b1 - a1, zAB = b2 - a2; // AB vector
  var xBC = c0 - b0, yBC = c1 - b1, zBC = c2 - b2; // BC vector
  return [yAB * zBC - zAB * yBC, zAB * xBC - xAB * zBC, xAB * yBC - yAB * xBC]; // cross product
}</code></pre>



<h5>Dot product</h5>

<a href="https://twitter.com/FreyaHolmer/status/1200807790580768768?ref_src=twsrc%5Etfw"><img src="images/webgl-guide/dot.gif" width=250 style="border: 1px solid #ddd;"></a>

<ul>
<li>The dot product is another interesting function: it compares two vectors and tells how perpendicular they are. (1: parallel, 0: perpendicular, -1: opposite of each other).
<br>In our case, it is useful to check if a triangle is facing a light source, and render it accordingly.
<li>This operation is generally done inside the shader, using the native function <b>dot(lightDirection, normmal)</b>.
<li>If you need to do it in JS, here's the corresponding code:
</ul>

<pre><code class="lang-js">// Dot-product of two vec3: v and w
dot = (v0, v1, v2, w0, w1, w2) => {
  return v0 * w0 + v1 * w1 + v2 * w2;
}</code></pre>



<h5>Diffuse light</h5>
<ul>
<li>Diffuse light (also called <b>directional light</b>) is the equivalent of the sun's light on Earth: all the rays are parallel and have the same intensity everywhere in the scene.
<li>When it hits a surface, it is reflected in all directions, but the intensity of the reflexion decreases proportionally to the angles in which the light hits the surface:
<br><img src="images/webgl-guide/diffuse.png">
<li>To simulate it, we need to define a light source with a color (for example, white), and a direction (for example, vec3(0.5, 3.0, 4.0)).

<li>The color sent to the fragment shader is: the light's color (rgb) × the face color (rgb) × the dot product of the normal and the light. The color's alpha is set to 1.0.
<li>If the dot product is negative, we set it to "0" (there can't be a negative amount of light). This is done with <b>max(dot(light, normal), 0.0);</b>
<li>NB: The components of a vec4 can be accessed with .x/y/z/t (for a position) or .r/g/b/a (for a color). They can also be composed into a new vector (ex: <b>vec3 rgb = col.rgb</b>).
</ul>

<iframe id=i10 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=10"></iframe>

<br><h5>Ambient light</h5>

<p>With diffuse lighting alone, some faces are too dark, like the rightmost one here. To fix that, we can add an ambient light reflexion.
<br>It corresponds to a light that is applied equally to all the faces of a model, regardless to their normal vector.
<br>To simulate it, we need to set a light color (not too bright, for example: vec3(0.2, 0.2, 0.2)), multiply it to the surface color, and add it to the diffuse light:
<br>
<br>
<iframe id=i11 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=11"></iframe>

<br>
<h5>Point light</h5>

<ul>
<li>We can also have a <b>point light</b> representing a light bulb, with a specific position and color.
<li>It's a kind of diffuse light, except that the light rays are not parallel, because the light source is not infinitely far away.
<li>With such a point light in the scene, the shading intensity will vary according to the distance from the light source, but also with the angle of the light rays.
<li>In the real world, the light <b>attenuation</b> is proportional to the distance squared, but in CGI, it's more often proportional to the distance (not squared).
<li>When a point light reflexion is computed per vertex, it looks a bit nicer but the triangles are still visible:
<br>
<br><img src="images/webgl-guide/per_vertex.png" width=500>
<br>
<br>
<li>The best solution consists in computing the right color for every fragment of the cube (i.e. every pixel) according to its distance from the light source,<br>and that's exactly what the fragment shader is here for:
<br><br><img src="images/webgl-guide/sphere.png" width=500>
</ul>
<p>The following demo shows how a point light can be computed per fragment. You can play with the numbers to change how it looks.
<br>The vertex shader sends the vertices positions, colors and normals to the fragment shader using varyings, and the fragment shader computes everything. 
<br>
<br>
<iframe id=i12 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=12"></iframe>

<h5>Smooth shading</h5>

<ul>
<li>With the current implementation, each face has an unique normal vector, which is used by all its vertices.
<br>This provokes a <b>facetted</b> (or "polygonal") rendering, with "hard edges" between the triangles.
<li><b>Smooth shading</b>, also called Phong shading, consists in computing a different normal for each vertex, equal to the mean of the normals of all the triangles around it.
<br>But no need to use divisions to obtain this mean value! Just add all the normals together and the mean will appear when the shaders will normalize the result (more info <a href="https://www.iquilezles.org/www/articles/normals/normals.htm">here</a>).
<br>Example: the same 3D model with smooth shading disabled / enabled:
<br><br><img src="images/webgl-guide/w5.gif" width=650>
</ul>

<h5>Other types of lighting</h5>
<ul>
<li>Emissive lighting: when an object is self-illuminated - this can be easy if you just want to make the fragments lighter (multiply their rgb color with a number higher than 1),
<br>or very complicated if you want the surface to illuminate surrounding objects (this will not be covered here :p ).
<li>Specular lighting: when an object is shiny, it can reflect a point light like a mirror under a certain angle (more info <a href="https://webgl2fundamentals.org/webgl/lessons/webgl-3d-lighting-point.html">here</a>).
<br>To simulate it, we can compute the half-vector between the camera, the fragment and the light, and compare this with the surface normal using a dot product.
<br>This dot product is then powered to a number that represents the surface's "shininess", and added to the other (ambient / diffuse / emmisive) lights in the fragment shader:
</ul>
<img src="images/webgl-guide/specular.png">

<pre><code class=lang-js>var fshader = `
(...)
float shininess = 150.0;
vec3 surfaceWorldPosition = (u_world * a_position).xyz;
vec3 v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;
vec3 v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;
vec3 surfaceToLightDirection = normalize(v_surfaceToLight);
vec3 surfaceToCameraDirection = normalize(v_surfaceToCamera);
vec3 halfVector = normalize(surfaceToLightDirection + surfaceToCameraDirection);
float light = dot(normal, surfaceToLightDirection);
# the pow is to avoid having specular reflection that's too shiny
float specular = pow(dot(normal, halfVector), shininess);
color.rgb *= light * lightColor;
color.rgb += specular * specularLightColor;
(...)
`;</code></pre>

<h5>A bit of vocabulary</h5>

<ul>
<li>You may find documents talking about ambient / diffuse / specular <b>colors</b>. It's the same thing as ambient / diffuse / specular <b>lighting</b>.
<br>And it kind of makes sense: in CG, like in the real world, the colors emitted by an object depend entirely on its lighting.

<li>However, <b>lighting</b> and <b>shading</b> are not the same thing, even though the two terms are often mixed.
<br>Lighting is actually a physics notion (how the light affects an object) while shading is purely CG-related (how a pixel is rendered on a screen).
</ul>

<br><hr><br>

<h4>Transforming the shaded cube</h4>

<ul>
<li>So far, we've only transformed the camera matrix, to make it revolve around the cube to create an illusion of cube rotation.
<li>Now that we have a fixed point light in the scene, if we want to rotate, translate or scale the cube without touching the rest of the scene, we need to do two things:<br>- introduce a <b>model matrix</b> (the transformation matrix of the cube),<br>- recompute the cube's normals and the lighting of every fragment every time the model matrix is updated.

<li>In practice, the best method is to keep the original normals unchanged, and pass them to the vertex shader, along with the vertex position and color.
<br>
Then, when the model matrix changes, the trick is compute its <b>inverse transpose</b> and pass it to the vertex shader in the form of an uniform mat4.
<br>
In the vertex shader, simply multiply the original normal with this inverse transpose matrix to obtain its updated value: <b>vec3 newNormal = oldNormal * inverseTranspose</b>.
<li>Here are the inverse() and inverseTranspose() functions added in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/matrix.js">matrix.js</a>:

<pre><code class="lang-js">// Get the inverse of a mat4
inverse = m => {
  var inv = new Float32Array([
     m[5]*m[10]*m[15] - m[5]*m[11]*m[14] - m[9]*m[6]*m[15] + m[9]*m[7]*m[14] + m[13]*m[6]*m[11] - m[13]*m[7]*m[10],
    -m[1]*m[10]*m[15] + m[1]*m[11]*m[14] + m[9]*m[2]*m[15] - m[9]*m[3]*m[14] - m[13]*m[2]*m[11] + m[13]*m[3]*m[10],
     m[1]*m[6]*m[15]  - m[1]*m[7]*m[14]  - m[5]*m[2]*m[15] + m[5]*m[3]*m[14] + m[13]*m[2]*m[7]  - m[13]*m[3]*m[6],
    -m[1]*m[6]*m[11]  + m[1]*m[7]*m[10]  + m[5]*m[2]*m[11] - m[5]*m[3]*m[10] - m[9]*m[2]*m[7]   + m[9]*m[3]*m[6],
    -m[4]*m[10]*m[15] + m[4]*m[11]*m[14] + m[8]*m[6]*m[15] - m[8]*m[7]*m[14] - m[12]*m[6]*m[11] + m[12]*m[7]*m[10],
     m[0]*m[10]*m[15] - m[0]*m[11]*m[14] - m[8]*m[2]*m[15] + m[8]*m[3]*m[14] + m[12]*m[2]*m[11] - m[12]*m[3]*m[10],
    -m[0]*m[6]*m[15]  + m[0]*m[7]*m[14]  + m[4]*m[2]*m[15] - m[4]*m[3]*m[14] - m[12]*m[2]*m[7]  + m[12]*m[3]*m[6],
     m[0]*m[6]*m[11]  - m[0]*m[7]*m[10]  - m[4]*m[2]*m[11] + m[4]*m[3]*m[10] + m[8]*m[2]*m[7]   - m[8]*m[3]*m[6],
     m[4]*m[9]*m[15]  - m[4]*m[11]*m[13] - m[8]*m[5]*m[15] + m[8]*m[7]*m[13] + m[12]*m[5]*m[11] - m[12]*m[7]*m[9],
    -m[0]*m[9]*m[15]  + m[0]*m[11]*m[13] + m[8]*m[1]*m[15] - m[8]*m[3]*m[13] - m[12]*m[1]*m[11] + m[12]*m[3]*m[9],
     m[0]*m[5]*m[15]  - m[0]*m[7]*m[13]  - m[4]*m[1]*m[15] + m[4]*m[3]*m[13] + m[12]*m[1]*m[7]  - m[12]*m[3]*m[5],
    -m[0]*m[5]*m[11]  + m[0]*m[7]*m[9]   + m[4]*m[1]*m[11] - m[4]*m[3]*m[9]  - m[8]*m[1]*m[7]   + m[8]*m[3]*m[5],
    -m[4]*m[9]*m[14]  + m[4]*m[10]*m[13] + m[8]*m[5]*m[14] - m[8]*m[6]*m[13] - m[12]*m[5]*m[10] + m[12]*m[6]*m[9],
     m[0]*m[9]*m[14]  - m[0]*m[10]*m[13] - m[8]*m[1]*m[14] + m[8]*m[2]*m[13] + m[12]*m[1]*m[10] - m[12]*m[2]*m[9],
    -m[0]*m[5]*m[14]  + m[0]*m[6]*m[13]  + m[4]*m[1]*m[14] - m[4]*m[2]*m[13] - m[12]*m[1]*m[6]  + m[12]*m[2]*m[5],
     m[0]*m[5]*m[10]  - m[0]*m[6]*m[9]   - m[4]*m[1]*m[10] + m[4]*m[2]*m[9]  + m[8]*m[1]*m[6]   - m[8]*m[2]*m[5]
  ]);
  det = m[0]*inv[0] + m[1]*inv[4] + m[2]*inv[8] + m[3]*inv[12];
  if(!det) return m;
  det = 1 / det;
  for(var i = 0; i < 16; i++) {
    inv[i] *= det;
  }
  return inv;
};

// Get the inverse transpose of a mat4
inverseTranspose = m => transpose(inverse(m));</code></pre>
<br>
<li>We also pass a "mvp" (<b>model view projection</b>) matrix to the vertex shader, which is the multiplication of the camera matrix and the model matrix.
<br>These two matrices are multiplied in JS instead of the vertex buffer, for the same reason as before: avoid the effort of recomputing it for each vertex, at each frame.

</ul>
<p>Here's a cube rotating on itself with a fixed camera and a fixed point light:
<br>
<br>

<iframe id=i13 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=13"></iframe>

<p>You may remark that in certain cases (simple rotation or scaling), the inverse transpose matrix will be equal to the model matrix.
<br>But for translations or any combination of transformations, it will actually have a different value.
<br>As I said earlier, this value is useful in order to update the face normals with a simple multiplication, instead of recomputing them from scratch (more info <a href="https://stackoverflow.com/questions/13654401/why-transforming-normals-with-the-transpose-of-the-inverse-of-the-modelview-matr">here</a>).

<br><br><hr><br>

<h4>Drawing many cubes</h4>

<ul>
<li>To draw many cubes at once, it's of course possible to declare the vertices coordinates, colors and normals of each cube separately, but that would be very verbose.
<li>Instead, we can consider the cube we already declared as a reusable model.
<li>For each cube we want to draw, we simply need to transform it (by giving it a new model matrix, mvp matrix and inverse transpose matrix), and render it.
</ul>

<p>Here's a demo with 3 red cuboids (deformed cubes)
<br><br>
<iframe id=i14 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=14"></iframe>

<p>To avoid repetitions, I added a drawShape() function in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/shapes.js">shapes.js</a>, with optional scaling along X/Y/Z. Its role is to (re)render the current model as many times as necessary.

<pre><code class="lang-js">// Draw the current shape
drawShape = (gl, program, cameraMatrix, modelMatrix, n, sx = 1, sy = 1, sz = 1) => {
  
  // Set the model matrix (add the custom scale if any)
  var model = gl.getUniformLocation(program, 'model');
  modelMatrix = transform(modelMatrix, {sx, sy, sz});
  gl.uniformMatrix4fv(model, false, modelMatrix);

  // Set the cube's mvp matrix (camera x model)
  var mvpMatrix = multMat4Mat4(cameraMatrix, modelMatrix);
  var mvp = gl.getUniformLocation(program, 'mvp');
  gl.uniformMatrix4fv(mvp, false, mvpMatrix);

  // Set the inverse transpose of the model matrix
  var inverseTransposeMatrix = transpose(inverse(modelMatrix));
  var inverseTranspose = gl.getUniformLocation(program, 'inverseTranspose');
  gl.uniformMatrix4fv(inverseTranspose, false, inverseTransposeMatrix);

  // Render
  gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_SHORT, 0);
};</code></pre>

<br><br><hr><br>


<h4>Hierarchical objects</h4>

<ul>
<li>A <b>hierarchical object</b> is a model made of several basic objects (called <b>segments</b>), for example a robotic arm.
<li><b>Joints</b> are where the segments are linked and rotate relatively to each other, like an elbow or a wrist.
<li>To keep the segments linked to each other, the transformation matrix is inherited from segment to segment (ex: a hand will add its own transformation matrix to the arm's one). 
</ul>
<p>The following demo shows an robotic arm made of three cuboids (click the buttons below to make it move).
<br><br>

<iframe id=i15 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=15"></iframe>
<ul>
<li>You can see from line 146 that the vertical "arm" cuboid can rotate around X, and once it's rotated, we perform a "-2" translation along Y.
<br>As described in the "transformations" chapter, this allows to make the cuboid to rotate around a pivot point placed at its extremity (the "elbow") instead of its center.
<li>Then from line 152, the hand cuboid, which is attached at the end of the arm cuboid, inherits its model matrix, and extends it to add its own rotation and translation.
<br>(the rotation happens along the Y axis, and the translation places it at the end of the arm)
<li>This process can be repeated many times to make a multi-joint object, like an entire robot or a rope made of many segments!
<li>Also, if many segments are attached to the same parent (for example, the fingers of a hand), they must all reuse their parent's matrix (see demo <a href="https://xem.github.io/webgl-guide/book/ch09/MultiJointModel.html">here</a>).

<br><br><img src="images/webgl-guide/6cubes.gif" width=250> 

<br><br><hr><br>

<h4>Debugging</h4>

<p>Syntax errors present in your fragment shaders are logged during their compilation. The most frequent are:
<ul>
<li>Missing semicolon at the end of a line.
<li>Missing decimal part in a float number (1 is an int, 1.0 is a float).
<li>Trying to change the value of a const variable.
<li>Trying to set a value already set by an uniform (uniforms are read-only).
<li>Trying to set a variable upper limit in a for-loop.
<li>Mismatching int or float precision for a variable read by both shaders.
</ul>
<br>
<p>Other errors can be made in the JS program, and can sometimes fail silently. especially:
<ul>
<li>Using the bad count parameter for gl.drawArrays or gl.drawElements (must be the number of vertices).
<li>Using the wrong combination of types for an index buffer and gl.drawElements (Uint16Array only work with gl.UNSIGNED_SHORT).
<li>Not passing the right amount of data in attributes or uniforms (ex: 4 floats in a vec3).
</ul>
<br>
<p>Finally, if no syntax errors were made but nothing appears, check that:
<ul>
<li>The camera looks in the right direction (and with a decent fov angle, around 0.9 rad or 50 degrees).
<li>The light source is not too dark or trapped inside your 3D object.
<li>Your normals are not inverted (they must point "outside" to let the object reflect the light correctly).
<li>You didn't accidentally set any color's alpha to 0.0.
</ul>

<br><br><hr><br>

<h4>To be continued...</h4>

<p>At this point we've covered all the basis of 2D and 3D rendering.
<br>Unfortunately, most browsers don't accept more than 16 WebGL contexts in the same page, so all the advanced techniques will be in the upcoming PART 2! :)
</div>-->
</div>

</main>

</div>

<footer></footer>

<script src="../ui.js"></script>

<script>
header();
footer();
menu();
</script>

<script>
if(navigator.userAgent.includes("WebKit")){

scr = document.createElement("SCRIPT");
scr.src = 'https://polyfill.io/v3/polyfill.min.js?features=es6';
document.body.appendChild(scr);

scr = document.createElement("SCRIPT");
scr.id = 'MathJax-script';
scr.setAttribute('async', true); 
scr.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
document.body.appendChild(scr);
}

ifrs = document.querySelectorAll(".section iframe");
for(ifr of ifrs){
  ifr.insertAdjacentHTML('afterEnd', '<a class=newWindow title="Open in a new window" href="'+ifr.src+'"> </a>');
}
</script>

</body>
</html>
<!--
TODO:
- texture coordinates: dessin de gauche pas clair
- demo multiple points = un clear de trop
- a un moment je suggere d'utiliser gl.POINTS mais ça n'affiche rien car pointSize est pas défini
- un mot sur ourquoi create/link/use program
- mieux expliciter que les couleurs rgba ça va de 0 à 1
- parler de l'atténuation de lumière via pointLight
- faire un normalize dans le f buffer car v_normal est pas forcément normalisé
- "mesh"
-->