<!doctype html>
<meta charset=utf-8>
<meta name="viewport" content="width=device-width, user-scalable=no">
<html>
<head>
<link rel=stylesheet href="../style.css?v=4">
<title>Maxime Euzière</title>
<base target=_blank>
</head>
<body class=large>

<div class="wrapper">

<header></header>

<div id=menu></div>

<main>

<style>
table { border-spacing: 0; border-collapse: collapse; width: 100% }
th, td { padding: 5px; width: 200px }
th { background: #eee }
h4 { margin-bottom: 0; }
h1 { font-size: 30px }
h2 { font-size: 24px; line-height: 40px; }
h3 { font-size: 20px }
h4 { font-size: 18px }
h5 { font-size: 16px }
ul, ol { padding-left: 15px }
li { line-height: 25px }
pre { margin: 3px; font-size: 12px; }
pre.inline, pre.inline code { display: inline; padding: 4px 2px; background: #333; font-size: 11px;}
.math { margin: 15px 0 }
.section iframe { height: 40vw; min-height: 400px; }
.ch10 { border: 1px solid #000 }
.ch10 * { border: none }
.ch10 td { max-width: 430px; width: auto; vertical-align: top }
.ch10 td + td { max-width: 450px; }
.newWindow { float: right; margin-top: -60px; left: -10px; position: relative; z-index: 2; padding: 5px; border: 1px solid #555; border-radius: 5px; color: #000; font-size: 20px; width: 40px; height: 40px; background: url('images/new_window.svg') no-repeat center center #def; }
.section p {line-height: 32px; }
</style>

<div class=section id=webgl_guide>
<h2>WebGL guide</h2>
<h3>october 2019 - may 2020</h3>

<br><hr>

<h4>Introduction</h4>

<p>This guide is a complete, summarized WebGL tutorial, with tiny interactive demos in each chapter.
<br>It's mainly inspired by the book <a href="https://www.oreilly.com/library/view/webgl-programming-guide/9780133364903/ch01.html">WebGL Programming Guide</a> and the websites <a href="https://webgl2fundamentals.org/">Webgl2Fundamentals</a>, <a href="http://learnwebgl.brown37.net/index.html">LearnWebgl</a> &amp, <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">MDN</a>. 
<br>Starting nearly from scratch, you'll be able to create your own 3D interactive scenes without needing to use any <a href="https://fr.wikipedia.org/wiki/Liste_de_frameworks_WebGL">library or framework</a>: only vanilla JS &amp; WebGL.
<br>My goal was to gather all the information and tricks about WebGL I found scattered everywhere, and present them in a short and helpful way. I hope you'll enjoy it!
<br>The live playground (used for the demos) is available <a href="https://xem.github.io/webgl-guide/visualizer/#PGNhbnZhcyBpZD0iY2FudmFzIiB3aWR0aD00MDAgaGVpZ2h0PTQwMD48L2NhbnZhcz4KPHNjcmlwdD4KLy8gR2V0IHRoZSBXZWJHTCByZW5kZXJpbmcgY29udGV4dAovLyBUaGUgWCBhbmQgWSBjb29yZGluYXRlcyBhcmUgZGVmaW5lZCBiZXR3ZWVuIC0xLjAgYW5kIDEuMAp2YXIgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgid2ViZ2wiKTsKCi8vIFZlcnRleCBzaGFkZXI6Ci8vIERlc2NyaWJlcyB0aGUgYXR0cmlidXRlcyBvZiBwb2ludHMgaW4gc3BhY2VzIChwb3NpdGlvbiwgc2l6ZSwgLi4uKQovLyAtIGdsX1Bvc2l0aW9uOiB2ZWM0KHgsIHksIHosIDEuMCkKLy8gLSBnbF9Qb2ludFNpemUgZmxvYXQKdmFyIHZzaGFkZXIgPSBgCnZvaWQgbWFpbigpIHsKICBnbF9Qb3NpdGlvbiA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKTsKICBnbF9Qb2ludFNpemUgPSAxMC4wOwp9YDsKCi8vIEZyYWdtZW50IHNoYWRlcjoKLy8gRGVzY3JpYmVzIGhvdyBlYWNoIHBpeGVsIGlzIHJlbmRlcmVkIChjb2xvciwgbGlnaHRpbmcsIC4uLikKLy8gLSBnbF9mcmFnQ29sb3I6IHZlYzQociwgZywgYiwgYWxwaGEpCnZhciBmc2hhZGVyID0gYApwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKdm9pZCBtYWluKCkgewogIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAwLjAsIDAuMCwgMS4wKTsKfWA7CgovLyBNYWtlIGEgcHJvZ3JhbSBmcm9tIHRoZXNlIHNoYWRlcnMgYW5kIHVzZSBpdCAKdmFyIHZzID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpOwpnbC5zaGFkZXJTb3VyY2UodnMsIHZzaGFkZXIpOwpnbC5jb21waWxlU2hhZGVyKHZzKTsKCnZhciBmcyA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpOwpnbC5zaGFkZXJTb3VyY2UoZnMsIGZzaGFkZXIpOwpnbC5jb21waWxlU2hhZGVyKGZzKTsKCnZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpOwpnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdnMpOwpnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnMpOwpnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTsKZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTsKCi8vIENsZWFyIHRoZSBjYW52YXMncyBjb2xvciBidWZmZXIsIGluIGJsYWNrCmdsLmNsZWFyQ29sb3IoMC4wLCAwLjAsIDAuMCwgMS4wKTsKZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7CgovLyBEcmF3IHBvaW50cyBvbiB0aGUgY2FudmFzJ3MgY29sb3IgYnVmZmVyCmdsLmRyYXdBcnJheXMoCiAgZ2wuUE9JTlRTLCAvLyBtb2RlCiAgMCwgICAgICAgICAvLyBzdGFydGluZyBwb2ludAogIDEsICAgICAgICAgLy8gbnVtYmVyIG9mIHBvaW50cyB0byBkcmF3Cik7Cjwvc2NyaXB0Pg==">here</a>, my 3D OBJ file parser/viewer is <a href="https://xem.github.io/webgl-guide/">here</a>, and all the source code is available <a href="https://github.com/xem/webgl-guide">on Github</a>.
<br>Helper files created while making this guide: <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/webgl.js">webgl.js</a>, <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/matrix.js">matrix.js</a> and <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/shapes.js">shapes.js</a>.
<br>If you're interested in code golfing, Shadertoy, WebGL raymarching and signed distance functions, check out <a href="webgl_quest.html">Webgl quest</a> and <a href="webgl_quest_2.html">Webgl quest 2.</a>
<br>Special thanks to <a href="https://twitter.com/iquilezles">Inigo Quilez</a>, <a href="https://twitter.com/kchplr">Kevin Chapelier</a>, <a href="https://twitter.com/FreyaHolmer/">Freya Holmér</a> and <a href="https://twitter.com/adriengueret">Adrien Guéret</a> for their knowledge, tips and proofreading!


<br><br><hr><br>
<h2>What is WebGL?</h2>

<h4>Presentation</h4>

<p>WebGL is a JavaScript API designed to compute and draw 2D and 3D graphics very fast in a Web browser, by using the processing power of the GPU.
<br>It's based on <b>OpenGL ES</b> and is programmed using <b>shaders</b> coded in <b>GLSL</b>, a language similar to C and C++.
<br>A scene rendered by WebGL is made of <b>vertices</b> (points in 3D space, with coordinates X, Y, Z), which can be drawn as points, lines or triangles (colored, shaded or textured).
<p>Two versions of the API exist: <b>WebGL 1.0</b>, supported by 97% of browsers, and its evolution <b>WebGL 2.0</b>, supported by 74% of browsers as of may 2020 (<a href="https://caniuse.com/#search=webgl">source</a>).
<br>This guide will focus on WebGL 1.0, but all the features added in WebGL 2.0 will be explained at the end if you want to take the plunge.
<br>
<p>The workflow of a WebGL program is pretty complex, and can be summarized like this:
<ul>
<li>The JavaScript code initializes the WebGL program and pilots it to draw a 2D or 3D scene on the <b>webgl context</b> of a <b>HTML5 canvas</b>.
<li>A first GLSL script called <b>vertex shader</b> is executed for every vertex of the scene. It computes an abstract, mathematical model of the scene and hands it to...
<li>A second GLSL script called <b>fragment shader</b>, executed for every visible fragment (pixel) of the canvas. It computes each fragment's color, in a process called <b>rasterization</b>.
<li>The fragments constitute a bitmap image stored in a <b>color buffer</b>, which is finally displayed on the canvas.
<br><br><img src="images/webgl-guide/workflow.png" width=800>
</ul>
<br>

<h4>The GLSL language</h4>

<p>The shaders source code can be placed in a string or loaded from a separate file. Their syntax can be summarized like this:

<ul>
<li>An <b>int</b> is a whole number: <b>0</b>, <b>1</b>, <b>2</b>, <b>-10</b>,...
<li>A <b>float</b> is a number written with at least one decimal: <b>0.0</b>, <b>0.1</b>, <b>1.0</b>, <b>-10.5</b>,...
<li>A <b>bool</b> is a boolean number. Its possible values are <b>true</b> and <b>false</b>.
<li>A <b>vec4</b> is an array of 4 floats representing vertex coordinates or a 3D vector (x, y, z, w), or a color (r, g, b, alpha). The types vec2 and vec3 exist too.
<li>A <b>mat4</b> is a matrix (a grid) of 4 x 4 floats, useful for transforming coordinates and vectors in 3D. The types mat2 (2x2) and mat3 (3x3) exist too.
<li>A <b>sampler2D</b> is a reference to a texture image; a <b>samplerCube</b> is a reference to a "3D texture" (a set of 6 textures mapped on a cube).
<li>A <b>variable</b> is declared with its type, for example: <pre class=inline><code class="lang-js">int i = -1</code></pre>, <pre class=inline><code class="lang-js">float f = 2.0</code></pre> or <pre class=inline><code class="lang-js">vec4 v = vec4(1.0, 2.0, 3.0, 4.0)</code></pre>.
<li>A <b>constant</b> is a variable with a fixed value: <pre class=inline><code class="lang-js">const int c = 100;</code></pre>.
<li>The xyzw / rgba components of a vec4 can be extracted and recomposed, for example: <pre class=inline><code class="lang-js">float f = v.x</code></pre>, <pre class=inline><code class="lang-js">vec3 rgb = v.rgb</code></pre>.
<li><b>Math functions</b>: cos, sin, tan, pow, exp, log, log2, sqrt, abs, sign, floor, ceil, round, trunc, fract, mod, min, max, clamp, mix, step, length, distance, dot, cross, normalize...
<li>Many <b>operators</b> are available (= + - * / &amp;&amp; || == != > >= &lt; &lt;= ++ -- ^^ += -= *= /=) but only between variables of the same type or same length (ex: int * int, mat4 * float, mat4 * vec4).
<li><b>Type casting</b> allows to convert a type into another. Ex: <pre class=inline><code class="lang-js">bool b = true; int i = int(b); /* i = 1 */ float f = float(i); /* f = 1.0 */</code></pre>.
<li><b>Tests and loops</b> are also available (if, else, switch, for, while), but loops must have a constant limit. (you can't do <pre class=inline><code class="lang-js">for(i=0; i&lt;j; i++){...}</code></pre> if j is variable).
<li>The <b>entry point</b> of each shader is a <pre class=inline><code class="lang-js">void main(){...}</code></pre> function.
<li>Custom functions can also be created and called by main(), but recursion isn't allowed.
<li>The <b>precision</b> of ints, floats and Sampler2Ds (lowp / mediump / highp) can be set in each shader with a directive, like <pre class=inline><code class="lang-js">precision highp int;</code></pre> or <pre class=inline><code class="lang-js">precision mediump float;</code></pre>
<br>These directives must be at the beginning of the shader's code, however only the float precision is mandatory in the fragment buffer, all the others have values by default.
<li>The vertex shader must set a global variable <b>gl_Position</b> containing the coordinates of the current vertex. <b>gl_PointSize</b> is also mandatory when rendering individual points.
<li>The fragment shader must set a global variable <b>gl_FragColor</b> containing the color of the current fragment.
<br>It can also read 3 global variables: <b>gl_FragCoord</b> (window coordinates),  <b>gl_PointCoord</b> (coordinates inside a point) and <b>gl_FrontFacing</b> (current triangle orientation).
</ul>

<br>
<h4>Communication between JavaScript and WebGL</h4>
<p>Four main mechanisms exist to send data between the different scripts:
<ul>
<li><b>Attributes</b> are global variable passed by JS to the vertex shader. Their value can change for each vertex (ex: vertex coordinates).
<li><b>Uniforms</b> are global variables passed by JS to both vertex and fragment shaders (ex: a color). Their value stays constant for an entire frame.
<li><b>Varyings</b> are not accessible by JavaScript. They can only be set by the vertex shader and read by the fragment shader.
<li><b>buffer objects</b> are big arrays of floats passed by JS to the vertex shader in chunks of 1 to 4 items.
<br>For example, if a long list of vertex coordinates (X,Y,Z, X,Y,Z, ...) is sent to the vertex buffer 3 by 3, the shader will receive each chunk in the form of an <b>attribute vec3</b>.
<li>Each attribute, uniform and varying must be declared before main() in the shaders that uses them.
<li>JS can also send commands to the WebGL program to clear the screen, render the scene, etc... and this can be done many times per second to create an animation.
</ul>

<br><img src="images/webgl-guide/schema2.png" width=750>

<br><br>
<p>Don't worry, all these features will be explained and illustrated in the next chapters.

<br><br><hr><br>
<center><h2>2D graphics</h2></center>
<br><hr><br>


<h4>Hello, point</h4>

<ul>

</ul>

<p>Here's the simplest possible WebGL program, drawing a red, square point in the middle of the canvas.

<p>It's a live demo, feel free to play with the code and change some values!


<h5>Demo</h5>
<iframe id=i1 loading=lazy src="../../webgl-guide/visualizer/?demo=1"></iframe>

<h5>What happens here?</h5>
<ul>
<li>Two JavaScript objects are essential in a WebGL app: the canvas context <b>gl</b>, returned by <pre class=inline><code class="lang-js">canvas.getContext('webgl')</code></pre>, and <b>program</b> returned by <pre class=inline><code class="lang-js">gl.createProgram()</code></pre> (lines 4 &amp; 37).
<li>JavaScript also uses the functions <b>createShader</b>, <b>shaderSource</b>, <b>compileShader</b>, <b>attachShader</b>, <b>linkProgram</b> and <b>useProgram</b> to set up and run the app (lines 27-41),
<br>and the functions <b>clearColor</b>, <b>clear</b> and <b>drawArrays</b> to set the default background color, clear the canvas and draw a point on it (lines 48-59).
<li>The vertex shader (lines 7-15) sets the vec4 <b>gl_Position</b> (x, y, z, 1.0), and <b>gl_PointSize</b> (in pixels).<br>It is executed once, as there's only one vertex.
<br>Since we're drawing in 2D, the point's Z coordinate is 0.0, while X and Y are in the range [-1 : 1]: within the bounds of the canvas.
<br>The 4th vertex coordinate is fixed to 1.0, this will be useful to compute transformations in the next chapters.
<li>The fragment shader (lines 18-24) sets the vec4 <b>gl_Fragolor</b> (r, g, b, alpha), in which the four components are in the range [0 : 1].<br>It is executed 100 times (once for each pixel inside the point).
<br>It starts with a mandatory directive, used to define the precision of its floating numbers: <pre class=inline><code class="lang-js">precision mediump float;</code></pre> (lowp and highp are also available, but less useful). 
<li>If an error occurs during the compilation, it's caught by <b>getShaderInfoLog</b> or <b>getProgramInfoLog</b> (lines 44-46) and logged in the browser's JS console.
</ul>

<h5>Tips & tricks</h5>
<ul>
<li>On some devices, the biggest supported point size is 62px (<a href="http://webglstats.com/webgl/parameter/ALIASED_POINT_SIZE_RANGE">source</a>).
<li>On some devices, the points may disappear entirely if their center is outside of the canvas (<a href="https://webglfundamentals.org/webgl/lessons/webgl-drawing-without-data.html#pointsissues">source</a>).
<li>If you don't like placing your shaders' source code in a JS string, you can also use:
<br>- script blocks (<pre class=inline><code class="lang-html">&lt;script type="x-shader/x-vertex" id="vshader">...&lt;/script></code></pre> / <pre class=inline><code class="lang-html">&lt;script type="x-shader/x-fragment" id="fshader">...&lt;/script></code></pre>
(and retrieve it with <pre class=inline><code class="lang-js">id.innerText</code></pre>).
<br>- external files, like <b>fshader.glsl</b> and <b>vshader.glsl</b>
(and retrieve it as text with XHR, fetch, require, or any method you prefer).
<br>
<li>The program creation (lines 26 to 46) is always the same and pretty verbose, so we can put it in a <b>compile()</b> function and reuse it in the next chapters (see <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/webgl.js">webgl.js</a>):
</ul>
<pre style="font-size:11px"><code class="lang-js">// Compile a WebGL program from a vertex shader and a fragment shader
compile = (gl, vshader, fshader) => {
  
  // Compile vertex shader
  var vs = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vs, vshader);
  gl.compileShader(vs);
  
  // Compile fragment shader
  var fs = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fs, fshader);
  gl.compileShader(fs);
  
  // Create and launch the WebGL program
  var program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  gl.useProgram(program);
  
  // Log errors (optional)
  console.log('vertex shader:', gl.getShaderInfoLog(vs) || 'OK');
  console.log('fragment shader:', gl.getShaderInfoLog(fs) || 'OK');
  console.log('program:', gl.getProgramInfoLog(program) || 'OK');
  
  return program;
}</code>
</pre>

<br><br><hr><br>

<h4>Custom values: attributes and uniforms</h4>

<p>Of course, WebGL wouldn't be interesting if it could just draw one hard-coded point.
<br>To make it less rigid, we can give it custom values. This can be done with <b>attributes</b> (variable, readable by the vertex buffer) and <b>uniforms</b> (constant, readable by both buffers).
<br>Here are the different types of attributes and uniforms that can be set by JS:
<br>

<table border style="table-layout:fixed;max-width:900px">
<tr>
<th style="max-width:100px">Qualifier<th style="max-width:100px">Type<th style="max-width:200px">GLSL<th style="min-width:460px">How to set its value in JS

<tr>
<td rowspan=2>attribute
<td>float
<td><pre><code class="lang-js">attribute float f;</code></pre>
<td><pre><code class="lang-js">var f = gl.getAttribLocation(program, 'f');
gl.vertexAttrib1f(f, 1.0);</code></pre>

<tr>
<td>vec4
<td><pre><code class="lang-js">attribute vec4 v;</code></pre>
<td><pre><code class="lang-js">var f = gl.getAttribLocation(program, 'f');
gl.vertexAttrib4f(f, 1.0, 2.0, 3.0, 4.0); // list
gl.vertexAttrib4fv(f, [1.0, 2.0, 3.0, 4.0]); // or array</code></pre>
<tr>
<td rowspan=4>uniform

<td>int
<td><pre><code class="lang-js">uniform int i;</code></pre>
<td><pre><code class="lang-js">var i = gl.getUniformLocation(program, 'f');
gl.uniform1i(i, 1);</code></pre>

<tr>
<td>float
<td><pre><code class="lang-js">uniform float f;</code></pre>
<td><pre><code class="lang-js">var f = gl.getUniformLocation(program, 'f'):
gl.uniform1f(f, 1.0);</code></pre>

<tr>
<td>vec4
<td><pre><code class="lang-js">uniform vec4 v;</code></pre>
<td><pre><code class="lang-js">var f = gl.getUniformLocation(program, 'f');
gl.uniform4f(f, 1.0, 2.0, 3.0, 4.0); // list
gl.uniform4fv(f, [1.0, 2.0, 3.0, 4.0]); // or array</code></pre>

<tr>
<td>mat4
<td><pre><code class="lang-js">uniform mat4 m;</code></pre>
<td><pre><code class="lang-js">var m = gl.getUniformLocation(program, 'm');
gl.uniformMatrix4fv(
  m,
  false, // transpose (always false)
  new Float32Array([
    1.0, 2.0, 3.0, 4.0,
    5.0, 6.0, 7.0, 8.0,
    9.0, 10.0, 11.0, 12.0,
    13.0, 14.0, 15.0, 16.0
  ])
);</code></pre>

</table>

<br>Notes:
<br>- The types vec2 and vec3 can be declared similarly to vec4, and the types mat2 and mat3 similarly to mat4.
<br>- Boolean uniforms should work according to the language's specs, but don't work everywhere. If you need one, consider replacing it with an int or a float.


<h5>Demo</h5>
<iframe id=i2 loading=lazy src="../../webgl-guide/visualizer/?demo=2"></iframe>

<h5>What happens here?</h5>

<ul>
<li>Position is declared with <pre class=inline><code class="lang-js">attribute vec4 position;</code></pre>, targeted with <pre class=inline><code class="lang-js">position = gl.getAttribLocation(program, 'position')</code></pre> and set with <pre class=inline><code class="lang-js">gl.vertexAttrib4f(position, 0, 0, 0, 1)</code></pre>.
<li>Point size is declared with <pre class=inline><code class="lang-js">attribute float size;</code></pre>, targeted with <pre class=inline><code class="lang-js">size = gl.getAttribLocation(program, 'size')</code></pre> and set with <pre class=inline><code class="lang-js">gl.vertexAttrib1f(size, 10)</code></pre>.
<li>Point color is declared with <pre class=inline><code class="lang-js">uniform float color;</code></pre>, targeted with <pre class=inline><code class="lang-js">color = gl.getUniformLocation(program, 'color')</code></pre> and set with <pre class=inline><code class="lang-js">gl.uniform1f(color, 1, 0, 0, 1)</code></pre>.
</ul>

<h5>Tips & tricks</h5>
<ul>
<li>The fourth value of a vec4 attribute is 1.0 by default, so it's frequent to encounter some code that only sets x, y and z with <pre class=inline><code class="lang-js">gl.vertexAttrib3f(position, 0, 0, 0)</code></pre>.
<li>You can draw as many points as you want by setting new attributes / uniforms and calling <b>drawArrays</b> again.
<br>The same shaders will be executed each time but with different inputs.
<br>For example, you can add these lines to add 2 other points:
</ul>
<pre><img src="images/webgl-guide/rgb.jpg" style=float:right><code class="lang-js">gl.vertexAttrib3f(position, 0.25, 0, 0);
gl.uniform4f(color, 0, 1, 0, 1); // green
gl.drawArrays(gl.POINTS, 0, 1);

gl.vertexAttrib3f(position, 0.5, 0, 0);
gl.uniform4f(color, 0, 0, 1, 1); // blue
gl.drawArrays(gl.POINTS, 0, 1);</code></pre>
<ul><li>Inside the fragment shader, you have access to a <b>gl_PointCoord</b> vec2 telling where the fragment is placed in the point (x and y coordinates are between -1 and 1).
<br>Moreover, you can prevent a fragment from being rendered using the <b>discard;</b> statement.
<br>As a result, you can make a rounded point by discarding every fragment further than a radius of 0.5:
</ul>
<pre><img src="images/webgl-guide/rounded.png" width=60 style=float:right><code class="lang-js">float d = distance(gl_PointCoord, vec2(0.5, 0.5));
if(d &lt; .5) { gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); }
else { discard; }</code></pre>

<br><br><hr><br>
<h4>Drawing many points, a matter of continuity</h4>

<p>By default, WebGL has no problem calling gl.drawArrays many times in a row, but only if these calls happen in the same timeframe.
<br>Here's a program that tries to draw a new random point every 500ms:

<h5>Demo</h5>

<iframe id=i3 loading=lazy src="../../webgl-guide/visualizer/?demo=3"></iframe>

<h5>What happens here?</h5>
<p>As you can see, the canvas is not cleared (in black), but completely reset each time drawArrays() is called. This is the standard behavior when the draws happen at different moments.
<br>To solve this, there are two solutions:
<ol>
<li>Save the positions and colors of every new point in a JS array or object. Then every 500ms, clear the canvas and redraw them all;
<li>Force <pre class=inline><code class="lang-js">{ preserveDrawingBuffer: true }</code></pre> when creating the WebGL context, as you can see by removing the commented code on line 4.
</ol>

<p>In both cases, the result will look like this:

<br><br><img src="images/webgl-guide/points.gif" width=300 loading=lazy>

<br><br><hr><br>

<h4>Drawing lines and triangles</h4>

<p>The next step consists in declaring many points at once, and telling WebGL how to display them: as points, as lines or as triangles.
<br>To do this, we'll use a <b>data buffer</b> (an array of binary numbers) to send vertex properties from JS to the fragment shader, via an attribute. The following types are supported:
</ul>
<br>
<table border style="table-layout:fixed">
<tr>
<th>Name
<th>Bounds
<th style="max-width:100px">Bytes
<th>JS container
<th>WebGL type

<tr>
<td>Unsigned byte
<td>0 ... 255
<td>1
<td>new Uint8Array([...])
<td>gl.UNSIGNED_BYTE

<tr>
<td>Signed short integer
<td>−32,768 ... 32,767
<td>2
<td>new Int16Array([...])
<td>gl.SHORT

<tr>
<td>Unsigned short integer
<td>0 ... 65,535
<td>2
<td>new Uint16Array([...])
<td>gl.UNSIGNED_SHORT

<tr>
<td>Signed integer
<td>-2,147,483,648 ... 2,147,483,647
<td>4
<td>new Int32Array([...])
<td>gl.INT

<tr>
<td>Unsigned integer
<td>0 ... 4,294,967,295
<td>4
<td>new Uint32Array([...])
<td>gl.UNSIGNED_INT

<tr>
<td>Floating point number
<td>-2<sup>128</sup> ... 2<sup>127</sup>
<td>4
<td>new Float32Array([...])
<td>gl.FLOAT
</table>
<br>
<p>Then, <b>gl.drawArrays</b> can render these vertices as points, lines and triangles in 7 different ways, by changing its first parameter:
<br>
<br>
<img src="images/webgl-guide/modes.png" width=800 style="border:2px solid #ddd">

<h5>Demo</h5>
<p>Here's the simplest way to draw a colored triangle:
<br>
<br>
<iframe id=i4 loading=lazy src="../../webgl-guide/visualizer/?demo=4"></iframe>

<h5>What happens here?</h5>
<ul>
<li>A data buffer is filled with 3 points coordinates and bound to a <b>position</b> attribute with <b>createBuffer</b>, <b>bindBuffer</b>, <b>bufferData</b>, <b>vertexAttribPointer</b> &amp; <b>enableVertexAttribArray</b> (lines 31-49).
<li>At the end, we tell <b>gl.drawArrays</b> to render these points as a triangle. As a result, every fragment inside the triangle will automatically reuse the "color" uniform variable (red).
<li>If you replace <b>gl.TRIANGLES</b> with <b>gl.LINE_LOOP</b>, only the lines between points 0-1, 1-2, and 2-0 will be rendered, with a <b>line width</b> of 1px (1 fragment).
<br>You can also try <b>gl.LINE_STRIP</b> to trace lines between points 0-1 and 1-2, and <b>gl.LINES</b> to draw a line between points 0 and 1, as it only works on consecutive pairs of points.
<br>Unfortunately, the line width can't be changed reliably in current WebGL implementations, so we'll have to stick with a 1px line width or "cheat" with triangles (more info <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/lineWidth">here</a> and <a href="https://mattdesl.svbtle.com/drawing-lines-is-hard">here</a>).
<li>Lines and triangles do not need <b>gl_PointSize</b>. If you replace <b>gl.TRIANGLES</b> with <b>gl.POINTS</b>, you'll have to set gl_PointSize again or they won't appear.
</ul>

<h5>Tips &amp; tricks</h5>

<ul>
<li>You can draw as many triangles as you want by adding vertex coordinates on line 33 and updating the vertex count on line 61.
<li>In all the following chapters' demos, you can replace <b>gl.TRIANGLES</b> with <b>gl.LINE_LOOP</b> to see the scene in <b>wireframe</b>.
<li>WebGL does <b>antialiasing</b> (pixel smoothing) by default. This can be disabled with <pre class=inline><code class="lang-js">canvas.getContext('webgl', {antialias: false});</code></pre>, to save resources, especially on retina screens.
<li>The buffer creation and binding is also quite verbose, so let's put it in the function <b>buffer()</b>, in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/webgl.js">webgl.js</a>:
</ul>
<pre style="font-size:11px"><code class="lang-js">// Bind a data buffer to an attribute, fill it with data and enable it
buffer = (gl, data, program, attribute, size, type) => {
  gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
  var a = gl.getAttribLocation(program, attribute);
  gl.vertexAttribPointer(a, size, type, false, 0, 0);
  gl.enableVertexAttribArray(a);
}</code>
</pre>

<br><hr><br>

<h4>Multi-attribute buffer and varying color</h4>

<p>Now, we want to give a different color to our three vertices, and draw a triangle with them.
<br>The vertex colors can be transmitted to the fragment buffer via a <b>varying</b> variable, to produce a gradient (this process is called <b>color interpolation</b>).
<br>The X/Y/Z and R/G/B values for each vertex can be stored in two data buffers, or in an <b>interleaved data buffer</b>, like here:
<h5>Demo</h5>

<iframe id=i6 loading=lazy src="../../webgl-guide/visualizer/?demo=5"></iframe>

<h5>What happens here?</h5>
<ul>
<li>For every chunk of 6 floats in the data buffer,
<br>- <pre class=inline><code class="lang-js">gl.vertexAttribPointer(position, 3, gl.FLOAT, false, FSIZE*6, 0);</code></pre> binds the first 3 values to the attribute <b>position</b> (line 47),
<br>- <pre class=inline><code class="lang-js">gl.vertexAttribPointer(color, 3, gl.FLOAT, false, FSIZE*6, FSIZE*3);</code></pre> binds the last 3 values to the attribute <b>color</b> (line 59).
<br>The last two parameters (stride and offset) are counted in bytes, and the size of a data buffer item can be retrieved using <b>BYTES_PER_ELEMENT</b> (line 39). 
<li>The varying <b>v_color</b> is declared in both shaders.
<br>- In the vertex shader, it receives the color of the current vertex.
<br>- In the fragment shader, its value is automatically interpolated from the three vertices around it:
</ul>


<img src="images/webgl-guide/interpolation.gif" width=350 style="border:2px solid #ddd">
<br>
<h5>Tips and tricks</h5>

<ul>
<li>It's a good practice to prefix every varying name with "v_".
<li>Color interpolation also works in <b>LINES</b>, <b>LINE_STRIP</b> and <b>LINE_LOOP</b> modes.
<li>Most WebGL tutorials online stop when they reach this famous "tricolor triangle" step. But there's a lot more to cover! ;)
<li>Contrary to POINTS mode (that has gl_PointCoords), in TRIANGLES mode there is no global variable indicating where the current fragment is situated inside the triangle.
<br>But you have access to <b>gl_FragCoords</b> telling where the fragment is positioned on the canvas.
</ul>

<br><br><hr><br>

<h4>Translate, rotate, scale</h4>

<p>If we want to move, rotate or scale a triangle, we need to know how to transform each of its vertices.
<ul>
<li><b>Translation</b> consists in moving all the vertices in a given direction (by increasing or decreasing their X/Y/Z coordinates).
<li><b>Rotation</b> consists in moving the vertices around a <b>pivot point</b>, with a given angle (a full turn clockwise is 360 degrees or 2 * Pi radians).
<li><b>Scaling</b> consists in making the triangle smaller or bigger by bringing the vertices closer or further from a pivot point.
</ul>
<p>These operations can be done component per component (compute the new value of X, then Y, then Z), but we generally use a much powerful tool: <b>matrix transformations</b>:
<br>Each transformation can be written as a mat4 (a matrix of 4x4 floats), and applied to a vertex's <b>homogeneous coordinates</b> (vec4(X, Y, Z, 1.0)) with a multiplication.

<p>
<table border style='max-width:700px'>
<tr>
<th style="min-width:300px">Transformation
<th style=min-width:250px>Transformation applied to each vertex coordinates
<th><div style="min-width: 260px">transformation via a matrix</div>

<tr>
<td>Identity (no change)
<td>x' = x
<br>y' = y
<br>z' = z
<td style=padding:10px>

<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr>
<td>Translation along X, Y and Z axis
<td>x' = x + Tx
<br>y' = y + Ty
<br>z' = z + Tz
<td style=padding:10px>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Tx</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Ty</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>Tz</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr>
<td>Rotation around the X with an angle φ
<br>(φ is in radians)
<td>x' = x
<br>y' = y cos φ - z sin φ
<br>z' = y sin φ + z cos φ
<td style=padding:10px>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>cos φ</mn></mtd>
            <mtd><mn>-sin φ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>sin φ</mn></mtd>
            <mtd><mn>cos φ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr style=padding:10px>
<td>Rotation around the Y with an angle θ
<td>x' = x cos θ + z sin θ
<br>y' = y
<br>z' = -x sin θ + z cos θ
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>cos θ</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>sin θ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>-sin θ</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>cos θ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr style=padding:10px>
<td>Rotation around the Z axis with an angle ψ
<td>x' = x cos ψ – y sin ψ
<br>y' = x sin ψ + y cos ψ
<br>z' = z
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>cos ψ</mn></mtd>
            <mtd><mn>-sin ψ</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>sin ψ</mn></mtd>
            <mtd><mn>cos ψ</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr style=padding:10px>
<td>Scaling along X, Y and Z axis
<td>x' = Sx * x
<br>y' = Sy * y
<br>z' = Sz * z
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>Sx</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Sy</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Sz</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

</table>

<h5>Demo</h5>

<iframe id=i5 loading=lazy src="../../webgl-guide/visualizer/?demo=6"></iframe>

<h5>What happens here?</h5>
<p>This demo performs 3 transformations on the same triangle: translate, then rotate, then scale.
<br>These transformations can be done in this order by multiplying their matrices from right to left, and multiplying the resulting <b>matrix product</b> with the vertex coordinates (see line 14).
<br>These 3 matrices are declared in JS and sent to the fragment shader using uniforms (see lines 41 to 72).
<br>WebGL only accepts uniform matrices that are <b>transposed</b> (matrices with the horizontal and vertical axis inverted), so we transpose them manually in the JS code.
<br>In the following chapters, the matrix product will be computed only once (in JS) and passed to the vertex shader, to avoid recomputing it for each vertex.

<h5>Tips and tricks</h5>

<ul>
<li>Matrices and vectors with the same size can be multiplied together natively in GLSL (ex: mat4 * vec4).
<li>In JS, it must be done term by term.
<li>Helper functions added in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/matrix.js">matrix.js</a>:
</ul>
<pre style="font-size:11px"><code class="lang-js">// Create an identity mat4
identity = () => {
  return new Float32Array([
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
  ]);
};

// Compute the multiplication of two mat4 (c = a x b)
multMat4Mat4 = (a, b) => {
  var i, e, a, b, ai0, ai1, ai2, ai3;
  var c = new Float32Array(16);
  for (i = 0; i &lt; 4; i++) {
    ai0 = a[i];
    ai1 = a[i+4];
    ai2 = a[i+8];
    ai3 = a[i+12];
    c[i]    = ai0 * b[0]  + ai1 * b[1]  + ai2 * b[2]  + ai3 * b[3];
    c[i+4]  = ai0 * b[4]  + ai1 * b[5]  + ai2 * b[6]  + ai3 * b[7];
    c[i+8]  = ai0 * b[8]  + ai1 * b[9]  + ai2 * b[10] + ai3 * b[11];
    c[i+12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
  }
  return c;
};

// Get the transposed of a mat4
transpose = m => {
  return new Float32Array([
    m[0], m[4], m[8],  m[12],
    m[1], m[5], m[9],  m[13],
    m[2], m[6], m[10], m[14],
    m[3], m[7], m[11], m[15]
  ]);
};

// Transform a mat4
// options: x/y/z (translate), rx/ry/rz (rotate), sx/sy/sz (scale)
transform = (mat, options) => {
  var out = new Float32Array(mat);
  var x = options.x || 0, y = options.y || 0, z = options.z || 0;
  var sx = options.sx || 1, sy = options.sy || 1, sz = options.sz || 1;
  var rx = options.rx, ry = options.ry, rz = options.rz;
  
  // translate
  if(x || y || z){
    out[12] += out[0] * x + out[4] * y + out[8]  * z;
    out[13] += out[1] * x + out[5] * y + out[9]  * z;
    out[14] += out[2] * x + out[6] * y + out[10] * z;
    out[15] += out[3] * x + out[7] * y + out[11] * z;
  }
  
  // Rotate
  if(rx){
    out.set(multMat4Mat4(out, new Float32Array([
      1, 0, 0, 0,
      0, Math.cos(rx), Math.sin(rx), 0,
      0, -Math.sin(rx), Math.cos(rx), 0,
      0, 0, 0, 1
    ])));
  }
  if(ry){
    out.set(multMat4Mat4(out, new Float32Array([
      Math.cos(ry), 0, -Math.sin(ry), 0,
      0, 1, 0, 0,
      Math.sin(ry), 0, Math.cos(ry), 0,
      0, 0, 0, 1
    ])));
  }
  if(rz){
    out.set(multMat4Mat4(out, new Float32Array([
      Math.cos(rz), Math.sin(rz), 0, 0,
      -Math.sin(rz), Math.cos(rz), 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1
    ])));
  }
  
  // Scale
  if(sx !== 1){
    out[0] *= sx, out[1] *= sx, out[2] *= sx, out[3] *= sx;
  }
  if(sy !== 1){
    out[4] *= sy, out[5] *= sy, out[6] *= sy, out[7] *= sy;
  }
  if(sz !== 1){
    out[8] *= sz, out[9] *= sz, out[10] *= sz, out[11] *= sz;
  }
  
  return out;
};</code>
</pre>

<h5>How to change the pivot point</h5>

<p>The rotation and scaling matrices, as described above, only allow to use the world's origin [0, 0, 0] as pivot point.
<br>Imagine a triangle that is not centered on the origin, that you need to rotate 90 degrees (Pi/2 radians) around its center, for example the point [0.5, 0.5, 0].
<br>The solution is to apply 3 transformation matrices to this triangle's vertices:
<ul>
<li>Translate them around the origin [0, 0, 0]
<li>Apply a 90 degrees rotation
<li>Translate them back to around the [0.5, 0.5, 0].
</ul>

<img src="images/webgl-guide/pivot.png" width=850>

<br><br><hr><br>

<h4>Texturing</h4>

<p>As we saw earlier, a fragment's color inside a triangle can be interpolated from the colors of each vertex around it.
<br>The same principle can be used with a texture image (it's called <b>sampling</b> in this case).
<br>A WebGL texture (whatever its size in pixels) has a local coordinates system (U,V) between 0 and 1, and any vertex can have <b>texture coordinates</b> in this system.
</ul>
<br><img src="images/webgl-guide/texture.png">

<h5>Demo</h5>

<p>Here's an example of texture applied to a <b>quad</b> (a square made of two triangles):
<br>
<br>
<iframe id=i7 loading=lazy src="../../webgl-guide/visualizer/?demo=7"></iframe>

<h5>What happens here?</h5>

<ul>
<li>An image is loaded and a WebGL <b>texture sampler</b> is created from it, using the functions <b>createTexture</b>, <b>pixelStorei</b>, <b>activeTexture</b>, <b>bindTexture</b>, <b>texParameteri</b> (lines 59 to 85).
<br>Most of these steps plus <b>clear</b> and <b>drawArrays</b> are executed after the image has finished loading (line 63).
<li>Special texture behaviors (wrap / mirror / clamp on edges, minimize / magnify filters, etc) can be configured with <b>texParameteri</b> (more info <a href="https://developer.mozilla.org/en/docs/Web/API/WebGLRenderingContext/texParameter">here</a>).
<br>In particular, <b>gl.TEXTURE_WRAP_S</b> and <b>gl.TEXTURE_WRAP_T</b> can be set to <b>gl.REPEAT</b> (default), <b>gl.CLAMP_TO_EDGE</b> or <b>gl.MIRRORED_REPEAT</b>.
<br>This tells WebGL what to do if a texture coordinates is not between 0 and 1:
<br><img src="images/webgl-guide/wrap.png" width=550>

<ul>
<li>The Y axis flip (on line 66) puts the image's UV origin at the top left corner, and avoids having to work with an upsise-down image.
<li>The vertices positions are interleaved with the texture coordinates in the data buffer (lines 30 to 35).
<br>The vertex buffer receives the vertex positions and texture coordinates as <b>attributes</b> (lines 8,9), and sends the latter to the fragment shader using a <b>varying</b> (lines 10, 13, 20).
<li>The fragment buffer receives the coordinates as a varying, the texture image as a <b>uniform sampler2D</b> (line 19), and calls <pre class="language-js inline"><code>texture2D(sampler, v_TexCoord)</code></pre> to interpolate it (line 22).
</ul>
<br>

<h5>Tips and tricks</h5>


<ul>
<li>The U and V axis are sometimes called <b>S and T</b>, but it's exactly the same thing.
<li>The "pixels" inside a texture are called <b>texels</b>.
<li>Since UV coordinates are between 0 and 1, the vast majority of texture images are square.
<li>In this demo, we're using a single texture (TEXTURE0). The maximum amount of textures is not fixed, but to be safe, you should not exceed the guaranteed minimum of 8 (<a href="http://webglstats.com/webgl/parameter/MAX_TEXTURE_IMAGE_UNITS">source</a>).
<br>You can call <pre class="language-js inline"><code>gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)</code></pre> to know the limit on your device.
<li>The maximum texture size also varies with the device used, but to be safe, width and height shouldn't exceed 4096px (<a href="http://webglstats.com/webgl2/parameter/MAX_TEXTURE_SIZE">source</a>).
<br>You can call <pre class="language-js inline"><code>gl.getParameter(gl.MAX_TEXTURE_SIZE)</code></pre> to know the limit on your device.
<li>You can overwrite textures after a <b>draw call</b> (after calling drawArrays or drawElements) if they're not used anymore.
<li>If you need more than 8 textures without constantly switching between them, you can make a <b>texture atlas</b> (a mosaic of textures), and pick coordinates in the regions you want.
<br>Warning: <b>texture bleeding</b> can occur if you use texture coordinates at the fronteer between two texture, due to antialiasing. 
</ul>
<br>
<h5>Changing the texture's appearance</h5>
<p>Remember that the values you're manipulating in the fragment buffer are rgba colors, so you can do anything you want with them, like:
<br>- inverting the colors (r = 1-r; g = 1-g; b = 1-b).
<br>- greyscaling (compute the mean of r, g and b, and apply it to r, g and b).
<br>- exchanging color components (ex: gl_FragColor = color.brga).
<br>- playing with <b>gl_FragCoord</b> (the current canvas coordinates, in pixels, in the form of a vec2).

<br><br><img src="images/webgl-guide/textures0.png" width=600>

<br>
<br>

<h5>Combining multiple textures</h5>
<p>Two or more textures can be used on a triangle at the same time. For example, you can initialize two samplers, and add or multiply them in the fragment shader:
<pre class="language-js"><code>vec4 color0 = texture2D(sampler0, v_TexCoord);
vec4 color1 = texture2D(sampler1, v_TexCoord);
gl_FragColor = color0 + color1;

// or

gl_FragColor = color0 * color1;</code></pre>

<br><img src="images/webgl-guide/textures.png" width=600>

<p>Or blend them together, using the <b>mix()</b> function:

<pre class="language-js"><code>gl_FragColor = mix(color0, color1, 0.25); // color0 * 0.25 + color1 * 0.75;</code></pre>

<br><img src="images/webgl-guide/textures2.png" width=600>
<br>
<br>
<br><br><hr><br>
<center><h2>3D graphics</h2></center>
<br><hr><br>

<h4>The 3D camera</h4>
<br>You should know by now that computers don't do "3D" natively.
<br>You (or your 3D framework) will have to do all the computing to simulate the camera, the perspective, and how they affect each polygon, so the scene can seem to be in 3D.
<br>Fortunately, the API we use (WebGL) provides very helpful tools to help rendering complex scenes without too much effort.
<br>
<br><img src="images/webgl-guide/frustum.png">
<p>In 3D, the "camera", with its position, angle and perspective, is defined by nothing more than a 4x4 matrix.
<br>During render, every vertex in the scene is multiplied by this matrix to simulate these camera properties and appear at the right position.
<br>The camera's <b>frustum</b>, also called <b>clipping volume</b>, defines an area in which the triangles will be rendered.
<br>For a camera with perspective, it is defined by a field of view angle, an aspect ratio, a near clip plane and a far clip plane, and can be set with this matrix:
<br>
<br>
<div class=math>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1/(aspect*tan(fov/2))</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1/tan(fov/2)</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-(far+near)/(far-near)</mn></mtd>
            <mtd><mn>-(2*far*near)/(far-near)</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-1</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>
</div>
<br>
<br>
<p>Then, the camera can be translated, rotated and scaled (zoomed) similarly to the vertices, by using the matrices multiplications we saw earlier.
<br>A slightly more advanced LookAt() function is often used by developers to set the camera's position, angle and target all at once.

<p>Here are the perspective() and lookAt() functions added in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/matrix.js">matrix.js</a>:

<pre><code class="lang-js">// Create a perspective matrix
// options: fov, aspect, near, far
orthogonal = options => {
  var fov = options.fov || 1.5;
  var aspect = options.ratio || 1; // (`canvas.width / canvas.height` if the canvas is rectangle)
  var near = options.near || 0;
  var far = options.far || 100;
  var f = 1 / Math.tan(fov);
  var nf = 1 / (near - far);
  return new Float32Array([
    f / aspect, 0, 0, 0, 
    0, f, 0, 0, 
    0, 0, (far + near) * nf, -1,
    0, 0, (2 * near * far) * nf, 0
  ]);
}

// Place a camera at the position [cameraX, cameraY, cameraZ], make it look at the point [targetX, targetY, targetZ].
// Optional: a "up" vector can be defined to tilt the camera on one side (vertical by default).  
lookAt = (mat, cameraX, cameraY, cameraZ, targetX, targetY, targetZ, upX = 0, upY = 1, upZ = 0) => {
  var e, fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;
  fx = targetX - cameraX;
  fy = targetY - cameraY;
  fz = targetZ - cameraZ;
  rlf = 1 / Math.sqrt(fx*fx + fy*fy + fz*fz);
  fx *= rlf;
  fy *= rlf;
  fz *= rlf;
  sx = fy * upZ - fz * upY;
  sy = fz * upX - fx * upZ;
  sz = fx * upY - fy * upX;
  rls = 1 / Math.sqrt(sx*sx + sy*sy + sz*sz);
  sx *= rls;
  sy *= rls;
  sz *= rls;
  ux = sy * fz - sz * fy;
  uy = sz * fx - sx * fz;
  uz = sx * fy - sy * fx;
  var l = new Float32Array(
    sx, ux, -fx, 0,
    sy, uy, -fy, 0,
    sz, uz, -fz, 0,
    0,  0,  0,   1
  );
  l = transform(l, {x: -cameraX, y: -cameraY, z: -cameraZ});
  return multMat4Mat4(mat, l); 
}</code>
</pre>

<br>
<p>It's also possible to make a camera with no perspective, also called "orthogonal", "orthographic", "isometric" or "2.5D".
<br>In this case, the clipping volume is a box:
<br><img src="images/webgl-guide/orthogonal.png">
<br>
<p>Here are the matrix and the corresponding source code:
<br>
<br>
<div class=math>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>2/(right-left))</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-((right+left)/(right-left))</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>2/(top-bottom)</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-((top+bottom)/(top-bottom))</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-2/(far-near)</mn></mtd>
            <mtd><mn>-((tar+near)/(far-near))</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>
</div>
<br>
<br>

<pre><code class="lang-js">// Create an orthogonal matrix
// options: top, bottom, left, right, near, far
orthogonal = options => {
  var top = options.top;
  var bottom = options.bottom;
  var left = options.left;
  var right = options.right;
  var near = options.near || 0;
  var far = options.far || 100;
  var rw = 1 / (right - left);
  var rh = 1 / (top - bottom);
  var rd = 1 / (far - near);
  return new Float32Array([
    2 * rw, 0, 0, 0,
    0, 2 * rh, 0, 0,
    0, 0, -2 * rd, 0,
    -(right + left) * rw, -(top + bottom) * rh, -(far + near) * rd, 1
  ]);
}</code>
</pre>

<br><br><hr><br>

<h4>Reduce repetitions with indexed vertices</h4>

<p>Before starting to draw <b>meshes</b> (3D objects) that contain a lot of triangles, we need to learn an optimized way to write our data buffers.
<br>As we have seen before, data buffers (with the type gl.ARRAY_BUFFER) can hold vertex properties (position, color, texture coordinates...).
<br>These properties can be placed into multiple buffers or interleaved into a single one.
<p>In 3D, vertices are often shared between multiple triangles.
<br>Instead of repeating the same vertices many times in the same buffer, it's possible to write each vertex only once in a data buffer,
<br>and use a second buffer with the type <b>gl.ELEMENT_ARRAY_BUFFER</b> that declares all our triangles by using indices of the first object.
<p>Even if many data buffers exist in your program, only one index buffer can be used, and it will list indices from all the data buffers at the same time,
<br>so they all need to be stored in the same order (the N'th item of every buffer must belong to the same N'th vertex).
<p>Finally, to draw indexed vertices, you need you replace gl.drawArrays with <b>gl.drawElements(type, count, type, offset)</b>.
<p>The indices stored in the index buffer have integer values (N = 0, 1, 2...), and you can choose their size in bytes depending on the number of vertices you want to index:
<br>
<br>
<table border>
<tr>
<th>Number of vertices to index
<th>Index buffer type
<th>drawElements type
<tr>
<td>0 ... 256
<td>Uint8Array([...])
<td>gl.UNSIGNED_BYTE
<tr>
<td>0 ... 65,536
<td>Uint16Array([...])
<td>gl.UNSIGNED_SHORT
<tr>
<td>0 ... 4,294,967,296
<td>Uint32Array([...])
<td>gl.UNSIGNED_INT (*)
</table>

<p>(*) In WebGL 1.0, an extension must be enabled before using the type UNSIGNED_INT: <b>gl.getExtension('OES_element_index_uint');</b>. In WebGL2, it's enabled by default.

<br><br><hr><br>

<h3>Hello cube</h3>

<p>The easiest shape to render in 3D is a cube composed of 8 points and 12 triangles.

<h5>Demo</h5>

<iframe id=i8 loading=lazy src="../../webgl-guide/visualizer/?demo=8"></iframe>

<h5>What happens here?</h5>

<ul>
<li>Here we are, finally drawing in 3D! But to render it correctly, we had to enable WebGL's <b>depth sorting</b>.
<br>This mechanism ensures that only the fragments that are the closest to the camera are drawn, in order to avoid, for example, seeing the back face of the cube on top of the front face.
<br>To do that, we add <pre class="language-js inline"><code>gl.enable(gl.DEPTH_TEST);</code></pre> and update the clearing: <pre class="language-js inline"><code>gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);</code></pre> (see lines 95 and 106).
<li>Notice the index buffer (lines 60-67 + 78-80), and the use of <b>drawElements</b> (line 107) with matching types (Uint8Array / gl.UNSIGNED_BYTE).
<li>You may have noticed that the cube appears to rotate on itself, but it's actually the camera that rotates around it (see lines 97-100 + 104).
</ul>

<h5>Tips and tricks</h5>

<p>Remember that in every demo, you can see the triangles in wireframe by changing the first parameter of gl.grawElements to <b>gl.LINE_STRIP</b>, which makes the face diagonals visible:

<br>

<br><img src="images/webgl-guide/wire.png" width=250>




<br><br><hr><br>

<h3>How to color each face of the cube</h3>

<p>To color each face individually, each vertex can't have an unique color like we did before. Its color needs to vary depending on which face is being rendered.
<br>The solution is to declare all the possible combinations of vertices positions and colors in two data buffers, and use an index buffer to create the corresponding triangles.
<br>Its indeed a bit more verbose, but still the simplese way to achieve it.

<br>The same principle applies if you want to make a cube with different textures on each face (each combination of vertex position and texture coordinates must be declared separately).

<h5>Demo</h5>

<iframe id=i9 loading=lazy src="../../webgl-guide/visualizer/?demo=9"></iframe>

<h5>What happens here?</h5>

<p>The vertex positions and colors are split in two data buffers to improve readability. Each line declares the 4 vertices composing one (square) face of the cube (lines 39-55).
<br>Then, the index buffer makes two triangles from the vertices of each face, and recycles the vertices placed on the diagonal (lines 57-64).
<br>Thanks to this indexing, we only need to declare 24 vertices (4 per face) instead of 36 (3 per triangle x 12 triangles).
<br>
<h5>Tips and tricks</h5>

<p>Let's add the cube declaration in the cube() function of <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/shapes.js">shapes.js</a> to avoid repeating it in the next demos:

<pre><code class="lang-js">// Declare a cube (2x2x2)
// Returns [vertices (Float32Array), normals (Float32Array), indices (Uint16Array)] 
//
//    v6----- v5
//   /|      /|
//  v1------v0|
//  | |     | |
//  | |v7---|-|v4
//  |/      |/
//  v2------v3

cube = (r = 1, g = 1, b = 1) => {

  var vertices = new Float32Array([
     1.0, 1.0, 1.0,  -1.0, 1.0, 1.0,  -1.0,-1.0, 1.0,   1.0,-1.0, 1.0, // front
     1.0, 1.0, 1.0,   1.0,-1.0, 1.0,   1.0,-1.0,-1.0,   1.0, 1.0,-1.0, // right
     1.0, 1.0, 1.0,   1.0, 1.0,-1.0,  -1.0, 1.0,-1.0,  -1.0, 1.0, 1.0, // up
    -1.0, 1.0, 1.0,  -1.0, 1.0,-1.0,  -1.0,-1.0,-1.0,  -1.0,-1.0, 1.0, // left
    -1.0,-1.0,-1.0,   1.0,-1.0,-1.0,   1.0,-1.0, 1.0,  -1.0,-1.0, 1.0, // down
     1.0,-1.0,-1.0,  -1.0,-1.0,-1.0,  -1.0, 1.0,-1.0,   1.0, 1.0,-1.0  // back
  ]);

  var normals = new Float32Array([
    0.0, 0.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0, 1.0,  // front
    1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0,  // right
    0.0, 1.0, 0.0,   0.0, 1.0, 0.0,   0.0, 1.0, 0.0,   0.0, 1.0, 0.0,  // up
   -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  // left
    0.0,-1.0, 0.0,   00,-1.0, 0.0,   0.0,-1.0, 0.0,   0.0,-1.0, 0.0,  // down
    0.0, 0.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,-1.0   // back
  ]);

  var indices = new Uint16Array([
    0, 1, 2,   0, 2, 3,  // front
    4, 5, 6,   4, 6, 7,  // right
    8, 9, 10,  8, 10,11, // up
    12,13,14,  12,14,15, // left
    16,17,18,  16,18,19, // down
    20,21,22,  20,22,23  // back
  ]);
  
  return [vertices, normals, indices];
};</code></pre>

<p>In bonus, <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/shapes.js">shapes.js</a> also contains the models for a sphere and a pyramid.
<br>You can try them in all the following demos by replacing cube() with <b>sphere()</b> or <b>pyramid()</b>.

<br><br><img src="images/webgl-guide/othershapes.png" width=600>

<br><br>NB: all the shapes in shapes.js use Uint16Array's for indices, so if you use them, remember to use the type <b>gl.UNSIGNED_SHORT</b> in drawArrays().

<br><br><hr><br>



<h4>Lighting and shading</h4>
<p>The terms lighting and shading are often used without distinction but they actually represent two different things:
<ul>
<li><b>Lighting</b> is a physics notion, representing how the light affects an object in the real world or in a 3D scene.
<li><b>Shading</b> is specific to computer graphics, and indicate how the pixels are rendered on a screen according to lighting.
</ul>
<p>Sometimes, lighting is also referred to as <b>coloring</b>, and it makes sense when you think about it, as the apparent color of an object is produced by the lightwaves it absorbs and/or reflects.
<p>Every 3D scene needs a minimum of shading to avoid looking flat and confusing, even if it's a simple colored cube:
<br><br>
<img src="images/webgl-guide/shading.png" width=500>
<br>In the first case, all the pixels are the same color, which doesn't look natural.<br>In the second case, every face has a different color, but our brains interpret in as a shaded, red cube.

<p>To implement that, we first need to learn two new tools:

<h5>1) Normals and cross-products</h5>

<img src="images/webgl-guide/normal.png" width=300>
<br>

<p>Each triangle has a <b>normal</b>: it's a 3D vector perpendicular to its surface, and <b>normalized</b> (with a length equal to 1).
<br>A normal can be computed using a <b>cross-product</b> of two edge's vectors: AB × BC if the points A, B and C are in counterclockwise order.


<br><br><a href="https://twitter.com/FreyaHolmer/status/1203059678705602562?ref_src=twsrc%5Etfw"><img src="images/webgl-guide/cross.gif" width=300 style="border: 1px solid #ddd;"></a>
<br><br>
<div style="background:#fff;width:97px;height:32px;position:relative;z-index:2;margin-top:-220px;left:200px;margin-bottom:170px;"></div>

<p>A cross-product can be computed natively in GLSL: <b>cross(AB, BC)</b>.

<br>However, the normals of a 3D model are generally hard-coded or computed once, in JS when the page loads. Here's the source code:
</ul>
<pre><code class="lang-js">// Cross-product of three points a, b, c.
// Returns the coordinates of a normal vector perpendicular to the side where these points are counter-clockwise.
cross = (a0, a1, a2, b0, b1, b2, c0, c1, c2) => {
  var xAB = b0 - a0, yAB = b1 - a1, zAB = b2 - a2; // AB vector
  var xBC = c0 - b0, yBC = c1 - b1, zBC = c2 - b2; // BC vector
  return [yAB * zBC - zAB * yBC, zAB * xBC - xAB * zBC, xAB * yBC - yAB * xBC]; // cross product
}</code></pre>

<br>There's a mnemotechnic way to remember how a cross-product works, called <b>right-hand rule</b>: your right thumb is the cross-product of your 2nd and 3rd right finger.

<img src="images/webgl-guide/righthand.png" width=400>

<p>Some people prefer the opposite, left-hand rule, which can be enabled using <b>gl.frontFace(gl.CW)</b>, but it's not recommended.
<br>Also, the fragment shader can know at any moment if the triangle being rendered is facing the camera by testing the boolean variable <b>gl_FrontFacing</b>.
<br>This can be used to enable <b>backface culling</b> (discard fragments to avoid displaying back-facing triangles and save resources),
<br>or to the contrary, make both sides of a triangle react to light in a similar way (by inverting the normal vector with <pre><code class=lang-js>normal *= -1;</code></pre> if gl_FrontFacing is true, for example). More info <a href="https://makc3d.wordpress.com/2015/09/17/alternative-to-gl_frontfacing/">here</a>.

<br>
<h5>2) Dot product</h5>

<a href="https://twitter.com/FreyaHolmer/status/1200807790580768768?ref_src=twsrc%5Etfw"><img src="images/webgl-guide/dot.gif" width=250 style="border: 1px solid #ddd;"></a>

<p>The <b>dot product</b> is a function that compares two normalized vectors and tells how perpendicular they are.
<br>The dot product can have any value between 1 and -1, with three remarkable values:
<ul>
<li>1: the vectors are parallel.
<li>0: they're perpendicular.
<li>-1: they're at the opposite of each other.
</ul>

<p>In our case, it is interesting to check if a triangle is facing a light source, and render it accordingly.
<br>This operation is usually done inside the shader, using the native function <b>dot(lightDirection, normal)</b>.
<br>Though, if you need to do it in JS one day, here's the corresponding source code:
<br>

<pre><code class="lang-js">// Dot-product of two vec3: v and w
dot = (v0, v1, v2, w0, w1, w2) => {
  return v0 * w0 + v1 * w1 + v2 * w2;
}</code></pre>

<br>
<br>
<hr style="width:500px">
<br>

<p>There are many different ways to light a 3D scene, here are the four main ones to start with:

<h5>1) Diffuse light</h5>
<p>Diffuse light (also called <b>directional light</b>) is the equivalent of the sun's light on Earth: all the rays are parallel and have the same intensity everywhere in the scene.
<br>When it hits a surface, it is reflected in all directions, but the intensity of the reflexion decreases proportionally to the angle in which the light hits the surface:
<br><br><img src="images/webgl-guide/diffuse.png">
<br>To simulate it, we need to define a light source with a color (for example, white), and a direction (for example, vec3(0.5, 3.0, 4.0)).

<br>The color sent to the fragment shader is: the light's color (rgb) × the face color (rgb) × the dot product of the normal and the light. The color's alpha is fixed to 1.0.
<br>If the dot product is negative, we set it to "0" (there can't be a negative amount of light). This is done with <b>max(dot(lightDirection, normal), 0.0);</b> (see line 27).
<br>Note: it's a good practice to re-normalize the normals in the shaders to ensure they have the right length. This is done with <b>normalize()</b>.
<br>
<br>

<iframe id=i10 loading=lazy src="../../webgl-guide/visualizer/?demo=10"></iframe>

<br><h5>2) Ambient light</h5>

<p>With diffuse lighting alone, some faces are too dark, like the rightmost one in the previous demo. To fix that, we can add an ambient light reflexion.
<br>It's a light that is applied equally to all the triangles in the scene, regardless to their normal vector.
<br>To simulate it, we need to set a light color (not too bright, for example: vec3(0.2, 0.2, 0.2)), multiply it to the surface color, and add it to the diffuse light (see line 37):
<br>
<br>
<iframe id=i11 loading=lazy src="../../webgl-guide/visualizer/?demo=11"></iframe>

<br>
<h5>3) Point light</h5>

<ul>
<li>We can also have a <b>point light</b> representing a light bulb, with a specific position and color.
<li>It's similar to diffuse light, except that the light rays are not parallel, because the light source is not "infinitely" far away.
<li>With such a point light in the scene, the shading intensity will vary according to the distance from the light source, but also with the angle of the light rays.
<li>In the real world, the light <b>attenuation</b> is proportional to the distance squared, but in computer graphics, it's more often proportional to the distance (not squared).
<li>When a point light reflexion is computed per vertex, it looks a bit nicer but the triangles are still visible:
<br>
<br><img src="images/webgl-guide/per_vertex.png" width=500>
<br>
<br>
<li>The best solution consists in computing the right color for every fragment of the cube (i.e. every pixel) according to its distance from the light source,<br>and that's exactly what the fragment shader is here for:
<br><br><img src="images/webgl-guide/sphere.png" width=500>
</ul>
<br>
<p>The following demo shows how a point light can be computed per fragment.
<br>The vertex shader sends the vertices positions, colors and normals to the fragment shader using varyings, and the fragment shader computes everything.
<br>
<br>
<iframe id=i12 loading=lazy src="../../webgl-guide/visualizer/?demo=12"></iframe>

<h5>4) Specular lighting</h5>

<img src="images/webgl-guide/specular.png" width=800>
<br>
<br>
<p>When an object is shiny, it can reflect a point light like a mirror under a certain angle (more info <a href="https://webgl2fundamentals.org/webgl/lessons/webgl-3d-lighting-point.html">here</a>).
<br>To simulate it, we can compute the <b>half-vector</b> between the camera, the fragment and the light, and compare this with the surface normal using a dot product.
<br>This dot product is then powered to a number that represents the surface's "shininess", and added to the other (ambient / diffuse) lights in the fragment shader.
<br><br>
<img src="images/webgl-guide/phong.png" width=800>
<br>

<p>The combination of diffuse, ambiant and specular lighting is also called <b>Phong reflexion</b>, and looks like this:
<br>
<br>
<iframe id=i13 loading=lazy src="../../webgl-guide/visualizer/?demo=13"></iframe>
<!--<pre><code class=lang-js>var fshader = `
(...)

(...)
`;</code></pre>
-->


<br><br><hr style="width:500px"><br>

<h5>Smooth shading</h5>

<p>By default, the normal vector of a triangle is reused by all its vertices.
<br>This provokes a <b>facetted</b> (or polygonal) rendering, where neighbour triangles are separated by a visible "hard edge".
<br><b>Smooth shading</b> (or "Phong shading"), consists in computing a different normal for each vertex, equal to the mean of the normals of all the triangles around it.
<br>But no need to use divisions to obtain this mean value! Simply add all the normals together, and the mean will be computed when the shaders normalize the result (more info <a href="https://www.iquilezles.org/www/articles/normals/normals.htm">here</a>).
<br>Also, since the normal is now a varying vector interpolated for each fragment, the fragment shader needs to re-normalize it to stay accurate.
<br>Example: the same 3D model with smooth shading disabled / enabled (more info about loading 3D models in a future chapter!):
<br><br><img src="images/webgl-guide/w5.gif" width=650>

<br><br><hr style="width:500px"><br>

<h5>How about raytracing?</h5>

<p>You may have heard about <b>raytracing</b> as a way to produce protorealistic lights and reflections in 3D scenes, but this is actually a whole other domain of computer graphics.

<br><br><img src="images/webgl-guide/ray.png">
<br>
<br>Raytracing can be done with WebGL, but it's generally computed on a fullscreen shader than in a scene made of triangles, as you can see <a href="https://www.shadertoy.com/results?query=tag%3Draytracer"> on Shadertoy</a>.

<br>It also enables more advanced lighting modes, such as <b>Emissive lighting</b>, where an object is self-illuminated, glows and affects the the surrounding objects like a light source.
<br><br><img src="images/webgl-guide/emissive.png">

<br><br>But this will not be covered in this guide... maybe the next one?
<br>
<br><br><hr style="width:500px"><br>

<h5>How about Physically Based Rendering?</h5>

<p>Physically Based Rendering, or PBR, is a combination of techniques that allow to make materials react to any type of lighting based on real-world physics.
<br>It allows to reach a level of realism that is much higher than what is possible with approximations like diffuse, ambient and specular lighting, or even basic raytracing.
<br>Though, the maths behind it are extremely complex, and out of the scope of this guide, but you can read more about it in this free <a href="http://www.pbr-book.org/">reference book</a>.

<br><br><img src="images/webgl-guide/pbr.jpg" width=800>

<br><br><hr style="width:500px"><br>

<h5>How about baked lighting?</h5>

<p><b>Baked lighting</b> was an optimization used in early 3D games, where real-time computations were very CPU-intensive.
<br>The lights, shadings and shadows were precomputed or drawn by artists during the game development and displayed as textures to save resources.
<br>Famous example from Zelda Wind Waker on Gamecube: 
<br><br><img src="images/webgl-guide/baked.jpg" width=700>

<br><br><hr><br>

<h4>How to transform a 3D model</h4>

<p>So far, we've only transformed the camera matrix to make it revolve around the cube, which created an illusion of cube rotation.
<br>Now that we learned how to place a fixed light in the scene, if we want to rotate, translate or scale a cube without touching the rest of the scene, we need to do two things:
<ul>
<li>Introduce a <b>model matrix</b> (the transformation matrix of the cube)
<li>Recompute the vertex normals and the lighting of every fragment after each transform (after each update of the model matrix).
</ul>

<p>But in practice, the best approach is to keep the original normals unchanged, and pass them to the vertex shader, along with the vertex position and color.
<br>
Then, when the model matrix changes, the trick is compute its <b>inverse transpose</b> and pass it to the vertex shader in the form of an uniform mat4.
<br>
Finally, in the vertex shader, we multiply the original normal with this inverse transpose matrix to obtain its updated value: <b>vec3 newNormal = oldNormal * inverseTranspose</b>.

<h5>Demo</h5>

<p>Here's a cube rotating on itself with a fixed camera and a fixed point light:

<br><br>

<iframe id=i14 loading=lazy src="../../webgl-guide/visualizer/?demo=14"></iframe>

<h5>What happens here?</h5>

<ul>
<li>When the page loads, the cube, the light and the camera matrix are set as usual. (lines 68-105).
<li>Three new matrices are introduced: <b>model</b> (the model matrix), <b>inverseTranspose</b> and <b>mvp</b> (the model view projection matrix, equal to cameraMatrix * modelMatrix).
<li>In the loop executed 60 times per second, we update the cube Y angle (line 117), recompute the model matrix (lines 119-122), the mvp matrix (lines 124-126), the inverse transpose matrix (lines 128-130), and send them to WebGL as uniforms, before rendering the scene.
<br>Note: the </b>identity</b> matrix is used at each frame to recompute the model matrix from scratch (line 120). It avoids updating the same matrix with small increments every time.
<li>The fragment matrix applies the mvp matrix to the current vertex (line 26), and sends three varyings (position, normal and color) to the fragment shader.
<li>The fragment shader does nothing new. As far as it is concerned, its task is still to compute a shading from the variables at its disposal, regardless of how they were computed.
</ul>

<h5>Tips and tricks</h5>

<ul>
<li>The mvp matrix introduced above is precomputed in JavaScript to avoid recomputing it for every vertex, just like we did for transformation matrices.
<li>Here are the inverse() and inverseTranspose() functions added in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/matrix.js">matrix.js</a>:
</ul>

<pre><code class="lang-js">// Get the inverse of a mat4
inverse = m => {
  var inv = new Float32Array([
     m[5]*m[10]*m[15] - m[5]*m[11]*m[14] - m[9]*m[6]*m[15] + m[9]*m[7]*m[14] + m[13]*m[6]*m[11] - m[13]*m[7]*m[10],
    -m[1]*m[10]*m[15] + m[1]*m[11]*m[14] + m[9]*m[2]*m[15] - m[9]*m[3]*m[14] - m[13]*m[2]*m[11] + m[13]*m[3]*m[10],
     m[1]*m[6]*m[15]  - m[1]*m[7]*m[14]  - m[5]*m[2]*m[15] + m[5]*m[3]*m[14] + m[13]*m[2]*m[7]  - m[13]*m[3]*m[6],
    -m[1]*m[6]*m[11]  + m[1]*m[7]*m[10]  + m[5]*m[2]*m[11] - m[5]*m[3]*m[10] - m[9]*m[2]*m[7]   + m[9]*m[3]*m[6],
    -m[4]*m[10]*m[15] + m[4]*m[11]*m[14] + m[8]*m[6]*m[15] - m[8]*m[7]*m[14] - m[12]*m[6]*m[11] + m[12]*m[7]*m[10],
     m[0]*m[10]*m[15] - m[0]*m[11]*m[14] - m[8]*m[2]*m[15] + m[8]*m[3]*m[14] + m[12]*m[2]*m[11] - m[12]*m[3]*m[10],
    -m[0]*m[6]*m[15]  + m[0]*m[7]*m[14]  + m[4]*m[2]*m[15] - m[4]*m[3]*m[14] - m[12]*m[2]*m[7]  + m[12]*m[3]*m[6],
     m[0]*m[6]*m[11]  - m[0]*m[7]*m[10]  - m[4]*m[2]*m[11] + m[4]*m[3]*m[10] + m[8]*m[2]*m[7]   - m[8]*m[3]*m[6],
     m[4]*m[9]*m[15]  - m[4]*m[11]*m[13] - m[8]*m[5]*m[15] + m[8]*m[7]*m[13] + m[12]*m[5]*m[11] - m[12]*m[7]*m[9],
    -m[0]*m[9]*m[15]  + m[0]*m[11]*m[13] + m[8]*m[1]*m[15] - m[8]*m[3]*m[13] - m[12]*m[1]*m[11] + m[12]*m[3]*m[9],
     m[0]*m[5]*m[15]  - m[0]*m[7]*m[13]  - m[4]*m[1]*m[15] + m[4]*m[3]*m[13] + m[12]*m[1]*m[7]  - m[12]*m[3]*m[5],
    -m[0]*m[5]*m[11]  + m[0]*m[7]*m[9]   + m[4]*m[1]*m[11] - m[4]*m[3]*m[9]  - m[8]*m[1]*m[7]   + m[8]*m[3]*m[5],
    -m[4]*m[9]*m[14]  + m[4]*m[10]*m[13] + m[8]*m[5]*m[14] - m[8]*m[6]*m[13] - m[12]*m[5]*m[10] + m[12]*m[6]*m[9],
     m[0]*m[9]*m[14]  - m[0]*m[10]*m[13] - m[8]*m[1]*m[14] + m[8]*m[2]*m[13] + m[12]*m[1]*m[10] - m[12]*m[2]*m[9],
    -m[0]*m[5]*m[14]  + m[0]*m[6]*m[13]  + m[4]*m[1]*m[14] - m[4]*m[2]*m[13] - m[12]*m[1]*m[6]  + m[12]*m[2]*m[5],
     m[0]*m[5]*m[10]  - m[0]*m[6]*m[9]   - m[4]*m[1]*m[10] + m[4]*m[2]*m[9]  + m[8]*m[1]*m[6]   - m[8]*m[2]*m[5]
  ]);
  det = m[0]*inv[0] + m[1]*inv[4] + m[2]*inv[8] + m[3]*inv[12];
  if(!det) return m;
  det = 1 / det;
  for(var i = 0; i < 16; i++) {
    inv[i] *= det;
  }
  return inv;
};

// Get the inverse transpose of a mat4
inverseTranspose = m => transpose(inverse(m));</code></pre>
<br>As you can see, inversing a matrix is pretty complex operation, but it's very useful:
<br>It actually updates the model's coordinates system from its transformation matrix, which can be used to update its normals (like here), but not only! (we will reuse it soon)

<br><br><hr><br>

<h4>Drawing many cubes</h4>

<p>To draw many cubes at once, it's of course possible to declare the vertices coordinates, colors and normals of each cube separately, but that would be very verbose.
<br>Instead, we can consider the cube we already declared as a reusable model.
<br>For each cube we want to draw, we simply need to transform it (by giving it a new model matrix, mvp matrix and inverse transpose matrix), and render it.
<br>

<h5>Demo</h5>

<p>Here's a demo with 3 red <b>cuboids</b> (that's how we call deformed cubes)
<br><br>
<iframe id=i15 loading=lazy src="../../webgl-guide/visualizer/?demo=15"></iframe>

<h5>What happens here?</h5>

<p>A new model matrix is created and drawn three times using the same data buffers (lines 110, 132, 154).

<h5>Tips and tricks</h5>

<p>To avoid repetitions, I added a drawShape() function in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/shapes.js">shapes.js</a>, with optional scaling along X/Y/Z. Its role is to (re)render the current model as many times as necessary.

<pre><code class="lang-js">// Draw the current shape
drawShape = (gl, program, cameraMatrix, modelMatrix, n, sx = 1, sy = 1, sz = 1) => {
  
  // Set the model matrix (add the custom scale if any)
  var model = gl.getUniformLocation(program, 'model');
  modelMatrix = transform(modelMatrix, {sx, sy, sz});
  gl.uniformMatrix4fv(model, false, modelMatrix);

  // Set the cube's mvp matrix (camera x model)
  var mvpMatrix = multMat4Mat4(cameraMatrix, modelMatrix);
  var mvp = gl.getUniformLocation(program, 'mvp');
  gl.uniformMatrix4fv(mvp, false, mvpMatrix);

  // Set the inverse transpose of the model matrix
  var inverseTransposeMatrix = transpose(inverse(modelMatrix));
  var inverseTranspose = gl.getUniformLocation(program, 'inverseTranspose');
  gl.uniformMatrix4fv(inverseTranspose, false, inverseTransposeMatrix);

  // Render
  gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_SHORT, 0);
};</code></pre>

<br><br><hr><br>


<h4>Hierarchical objects</h4>

<p>A <b>hierarchical object</b> is a model made of several basic objects (called <b>segments</b>), for example a robotic arm.
<br><b>Joints</b> are where the segments are linked and rotate relatively to each other, like an elbow or a wrist.
<br>To keep the segments linked to each other, the transformation matrix is inherited from segment to segment (ex: a hand will apply its own transformation matrix to the arm's one). 
<p>The following demo shows an robotic arm made of three cuboids (click the buttons below to make it move).
<br>

<h5>Demo</h5>

<iframe id=i16 loading=lazy src="../../webgl-guide/visualizer/?demo=16"></iframe>

<h5>What happens here?</h5>

<ul>
<li>You can see on lines 146-150 that the vertical "arm" cuboid can rotate around its X axis, and once it's rotated, we perform a "-2" translation along Y.
<br>As described in the "transformations" chapter, this allows to make the cuboid rotate around a pivot point placed at its extremity (the "elbow", 2 units higher) instead of its center.
<li>Then, on lines 152-155, the hand cuboid, which is attached at the end of the arm cuboid, inherits its model matrix, and updates it to add its own rotation and translation.
<br>(the rotation happens along the Y axis, and the translation places it at the end of the arm).
</ul>

<h5>Tips and tricks</h5>
<ul>
<li>This process can be repeated many times to make a multi-joint object, like an entire robot or a rope made of many segments!
<li>If many segments are attached to the same parent (for example, the fingers of a hand), they must all reuse their parent's matrix (see multi-joint demo <a href="https://xem.github.io/webgl-guide/book/ch09/MultiJointModel.html">here</a>).
</ul>

<br><img src="images/webgl-guide/6cubes.gif" width=250> 


<br><br><hr><br>

<h4>Debugging</h4>

<p>Many kind of errors can be present in your WebGL shaders or occur on runtime. The most frequent I've encountered are:
<ul>
<li>Missing semicolon at the end of a line.
<li>Missing decimal part in a float number (1 is an int, 1.0 is a float).
<li>Trying to change the value of a const variable.
<li>Trying to set a value already set by an uniform or a varying (they are read-only).
<li>Trying to set a non-constant limit in a for-loop.
<li>Trying to use a function recursively.
<li>Trying to use === or !== operators.
<li>Mismatching int or float precision for a variable read by both shaders.
</ul>
<br>
<p>Other errors can be made in the JS program, and can sometimes fail silently. especially:
<ul>
<li>Using the bad count parameter for gl.drawArrays or gl.drawElements (must be the number of vertices).
<li>Using the wrong combination of types for an index buffer and gl.drawElements (Uint16Array only work with gl.UNSIGNED_SHORT).
<li>Not passing the right amount of data in attributes or uniforms (ex: 4 floats in a vec3).
</ul>
<br>
<p>Finally, if no syntax errors were made but nothing appears, check if:
<ul>
<li>The camera looks in the right direction (and with a decent fov angle, usually around 0.9 radians or 50 degrees).
<li>The light source is not too dark or trapped inside a 3D object.
<li>Your normals are not inverted (they must point "outside" to let the object reflect the light correctly).
<li>You didn't accidentally set any color's alpha to 0.0.
<li>You're not drawing points that are too big or have their center placed outside of the canvas.
</ul>


<br><br><hr><br>

<h4>WebGL 2.0</h4>
<br>
As I said in the introduction, WebGL 2.0 brings new features and changes a few things compared to WebGL 1.0.
<br>To enable it, you need to change the canvas context creation: <pre class=inline><code class="lang-js">canvas.getContext("webgl2");</code></pre> and put <b>#version 300 es</b> on the very first line of your shaders.
<br>Here are the most important changes:
<br><ul>
<li><b>attribute</b> must be renamed as <b>in</b> inside the shaders (ex: <b>in vec4 a_position;</b>).
<li><b>varyings</b> must be renamed as <b>out</b> in the vertex shader and <b>in</b> in the fragment buffer.
<li><b>gl_FragColor</b> doesn't exist anymore. Instead, the fragment shader needs to declare its own <b>out vec4 fragColor;</b> before main() and set its value inside main().
<li>The fragment shader can edit the depth buffer directly using the global <b>gl_FragDepth</b>.
<li>New <b>types</b>: uint, bvec2/3/4 (boolean vectors), ivec2/3/4 (integer vectors), uvec2/3/4 (uint vectors), mat2x3, mat2x4, mat3x4, mat4x3, mat4x2, mat3x2 and a bunch of new Samplers.
<li>New boolean <b>operators</b>: %, &lt;&lt;, >>, &amp;, ^, |, &lt;&lt;=, >>=, &=, ^=, |=.
<li>New <b>matrix functions</b>: inverse(), transpose().
<li>Loops bounds no not need to be constant anymore. 
<li>The functions <b>texture2D</b> and <b>textureCube</b> are now simply called <b>texture</b>.
<li>Mipmapping now works on textures even if their width and height are not a power of 2.
<br>(Mipmaps are smaller versions of a 2D texture, used when a textured object is moving away from the camera. They can be generated with <b>gl.generateMipmap(gl.TEXTURE_2D)</b>).
<br>The GLSL function <b>textureSize(sampler, lod)</b> gives you texture size for a given level of detail.
<br>And the function <b>texelFetch(sampler, ivec2(x,y), lod)</b> gives you the value of a given texel.
<li>Most <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getExtension">extensions</a> don't need to be loaded anymore, as they are enabled by default.
<li>In particular, <b>Vertex array objects</b> are now available natively and allow to cache the attributes binding, leading to a performance boost in programs doing many draw calls per frame:
<pre><code class="lang-js">// Just after WebGL setup
var vao = gl.createVertexArray();
gl.bindVertexArray(vao);

// (bind attributes as usual: floats, vec4, buffers...)

// Then, before each draw call:
gl.bindVertexArray(vao);</code></pre>
<li>Similarly, <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext#Uniform_buffer_objects">Uniform Buffer Objects</a> can be used to cache uniforms, but it's harder to setup and generally less useful as uniforms tend to be rarely updated.
</ul>

<br><br><hr><br>

<h4>To be continued...</h4>

<p>At this point we've covered all the basis of 2D and 3D rendering in WebGL 1.0 and 2.0!
<br>For the record, this single page contained more information than 430 pages of <a href="https://www.oreilly.com/library/view/webgl-programming-guide/9780133364903/ch01.html">the book</a> and 3/4 of the <a href="https://webgl2fundamentals.org/">site</a> that inspired it at the beginning. Did I invent tutorial golfing? :D
<br>I could have made it longer but unfortunately, most browsers can't display more than 16 WebGL canvas contexts in the same page...
<br>so all the advanced techniques will be in the upcoming part 2... and maybe a book one day?
</div>

</main>

</div>

<footer></footer>

<script src="../ui.js"></script>

<script>
header();
footer();
menu();
</script>

<script>
if(navigator.userAgent.includes("WebKit")){

scr = document.createElement("SCRIPT");
scr.src = 'https://polyfill.io/v3/polyfill.min.js?features=es6';
document.body.appendChild(scr);

scr = document.createElement("SCRIPT");
scr.id = 'MathJax-script';
scr.setAttribute('async', true); 
scr.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
document.body.appendChild(scr);
}

ifrs = document.querySelectorAll(".section iframe");
for(ifr of ifrs){
  ifr.insertAdjacentHTML('afterEnd', '<a class=newWindow title="Open in a new window" href="'+ifr.src+'"> </a>');
}
</script>

</body>
</html>