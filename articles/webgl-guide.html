<!doctype html>
<meta charset=utf-8>
<meta name="viewport" content="width=device-width, user-scalable=no">
<html>
<head>
<link rel=stylesheet href="../style.css?v=4">
<title>Maxime Euzière</title>
<base target=_blank>
</head>
<body class=large>

<div class="wrapper">

<header></header>

<div id=menu></div>

<main>

<style>
table { border-spacing: 0; border-collapse: collapse; width: 100% }
th, td { padding: 5px; width: 200px }
th { background: #eee }
h4 { margin-bottom: 0; }
h1 { font-size: 30px }
h2 { font-size: 24px }
h3 { font-size: 20px }
h4 { font-size: 18px }
h5 { font-size: 14px }
ul { padding-left: 15px }
pre { margin: 3px; font-size: 12px; }
.math { margin: 15px 0 }
.section iframe { height: 40vw; min-height: 400px; }
.ch10 { border: 1px solid #000 }
.ch10 * { border: none }
.ch10 td { max-width: 430px; width: auto; vertical-align: top }
.ch10 td + td { max-width: 450px; }

</style>

<div class=section id=webgl_guide>
<h2>WebGL guide</h2>
<h3>october 2019 - may 2020</h3>
  
<h4>Introduction</h4>

<p>This page is a complete, summarized WebGL tutorial, including tiny, embedded, editable demos in each chapter.
<p>It's mainly inspired by the book <a href="https://www.oreilly.com/library/view/webgl-programming-guide/9780133364903/ch01.html">WebGL Programming Guide</a> and the websites <a href="https://webgl2fundamentals.org/">Webgl2Fundamentals.org</a>, <a href="http://learnwebgl.brown37.net/index.html">LearnWebgl</a> &amp, <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">mdn.io</a>. 
<p>Starting nearly from scratch, you'll be able to create your own 3D interactive scenes without needing to use any <a href="https://fr.wikipedia.org/wiki/Liste_de_frameworks_WebGL">library or framework</a>: only vanilla JS &amp; WebGL.
<p>My goal was to gather all the information and tricks about WebGL I found scattered everywhere, and present them in a short and helpful way. I hope you'll enjoy it!
<p>The live playground (used for the demos) is available <a href="https://xem.github.io/webgl-guide/visualizer/#PGNhbnZhcyBpZD0iY2FudmFzIiB3aWR0aD00MDAgaGVpZ2h0PTQwMD48L2NhbnZhcz4KPHNjcmlwdD4KLy8gR2V0IHRoZSBXZWJHTCByZW5kZXJpbmcgY29udGV4dAovLyBUaGUgWCBhbmQgWSBjb29yZGluYXRlcyBhcmUgZGVmaW5lZCBiZXR3ZWVuIC0xLjAgYW5kIDEuMAp2YXIgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgid2ViZ2wiKTsKCi8vIFZlcnRleCBzaGFkZXI6Ci8vIERlc2NyaWJlcyB0aGUgYXR0cmlidXRlcyBvZiBwb2ludHMgaW4gc3BhY2VzIChwb3NpdGlvbiwgc2l6ZSwgLi4uKQovLyAtIGdsX1Bvc2l0aW9uOiB2ZWM0KHgsIHksIHosIDEuMCkKLy8gLSBnbF9Qb2ludFNpemUgZmxvYXQKdmFyIHZzaGFkZXIgPSBgCnZvaWQgbWFpbigpIHsKICBnbF9Qb3NpdGlvbiA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKTsKICBnbF9Qb2ludFNpemUgPSAxMC4wOwp9YDsKCi8vIEZyYWdtZW50IHNoYWRlcjoKLy8gRGVzY3JpYmVzIGhvdyBlYWNoIHBpeGVsIGlzIHJlbmRlcmVkIChjb2xvciwgbGlnaHRpbmcsIC4uLikKLy8gLSBnbF9mcmFnQ29sb3I6IHZlYzQociwgZywgYiwgYWxwaGEpCnZhciBmc2hhZGVyID0gYApwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKdm9pZCBtYWluKCkgewogIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAwLjAsIDAuMCwgMS4wKTsKfWA7CgovLyBNYWtlIGEgcHJvZ3JhbSBmcm9tIHRoZXNlIHNoYWRlcnMgYW5kIHVzZSBpdCAKdmFyIHZzID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpOwpnbC5zaGFkZXJTb3VyY2UodnMsIHZzaGFkZXIpOwpnbC5jb21waWxlU2hhZGVyKHZzKTsKCnZhciBmcyA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpOwpnbC5zaGFkZXJTb3VyY2UoZnMsIGZzaGFkZXIpOwpnbC5jb21waWxlU2hhZGVyKGZzKTsKCnZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpOwpnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdnMpOwpnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnMpOwpnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTsKZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTsKCi8vIENsZWFyIHRoZSBjYW52YXMncyBjb2xvciBidWZmZXIsIGluIGJsYWNrCmdsLmNsZWFyQ29sb3IoMC4wLCAwLjAsIDAuMCwgMS4wKTsKZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7CgovLyBEcmF3IHBvaW50cyBvbiB0aGUgY2FudmFzJ3MgY29sb3IgYnVmZmVyCmdsLmRyYXdBcnJheXMoCiAgZ2wuUE9JTlRTLCAvLyBtb2RlCiAgMCwgICAgICAgICAvLyBzdGFydGluZyBwb2ludAogIDEsICAgICAgICAgLy8gbnVtYmVyIG9mIHBvaW50cyB0byBkcmF3Cik7Cjwvc2NyaXB0Pg==">here</a>, my 3D OBJ file parser/viewer is <a href="https://xem.github.io/webgl-guide/">here</a>, and all the source code is available <a href="https://github.com/xem/webgl-guide">on Github</a>.
<p>Helper files created while making this guide: <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/webgl.js">webgl.js</a>, <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/matrix.js">matrix.js</a> and <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/shapes.js">shapes.js</a>.
<p>If you're interested in Shadertoy, WebGL raymarching and signed distance functions, check out <a href="webgl_quest.html">Webgl quest</a> and <a href="webgl_quest_2.html">Webgl quest 2.</a>
<p>Special thanks to <a href="https://twitter.com/iquilezles">Inigo Quilez</a> and <a href="https://twitter.com/kchplr">Kevin Chapelier</a> for their knowledge and tips!

<br><br><hr><br>
<h2>2D graphics</h2>
<h4>How to draw a point</h4>

<ul>
<li>A <b>vertex</b> is a point in 3D space (coordinates: X, Y, Z).
<li>A <b>fragment</b> is where the scene is rendered (the pixels on your screen).
<li>In a WebGL app, two scripts (vertex shader and fragment shader) are written in GLSL language and controlled by JS to render a scene on a canvas:
<li>The <b>vertex shader</b> is executed for every vertex of your scene, and must set two variables called <b>gl_Position</b> and <b>gl_PointSize</b>
<li>The <b>fragment shader</b> is executed for every fragment, and must set the variable <b>gl_FragColor</b> (the color of each pixel).
<li>The source code of both shaders is placed inside a <b>void main(){...}</b> function.
<li>The X and Y coordinates in a WebGL canvas context go from -1 to 1, whatever the size of the canvas.
<br><img src="images/webgl-guide/webgl.png">
<li>In the language GLSL, an <b>int</b> is a whole number (0, 1, 2, ...). A <b>float</b> is a number written with at least one decimal (ex: 0.0, 0.1, 1.0, ...).
<li>A <b>vec4</b> is an array of 4 floats representing either vertex coordinates (x, y, z, 1.0), a color (r, g, b, alpha), or anything you want. (vec2 and vec3 exist too, but are rarely used).
<li>A <b>mat4</b> is a matrix (a grid) of 4 x 4 floats. (mat2 and mat3 exist too, but are also rarely used).
</ul>

<p>Here's the simplest possible WebGL program, drawing a red point in the middle of the canvas. It's a live demo, feel free to play with the code!
<br>
<br>
<iframe id=i1 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=1"></iframe>

<p>The program compilation (lines 30 to 42) is always the same, so I've put it in a compile() function that will be used in the next chapters (see <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/webgl.js">webgl.js</a>):

<pre style="font-size:11px"><code class="lang-js">// Compile a WebGL program from a vertex shader and a fragment shader
compile = (gl, vshader, fshader) => {
  var vs = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vs, vshader);
  gl.compileShader(vs);
  var fs = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fs, fshader);
  gl.compileShader(fs);
  var program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  gl.useProgram(program);
  console.log('vertex shader:', gl.getShaderInfoLog(vs) || 'OK');
  console.log('fragment shader:', gl.getShaderInfoLog(fs) || 'OK');
  console.log('program:', gl.getProgramInfoLog(program) || 'OK');
  return program;
}</code>
</pre>

<p>Shaders can also contain <a href="https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)#Functions">custom C-like functions</a>, that can be called inside main().
<p>You may have noticed that the fragment shader starts with a directive that says <b>precision mediump float;</b>:
<br>this is due to the language's specs, which made it mandatory to specify how precise the floats are in this shader.
<br>The possible precisions are "lowp" (less precise but faster), "mediump" and "highp" (more precise but slower), "mediump" is largely enough to compute colors.
<br>The vertex shader can also start with this directive, but defaults to "highp", which is nice (vertex positions need to be very precise).

<br><br><hr><br>

<h4>Custom values: attributes and uniforms</h4>

<ul>
<li>Of course, WebGL wouldn't be interesting if it could just draw one hard-coded point.
<br>It becomes interesting when we give it custom values. This can be done through attributes, uniforms, and buffer objects (we'll see these ones later).
<li>An <b>attribute</b> is a global variable passed by JS to the vertex shader. Its value can change for each vertex (ex: coordinates, position).
<li>An <b>uniform</b> is a global variable passed by JS to both vertex and fragment shaders  (ex: a color). Its value stays constant for an entire draw call.
<li>All the attributes and uniforms received from the JS program must be declared before main() in each shader.
<!--li>For the record, some browsers (like Safari) only accept to draw points that are set by JS, and won't run the previous demo at all.-->
</ul>


<p>Here are the different types of attributes and uniforms that can be set by JS:
<br>

<table border style="table-layout:auto">
<tr>
<th>Qualifier<th style="min-width:100px">Type<th>GLSL<th style="min-width:460px">How to set its value in JS

<tr>
<td rowspan=2>attribute
<td>float
<td><pre><code class="lang-js">attribute float f;</code></pre>
<td><pre><code class="lang-js">var f = gl.getAttribLocation(program, 'f');
gl.vertexAttrib1f(f, 1.0);</code></pre>

<tr>
<td>vec4
<td><pre><code class="lang-js">attribute vec4 v;</code></pre>
<td><pre><code class="lang-js">var f = gl.getAttribLocation(program, 'f');
gl.vertexAttrib4f(f, 1.0, 2.0, 3.0, 4.0); // list
gl.vertexAttrib4fv(f, [1.0, 2.0, 3.0, 4.0]); // or array</code></pre>
<tr>
<td rowspan=4>uniform

<td>int
<td><pre><code class="lang-js">uniform int i;</code></pre>
<td><pre><code class="lang-js">var i = gl.getUniformLocation(program, 'f');
gl.uniform1i(i, 1);</code></pre>

<tr>
<td>float
<td><pre><code class="lang-js">uniform float f;</code></pre>
<td><pre><code class="lang-js">var f = gl.getUniformLocation(program, 'f'):
gl.uniform1f(f, 1.0);</code></pre>

<tr>
<td>vec4
<td><pre><code class="lang-js">uniform vec4 v;</code></pre>
<td><pre><code class="lang-js">var f = gl.getUniformLocation(program, 'f');
gl.uniform4f(f, 1.0, 2.0, 3.0, 4.0); // list
gl.uniform4fv(f, [1.0, 2.0, 3.0, 4.0]); // or array</code></pre>

<tr>
<td>mat4
<td><pre><code class="lang-js">uniform mat4 m;</code></pre>
<td><pre><code class="lang-js">var m = gl.getUniformLocation(program, 'm');
gl.uniformMatrix4fv(
  m,
  false, // transpose (always false)
  new Float32Array([
    1.0, 2.0, 3.0, 4.0,
    5.0, 6.0, 7.0, 8.0,
    9.0, 10.0, 11.0, 12.0,
    13.0, 14.0, 15.0, 16.0
  ])
);</code></pre>

</table>

<br>(vec2 andvec3 are declared similarly to vec4, mat2 and mat3 similarly to mat4).

<br>
<p>Here's the same demo as before, but this time the position, size and color of the point are set by the JS code:
<br>
<br>
<iframe id=i2 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=2"></iframe>

<br><br><hr><br>
<h4>How to draw many points, a matter of continuity</h4>

<p>First, let's try to edit the previous demo to display other points: for example, you'll see this if you uncomment the lines 47 to 53! (beautiful, isn't it?)
<br><br><img src="images/webgl-guide/rgb.jpg">

<p>WebGL has no problem calling gl.drawArrays many times in a row, but only if it is in the same timeframe.

<p>Here's what happens if we make a program that tries to draw a new random point every 500ms:

<br>
<br>
<iframe id=i3 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=3"></iframe>

<p>As you can see, the canvas is not only cleared, but completely reset each time drawArrays() is called. This is because the draws happen at different moments.
<br>To solve this, there are two solutions:
<br>1) Remember the positions and colors of every point and redraw them all every 500ms;
<br>2) Force <b>{ preserveDrawingBuffer: true }</b>, as you can see by removing the commented code on line 4 (if this is enabled, you can still gl.clear() the canvas manually).

<br><br><img src="images/webgl-guide/points.gif" width=300 loading=lazy>

<br><br><hr><br>

<h4>How to draw lines and triangles</h4>

<ul>
<li>The next step consists in declaring many points at once, and telling WebGL how to display them: as points, as lines or as triangles.
<li>To do this, we'll use an <b>array buffer</b> (an array of numbers) to transmit a list of vertex properties from JS to the fragment shader, via an attribute.
<li>This buffer is encoded in binary, and is interpreted as a list of numbers, formatted as one of these types:
<br>
<br>
<table border>
<tr>
<th>Name
<th>Bounds
<th>JS container
<th>WebGL type

<tr>
<td>Unsigned byte
<td>0 ... 255
<td>new Uint8Array([...])
<td>gl.UNSIGNED_BYTE

<tr>
<td>Signed short integer
<td>−32,768 ... 32,767
<td>new Int16Array([...])
<td>gl.SHORT

<tr>
<td>Unsigned short integer
<td>0 ... 65,535
<td>new Uint16Array([...])
<td>gl.UNSIGNED_SHORT

<tr>
<td>Signed integer
<td>-2,147,483,648 ... 2,147,483,647
<td>new Int32Array([...])
<td>gl.INT

<tr>
<td>Unsigned integer
<td>0 ... 4,294,967,295
<td>new Uint32Array([...])
<td>gl.UNSIGNED_INT

<tr>
<td>Floating point number
<td>none
<td>new Float32Array([...])
<td>gl.FLOAT
</table>
<br>
<li>gl.drawArrays can render points, lines and triangles in 7 different ways, by simply changing its first parameter:
<br>
<br>
<img src="images/webgl-guide/modes.png" width=800 style="border:2px solid #ddd">
<br>
<li>gl.POINTS is the only mode that supports gl_PointSize in the fragment shader.
<li>In lines mode, the lines width is 1 pixel wide. This width can't be changed reliably in current implementations (more info <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/lineWidth">here</a>)
</ul>

<p>Here's the simplest way to draw a triangle. You can edit the mode on line 59 to render points or lines instead of a triangle (ex: <mark style="background: #def;padding:3px;">gl.POINTS</mark> or <mark style="background: #def;padding:3px;">gl.LINE_LOOP</mark>).
<p>After binding the data buffer to the WebGL program, we specify the type and the number of values to read for each vertex, in this example it's 2 floats: X and Y (lines 43/44).
<br>
<br>
<iframe id=i4 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=4"></iframe>

<p>You can draw as many triangles as you want by adding vertices on line 33 and updating count on line 61.

<p>The array buffer creation and binding is always the same, so I included it in the function arraybuffer (in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/webgl.js">webgl.js</a>):
<pre style="font-size:11px"><code class="lang-js">// Bind an array buffer to an attribute and enable it
arraybuffer = (gl, data, program, attribute, size, type) => {
  gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
  var a = gl.getAttribLocation(program, attribute);
  gl.vertexAttribPointer(a, size, type, false, 0, 0);
  gl.enableVertexAttribArray(a);
}</code>
</pre>

<br><hr><br>

<h4>Multi-attribute buffer and varying color</h4>

<ul>
<li>Now imagine that we want to give a specific color to three vertices, and draw a triangle with them.
<li>We can do that by binding two data buffers (one for the vertex positions, another one for the vertex colors), which is totally fine,
<br>but we can also save a bit of resources by using a single data buffer with interleaved data, for example the values X/Y/R/G/B, recurring every 5 floats (see demo below).
<li>The vertex buffer will receive the positions and colors for each vertex and will need to transmit the colors to the fragment buffer.
<br>To do so, we will use a <b>varying</b>: a global variable that is writable by the vertex shader and readable by the fragment shader.
<br>Varyings are declared at the beginning of both shaders, and set in the code of the vertex shader. It's a good practice to name them with a "v_" prefix.
<br>Every fragment (pixel) inside the triangle, if it's bound to a varying color variable, will be interpolated from the color of each vertex around it!
</ul>
<iframe id=i6 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=5"></iframe>

<br><br><hr><br>

<h4>Translate, rotate, scale</h4>

<ul>
<li>If we want to move, rotate or scale a triangle, we need to know how to transform each of its vertices.
<li><b>Translation</b> consists in moving all the vertices in a given direction (increase or decrease its X/Y/Z coordinates).
<li><b>Rotation</b> consists in moving the vertices around a <b>pivot point</b>, with a given angle (a full turn clockwise is 360 degrees or 2 * Pi radians).
<li><b>Scaling</b> consists in making the triangle smaller or bigger by bringing the vertices closer or further from a pivot point.
<li>These operations can be done component per component (compute X, then Y, then Z), but we generally use a much powerful tool: <b>matrix transformations</b>.
<li>Each transformations can be written as a mat4 (a matrix of 4x4 floats), and applied to a vertex's <b>homogeneous coordinates</b> (vec4(X, Y, Z, 1.0)) with a multiplication.
</ul>

<p>
<table border>
<tr>
<th>Transformation
<th style=min-width:250px>Transformation applied to each vertex coordinates
<th><div style="min-width: 260px">transformation via a matrix</div>

<tr>
<td>Identity (no change)
<td>x' = x
<br>y' = y
<br>z' = z
<td style=padding:10px>

<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr>
<td>Translation along X, Y and Z axis
<td>x' = x + Tx
<br>y' = y + Ty
<br>z' = z + Tz
<td style=padding:10px>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Tx</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Ty</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>Tz</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr>
<td>Rotation around the X with an angle φ
<br>(φ is in radians)
<td>x' = x
<br>y' = y cos φ - z sin φ
<br>z' = y sin φ + z cos φ
<td style=padding:10px>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>cos φ</mn></mtd>
            <mtd><mn>-sin φ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>sin φ</mn></mtd>
            <mtd><mn>cos φ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr style=padding:10px>
<td>Rotation around the Y with an angle θ
<td>x' = x cos θ + z sin θ
<br>y' = y
<br>z' = -x sin θ + z cos θ
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>cos θ</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>sin θ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>-sin θ</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>cos θ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr style=padding:10px>
<td>Rotation around the Z axis with an angle ψ
<td>x' = x cos ψ – y sin ψ
<br>y' = x sin ψ + y cos ψ
<br>z' = z
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>cos ψ</mn></mtd>
            <mtd><mn>-sin ψ</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>sin ψ</mn></mtd>
            <mtd><mn>cos ψ</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr style=padding:10px>
<td>Scaling along X, Y and Z axis
<td>x' = Sx * x
<br>y' = Sy * y
<br>z' = Sz * z
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>Sx</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Sy</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Sz</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      ×
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

</table>

<ul>
<li>Multiple transformations can be accumulated by multiplying their matrices from right to left.
<br>For example, to translate then rotate a point, multiply in this order: (〈 rotation matrix 〉 × 〈 translation matrix 〉) × 〈 coordinates vector 〉
<li>Matrices and vectors can be multiplied together natively in GLSL:
</ul>

<iframe id=i5 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=6"></iframe>

<ul>
<li>As you can see on line 14 and 41 to 72, the 3 matrices are declared in JS and sent to the fragment shader, which multiplies them with each vertex position.
<br>This is easy to code, but unfortunately not optimal in real conditions, as the multiplications must be hardcoded in glsl and repeated for every fragment of the program.
<br>In the following examples, the compound transformation matrix will be computed only once (in JS) and passed to the shader.
</ul>

<p>Helper functions added in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/matrix.js">matrix.js</a> (because matrices multiplications are not native in JS):
<pre style="font-size:11px"><code class="lang-js">// Create an identity mat4
identity = () => {
  return new Float32Array([
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
  ]);
};

// Compute the multiplication of two mat4 (c = a x b)
multMat4Mat4 = (a, b) => {
  var i, e, a, b, ai0, ai1, ai2, ai3;
  var c = new Float32Array(16);
  for (i = 0; i &lt; 4; i++) {
    ai0 = a[i];
    ai1 = a[i+4];
    ai2 = a[i+8];
    ai3 = a[i+12];
    c[i]    = ai0 * b[0]  + ai1 * b[1]  + ai2 * b[2]  + ai3 * b[3];
    c[i+4]  = ai0 * b[4]  + ai1 * b[5]  + ai2 * b[6]  + ai3 * b[7];
    c[i+8]  = ai0 * b[8]  + ai1 * b[9]  + ai2 * b[10] + ai3 * b[11];
    c[i+12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
  }
  return c;
};

// Transform a mat4
// options: x/y/z (translate), rx/ry/rz (rotate), sx/sy/sz (scale)
transform = (mat, options) => {

  var out = new Float32Array(mat);
  
  var x = options.x || 0;
  var y = options.y || 0;
  var z = options.z || 0;
  
  var sx = options.sx || 1;
  var sy = options.sy || 1;
  var sz = options.sz || 1;
  
  var rx = options.rx;
  var ry = options.ry;
  var rz = options.rz;
  
  // translate
  if(x || y || z){
    out[12] += out[0] * x + out[4] * y + out[8]  * z;
    out[13] += out[1] * x + out[5] * y + out[9]  * z;
    out[14] += out[2] * x + out[6] * y + out[10] * z;
    out[15] += out[3] * x + out[7] * y + out[11] * z;
  }
  
  // Rotate
  if(rx) out.set(multMat4Mat4(out, new Float32Array([1, 0, 0, 0, 0, Math.cos(rx), Math.sin(rx), 0, 0, -Math.sin(rx), Math.cos(rx), 0, 0, 0, 0, 1])));
  if(ry) out.set(multMat4Mat4(out, new Float32Array([Math.cos(ry), 0, -Math.sin(ry), 0, 0, 1, 0, 0, Math.sin(ry), 0, Math.cos(ry), 0, 0, 0, 0, 1])));
  if(rz) out.set(multMat4Mat4(out, new Float32Array([Math.cos(rz), Math.sin(rz), 0, 0, -Math.sin(rz), Math.cos(rz), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])));
  
  // Scale
  if(sx !== 1){
    out[0] *= sx;  
    out[1] *= sx;
    out[2] *= sx;
    out[3] *= sx;
  }
  if(sy !== 1){
    out[4] *= sy;
    out[5] *= sy;
    out[6] *= sy;
    out[7] *= sy;
  }
  if(sz !== 1){
    out[8] *= sz;
    out[9] *= sz;
    out[10] *= sz;
    out[11] *= sz;
  }
  
  return out;
};</code>
</pre>

<h5>How to change the pivot point</h5>

<p>The rotations and scaling matrices, as described above, only allow to use the world's origin (0,0,0) as pivot point.
<br>Imagine a triangle that is not centered on the origin, and needing to rotate 90 degrees (Pi / 2 radins) around its center, for example the point (2,2,0).
<br>The solution is to apply 3 transformation matrices to this triangle's vertices: translate to (0,0,0), then rotate 90 degrees, then translate back to (2,2,0)!

<br><br><hr><br>

<h4>Texturing</h4>

<ul>
<li>As we saw earlier, the colors of the fragments inside a triangle are interpolated from the colors of each vertex around it.
<br>The same principle can be used with a texture image (it's called sampling in this case).
<li>Each texture (square or rectangle) has a local coordinates system (U,V) that goes from 0 to 1, and every vertex can have its own <b>texture coordinates</b> in this system.
<li>A JS Image object can be bound to an <b>uniform sampler2D</b> to create a texture, which is applied to the current fragment using <b>gl_FragColor = texture2D(sampler, coords);</b>
<li>The "pixels" of the texture are called texels. The texture files are generally squared to avoid being stretched in a direction or the other.
<br><img src="images/webgl-guide/texture.png">
</ul>

<p>Here's an example of textured quad (a square made of two triangles). You can edit the numbers to change the way the vertices and texture are mapped:
<p>
<iframe id=i7 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=7"></iframe>

<p>Remember that the values you're manipulating are rgba colors, so you can basically do anything you want with them, like inverting the colors:

<pre class="language-js"><code>vec4 color = texture2D(sampler, v_TexCoord);
gl_FragColor = vec4(vec3(1.0, 1.0, 1.0) - color.rgb, 1.0);</code></pre>

<br><img src="images/webgl-guide/textures0.png">

<h5>Multiple textures</h5>
<p>Two or more textures can also be used at the same time. For example, you can initialize two samplers, and add or multiply them in the fragment shader:
<pre class="language-js"><code>vec4 color0 = texture2D(sampler0, v_TexCoord);
vec4 color1 = texture2D(sampler1, v_TexCoord);
gl_FragColor = color0 + color1;

// or

gl_FragColor = color0 * color1;</code></pre>

<br><img src="images/webgl-guide/textures.png" width=600>

<p>Or blend them together:

<pre class="language-js"><code>gl_FragColor = color0 * 0.25 + color1 * 0.75;</code></pre>

<br><img src="images/webgl-guide/textures2.png" width=600>

<br><br><hr><br>

<h2>3D graphics</h2>
<br>You should know by now that computers don't do "3D" natively.
<br>You (or your 3D framework) will have to do all the computing to simulate the camera, the perspective and how they affect each polygon, so the scene can seem to be in 3D.
<br>Fortunately, the API we use (WebGL) provides very helpful tools (especially data and depth buffers) to help rendering complex scenes without too much effort.
<br>
<h4>3D camera</h4>
<br><img src="images/webgl-guide/frustum.png">
<ul>
<li>In 3D, the "camera", with its position, angle and perspective, is defined by nothing more than a 4x4 matrix.
<li>During render, every vertex in the scene is multiplied by this matrix to simulate these camera properties and appear at the right position.
<li>First, the camera's frustum (field of view angle, aspect ratio, near clip plane and far clip plane) can be set with:

<div class=math>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1/(aspect*tan(fov/2))</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1/tan(fov/2)</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-(far+near)/(far-near)</mn></mtd>
            <mtd><mn>-(2*far*near)/(far-near)</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-1</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>
</div>

<li>Then, the camera can be translated, rotated and scaled (zoomed) similarly to the vertices, by using the matrices multiplications we saw earlier.
<li>A slightly more advanced LookAt() function is often used by developers to set the camera's position, angle and target all at once.
</ul>
<p>Here are the perspective() and lookAt() functions I added in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/matrix.js">matrix.js</a>:

<pre><code class="lang-js">// Create a perspective matrix
// options: fov, aspect, near, far
orthogonal = options => {
  var fov = options.fov || 1.5;
  var aspect = options.ratio || 1; // canvas.width / canvas.height
  var near = options.near || 0;
  var far = options.far || 100;
  var f = 1 / Math.tan(fov);
  var nf = 1 / (near - far);
  return new Float32Array([
    f / aspect, 0, 0, 0, 
    0, f, 0, 0, 
    0, 0, (far + near) * nf, -1,
    0, 0, (2 * near * far) * nf, 0
  ]);
}

// LookAt
lookat = (mat, eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) => {
  var e, fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;
  fx = centerX - eyeX;
  fy = centerY - eyeY;
  fz = centerZ - eyeZ;
  rlf = 1 / Math.sqrt(fx*fx + fy*fy + fz*fz);
  fx *= rlf;
  fy *= rlf;
  fz *= rlf;
  sx = fy * upZ - fz * upY;
  sy = fz * upX - fx * upZ;
  sz = fx * upY - fy * upX;
  rls = 1 / Math.sqrt(sx*sx + sy*sy + sz*sz);
  sx *= rls;
  sy *= rls;
  sz *= rls;
  ux = sy * fz - sz * fy;
  uy = sz * fx - sx * fz;
  uz = sx * fy - sy * fx;
  var l = new Float32Array(
    sx, ux, -fx, 0,
    sy, uy, -fy, 0,
    sz, uz, -fz, 0,
    0,  0,  0,   1
  );
  l = transform(l, {x: -eyeX, y: -eyeY, z: -eyeZ});
  return multMat4Mat4(mat, l); 
}</code>
</pre>

<br>
<p>It's also possible to make an orthogonal camera with no perspective, also called "orthographic", "isometric" or "2.5D" view.
<br>In this case, the frustum is a box:
<br><img src="images/webgl-guide/orthogonal.png">

<div class=math>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>2/(right-left))</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-((right+left)/(right-left))</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>2/(top-bottom)</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-((top+bottom)/(top-bottom))</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-2/(far-near)</mn></mtd>
            <mtd><mn>-((tar+near)/(far-near))</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>
</div>

<p>And the source code:

<pre><code class="lang-js">// Create an orthogonal matrix
// options: top, bottom, left, right, near, far
orthogonal = options => {
  var top = options.top;
  var bottom = options.bottom;
  var left = options.left;
  var right = options.right;
  var near = options.near || 0;
  var far = options.far || 100;
  var rw = 1 / (right - left);
  var rh = 1 / (top - bottom);
  var rd = 1 / (far - near);
  return new Float32Array([
    2 * rw, 0, 0, 0,
    0, 2 * rh, 0, 0,
    0, 0, -2 * rd, 0,
    -(right + left) * rw, -(top + bottom) * rh, -(far + near) * rd, 1
  ]);
}</code>
</pre>

<p>You may have noticed that the matrix is different in the mathematic formula and in the source code.
<br>This is because WebGL requires that all the matrices used in the shaders are transposed (i.e. X and Y axis are inversed).
<br>You don't need to worry about it when using the functions in  <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/matrix.js">matrix.js</a>, but otherwise, you can either write your matrices already transposed, or use this function:

<pre><code class="lang-js">// Get the transposed of a mat4
transpose = m => {
  return new Float32Array([
    m[0], m[4], m[8],  m[12],
    m[1], m[5], m[9],  m[13],
    m[2], m[6], m[10], m[14],
    m[3], m[7], m[11], m[15]
  ]);
};</code>
</pre>

<br><br><hr><br>

<h4>Reduce repetitions with indexed vertices</h4>

<ul>
<li>Before starting to draw 3D objects (that require a lot of triangles), we need to learn an optimized way to write our buffers.
<li>As we have seen before, data buffers (with the type gl.ARRAY_BUFFER) can hold vertex properties (position, color, texture coordinates...).
<li>These properties can be placed into multiple buffers or interleaved into a single one.
<li>In 3D, vertices are often shared between multiple triangles.
<li>Instead of repeating the same vertices many times in the same buffer, it's possible to write each vertex only once in a data buffer,<br>and use a second buffer with the type <b>gl.ELEMENT_ARRAY_BUFFER</b> that declares all our triangles by using indices of the first object.
<li>Even if many data buffers exist in your program, only one index buffer can be used, and it will list indices from all the data buffers at once,<br>so they all need to be stored in the same order (the N'th item of every buffer must belong to the same N'th vertex).
<li>Finally, to draw indexed vertices, you need you replace gl.drawArrays with <b>gl.drawElements(type, count, type, offset)</b>.
<li>The indices stored in the index buffer have integer values (N = 0, 1, 2...), and you can choose their size in bytes depending on the number of vertices you want to index:
<br>
<br>
<table border>
<tr>
<th>Number of vertices to index
<th>Index buffer type
<th>drawElements type
<tr>
<td>0 ... 256
<td>Uint8Array([...])
<td>gl.UNSIGNED_BYTE
<tr>
<td>0 ... 65,536
<td>Uint16Array([...])
<td>gl.UNSIGNED_SHORT
<tr>
<td>0 ... 4,294,967,296
<td>Uint32Array([...])
<td>gl.UNSIGNED_INT (*)
</table>

<p>(*) In WebGL1, an extension must be enabled before using the type UNSIGNED_INT: <b>gl.getExtension('OES_element_index_uint');</b>. In WebGL2, it's enabled by default.
</ul>

<br>
<p>You can see indexed buffers in action in the following demos...


<br><br><hr><br>

<h3>Hello cube</h3>

<p>The easiest 3D shape to render is a cube. But to render it correctly, two new settings must be used:
<ul>
<li>In order to make each triangle appear at the right depth (the front ones in front, the back ones in the back), depth-sorting must be enabled with <b>gl.enable(gl.DEPTH_TEST);</b>
<li>The clear code is also updated to take this depth test into account: <b>gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);</b> (see lines 95 and 106).
</ul>

<iframe id=i8 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=8"></iframe>

<p>You can notice that the cube appears to rotate on itself, but it's actually the camera that rotates around it (see lines 97-100 + 104).

<br><br><hr><br>

<h3>Color each face of the cube</h3>

<ul>
<li>To color each face individually, each vertex can't have an unique color like before. Its color needs to vary depending on which face is being rendered.
<li>The solution is to declare all the possible combinations of vertices positions and colors in two data buffers, and use an index buffer to create the corresponding triangles.
<li>The same principle will apply if you want to make a cube with different textures on each face.
</ul>

<iframe id=i9 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=9"></iframe>

<p>I've added the cube declaration in the cube() function of <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/shapes.js">shapes.js</a> to avoid repeating it in the next demos:

<pre><code class="lang-js">// Declare a cube (2x2x2)
// Returns [vertices (Float32Array), normals (Float32Array), indices (Uint16Array)] 
//
//    v6----- v5
//   /|      /|
//  v1------v0|
//  | |     | |
//  | |v7---|-|v4
//  |/      |/
//  v2------v3

cube = (r = 1, g = 1, b = 1) => {

  var vertices = new Float32Array([
     1.0, 1.0, 1.0,  -1.0, 1.0, 1.0,  -1.0,-1.0, 1.0,   1.0,-1.0, 1.0, // front
     1.0, 1.0, 1.0,   1.0,-1.0, 1.0,   1.0,-1.0,-1.0,   1.0, 1.0,-1.0, // right
     1.0, 1.0, 1.0,   1.0, 1.0,-1.0,  -1.0, 1.0,-1.0,  -1.0, 1.0, 1.0, // up
    -1.0, 1.0, 1.0,  -1.0, 1.0,-1.0,  -1.0,-1.0,-1.0,  -1.0,-1.0, 1.0, // left
    -1.0,-1.0,-1.0,   1.0,-1.0,-1.0,   1.0,-1.0, 1.0,  -1.0,-1.0, 1.0, // down
     1.0,-1.0,-1.0,  -1.0,-1.0,-1.0,  -1.0, 1.0,-1.0,   1.0, 1.0,-1.0  // back
  ]);

  var normals = new Float32Array([
    0.0, 0.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0, 1.0,  // front
    1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0,  // right
    0.0, 1.0, 0.0,   0.0, 1.0, 0.0,   0.0, 1.0, 0.0,   0.0, 1.0, 0.0,  // up
   -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  // left
    0.0,-1.0, 0.0,   0.0,-1.0, 0.0,   0.0,-1.0, 0.0,   0.0,-1.0, 0.0,  // down
    0.0, 0.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,-1.0   // back
  ]);

  var indices = new Uint16Array([
    0, 1, 2,   0, 2, 3,  // front
    4, 5, 6,   4, 6, 7,  // right
    8, 9, 10,  8, 10,11, // up
    12,13,14,  12,14,15, // left
    16,17,18,  16,18,19, // down
    20,21,22,  20,22,23  // back
  ]);
  
  return [vertices, normals, indices];
};</code></pre>

<p>In bonus, <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/shapes.js">shapes.js</a> also contains the models for a sphere and a pyramid.
<br>You can test them in all the following demos by replacing cube() with <b>sphere()</b> or <b>pyramid()</b>.

<br><br><img src="images/webgl-guide/othershapes.png">

<br><br>NB: all the shapes in this file use Uint16Array's for indices, so remember to use <b>gl.UNSIGNED_SHORT</b> in drawArrays().

<br><br><hr><br>

<h4>Lighting and shading</h4>

<h5>Diffuse light</h5>
<ul>
<li>Diffuse light reflexion is visible when the light is reflected in all directions as it hits a surface, with an intensity that decreases with the surface's relative angle.
<br><img src="images/webgl-guide/diffuse.png">
<li>To simulate that, we need to define a light source with a color (for example, white), and a direction (for example, vec3(0.5, 3.0, 4.0)).
<li>Each triangle has <b>normal</b>: a vec3 that points to the outside, and <b>normalized</b> (with a length equal to 1).
<li>In the fragment shader, we perform a <b>dot product</b> between the light vector and the face normal, to determine how much the light is diffused:
<br><br><img src="images/webgl-guide/dot.gif" width=250 style="border: 1px solid #ddd; position: relative;top: 5px;margin: 0 10px 0 0;">
 (gif by <a href="https://twitter.com/FreyaHolmer/status/1200807790580768768?ref_src=twsrc%5Etfw">@FreyaHolmer</a>)<br><br>
<li>If the dot product is negative, we set it to "0" (there can't be a negative amount of light). This is done with <b>max(dot(light, normal), 0.0);</b>
<li>The color sent to the fragment shader is: the light's color (rgb) × the face color (rgb) × the dot product of the normal and the light. The color's alpha is set to 1.0.
<li>NB: The components of a vec4 can be accessed with .x/y/z/t (for a position) or .r/g/b/a (for a color). They can also be composed into a new vector (ex: <b>vec3 rgb = col.rgb</b>).
</ul>

<iframe id=i10 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=10"></iframe>

<br><h5>Ambient light</h5>

<p>With diffuse lighting alone, some faces are too dark, like the rightmost one here. To fix that, we can add an ambient light reflexion.
<p>To simulate it, we need to set a light color (not too bright, for example: vec3(0.2, 0.2, 0.2)), apply it to the surface color (with a multiplication), and add it to the diffuse light:
<br>
<br>
<iframe id=i11 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=11"></iframe>

<br>
<h5>Point light</h5>

<p>With diffuse and ambient lights alone, each face gets a flat color. It's called polygonal or facetted rendering, and isn't realistic (it's great for retro-looking games though)  
<ul>
<li>To enhance that, we can use a <b>point light</b> representing the sun or a light bulb, with a specific position and color
<li>With such a point light in the scene, the shading will be able to vary according to the distance between each point of the cube and the point light
<li>When it's computed per vertex, it looks a bit nicer but still not great due to the imprecise color interpolation (the triangles are visible):
<br>
<br><img src="images/webgl-guide/per_vertex.png" width=500>
<br>
<br>
<li>A better solution consists in computing the right color for every fragment of the cube (i.e. every pixel),<br>and that's exactly what the fragment shader is here for:
<br><br><img src="images/webgl-guide/sphere.png" width=500>
</ul>
<br>
<iframe id=i12 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=12"></iframe>
<p>As you can see, the vertex shader sends the verices positions, colors and normals to the fragment shader using varyings, and the fragment shader computes everything. 

<h5>Smooth shading</h5>

<ul>
<li>With the lighting methods we've seen before, a complex 3D model will always have "hard edges" (abrupt changes of lighting between two faces).
<br>This is because each face has an unique normal vector, which is shared between all its vertices.
<li>Smooth shading consists in computing a different normal for each vertex, equal to the mean of the normals of all the faces it belongs to.
<br>But no need to use divisions! Just add all the normals together and the mean will simply appear when the shaders will normalize the result (more info <a href="https://www.iquilezles.org/www/articles/normals/normals.htm">here</a>).
<li>Example: a complex 3D model with smooth shading disabled / enabled.
<br><br><img src="images/webgl-guide/w5.gif" width=650>
</ul>

<h5>Other types of lighting</h5>
<ul>
<li>Emissive lighting: when an object is self-illuminated - this can be easy if you just want to make the fragments lighter (multiply their rgb color with a number higher than 1),
<br>or very complicated if you want the surface to illuminate surrounding objects (this will not be covered here :p ).
<li>Specular lighting: when an object is shiny, it can reflect a point light like a mirror under a certain angle (more info <a href="https://webgl2fundamentals.org/webgl/lessons/webgl-3d-lighting-point.html">here</a>).
<br>To simulate it, we can compute the half-vector between the camera, the fragment and the light, and compare this with the surface normal using a dot product.
<br>This dot product is then powered to a number that represents the surface's "shininess", and added to the other (ambient / diffuse / emmisive) lights in the fragment shader:
</ul>
<img src="images/webgl-guide/specular.png">

<pre><code class=lang-js>var fshader = `
(...)
float shininess = 150.0;
vec3 surfaceWorldPosition = (u_world * a_position).xyz;
vec3 v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;
vec3 v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;
vec3 surfaceToLightDirection = normalize(v_surfaceToLight);
vec3 surfaceToCameraDirection = normalize(v_surfaceToCamera);
vec3 halfVector = normalize(surfaceToLightDirection + surfaceToCameraDirection);
float light = dot(normal, surfaceToLightDirection);
# the pow is to avoid having specular reflection that's too shiny
float specular = pow(dot(normal, halfVector), shininess);
color.rgb *= light * lightColor;
color.rgb += specular * specularLightColor;
(...)
`;</code></pre>

<h5>A bit of vocabulary</h5>

<ul>
<li>You may find documents talking about ambient / diffuse / specular <b>colors</b>. It's the same thing as ambient / diffuse / specular <b>lighting</b>.
<br>And it kind of makes sense: in CG, like in the real world, the colors emitted by an object depend entirely on its lighting.

<li>However, <b>lighting</b> and <b>shading</b> are not the same thing, even though the two terms are often mixed.
<br>Lighting is actually a physics notion (how the light affects an object) while shading is purely CG-related (how a pixel is rendered on a screen).
</ul>

<br><hr><br>

<h4>Transforming the shaded cube</h4>

<ul>
<li>So far, we've only transformed the camera matrix, to make it revolve around the cube to create an illusion of cube rotation.
<li>Now that we have a fixed point light in the scene, if we want to rotate, translate or scale the cube without touching the rest of the scene, we need to do two things:<br>- introduce a <b>model matrix</b> (the transformation matrix of the cube),<br>- recompute the cube's normals and the lighting of every fragment every time the model matrix is updated.
<li>Computing a triangle normal can be done using a <b>cross-product</b> of two edge's vectors respecting the-right hand rule (AB × BC if A, B and C are in counterclockwise order).

<br><br><img src="images/webgl-guide/cross.gif" width=300 style="border: 1px solid #ddd; position: relative;top: 5px;margin: 0 10px 0 0;">
 (gif by <a href="https://twitter.com/FreyaHolmer/status/1203059678705602562?ref_src=twsrc%5Etfw">@FreyaHolmer</a>)
<br><br>

<li>A cross-product can be computed natively in WebGL: <b>cross(vec3 AB, vec3 BC)</b>.

<li>In practice, the best method is to keep the original normals unchanged, and pass them to the vertex shader, along with the vertex position and color.
<br>
Then, when the model matrix changes, the trick is compute its <b>inverse transpose</b> and pass it to the vertex shader in the form of an uniform mat4.
<br>
In the vertex shader, simply multiply the original normal with this inverse transpose matrix to obtain its updated value: <b>vec3 newNormal = oldNormal * inverseTranspose</b>.
<li>Here are the inverse() and inverseTranspose() functions added in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/matrix.js">matrix.js</a>:

<pre><code class="lang-js">// Get the inverse of a mat4
inverse = m => {
  var inv = new Float32Array([
     m[5]*m[10]*m[15] - m[5]*m[11]*m[14] - m[9]*m[6]*m[15] + m[9]*m[7]*m[14] + m[13]*m[6]*m[11] - m[13]*m[7]*m[10],
    -m[1]*m[10]*m[15] + m[1]*m[11]*m[14] + m[9]*m[2]*m[15] - m[9]*m[3]*m[14] - m[13]*m[2]*m[11] + m[13]*m[3]*m[10],
     m[1]*m[6]*m[15]  - m[1]*m[7]*m[14]  - m[5]*m[2]*m[15] + m[5]*m[3]*m[14] + m[13]*m[2]*m[7]  - m[13]*m[3]*m[6],
    -m[1]*m[6]*m[11]  + m[1]*m[7]*m[10]  + m[5]*m[2]*m[11] - m[5]*m[3]*m[10] - m[9]*m[2]*m[7]   + m[9]*m[3]*m[6],
    -m[4]*m[10]*m[15] + m[4]*m[11]*m[14] + m[8]*m[6]*m[15] - m[8]*m[7]*m[14] - m[12]*m[6]*m[11] + m[12]*m[7]*m[10],
     m[0]*m[10]*m[15] - m[0]*m[11]*m[14] - m[8]*m[2]*m[15] + m[8]*m[3]*m[14] + m[12]*m[2]*m[11] - m[12]*m[3]*m[10],
    -m[0]*m[6]*m[15]  + m[0]*m[7]*m[14]  + m[4]*m[2]*m[15] - m[4]*m[3]*m[14] - m[12]*m[2]*m[7]  + m[12]*m[3]*m[6],
     m[0]*m[6]*m[11]  - m[0]*m[7]*m[10]  - m[4]*m[2]*m[11] + m[4]*m[3]*m[10] + m[8]*m[2]*m[7]   - m[8]*m[3]*m[6],
     m[4]*m[9]*m[15]  - m[4]*m[11]*m[13] - m[8]*m[5]*m[15] + m[8]*m[7]*m[13] + m[12]*m[5]*m[11] - m[12]*m[7]*m[9],
    -m[0]*m[9]*m[15]  + m[0]*m[11]*m[13] + m[8]*m[1]*m[15] - m[8]*m[3]*m[13] - m[12]*m[1]*m[11] + m[12]*m[3]*m[9],
     m[0]*m[5]*m[15]  - m[0]*m[7]*m[13]  - m[4]*m[1]*m[15] + m[4]*m[3]*m[13] + m[12]*m[1]*m[7]  - m[12]*m[3]*m[5],
    -m[0]*m[5]*m[11]  + m[0]*m[7]*m[9]   + m[4]*m[1]*m[11] - m[4]*m[3]*m[9]  - m[8]*m[1]*m[7]   + m[8]*m[3]*m[5],
    -m[4]*m[9]*m[14]  + m[4]*m[10]*m[13] + m[8]*m[5]*m[14] - m[8]*m[6]*m[13] - m[12]*m[5]*m[10] + m[12]*m[6]*m[9],
     m[0]*m[9]*m[14]  - m[0]*m[10]*m[13] - m[8]*m[1]*m[14] + m[8]*m[2]*m[13] + m[12]*m[1]*m[10] - m[12]*m[2]*m[9],
    -m[0]*m[5]*m[14]  + m[0]*m[6]*m[13]  + m[4]*m[1]*m[14] - m[4]*m[2]*m[13] - m[12]*m[1]*m[6]  + m[12]*m[2]*m[5],
     m[0]*m[5]*m[10]  - m[0]*m[6]*m[9]   - m[4]*m[1]*m[10] + m[4]*m[2]*m[9]  + m[8]*m[1]*m[6]   - m[8]*m[2]*m[5]
  ]);
  det = m[0]*inv[0] + m[1]*inv[4] + m[2]*inv[8] + m[3]*inv[12];
  if(!det) return m;
  det = 1 / det;
  for(var i = 0; i < 16; i++) {
    inv[i] *= det;
  }
  return inv;
};

// Get the inverse transpose of a mat4
inverseTranspose = m => transpose(inverse(m));</code></pre>
<br>
<li>We also pass a "mvp" (<b>model view projection</b>) matrix to the vertex shader, which is the multiplication of the camera matrix and the model matrix.
<br>These two matrices are multiplied in JS instead of the vertex buffer, for the same reason as before: avoid the effort of recomputing it for each vertex, at each frame.
<li>Normals are generally hardcoded, but if you need to compute one in JS, here's the code:
<pre><code class="lang-js">// Cross-product of three points a, b, c, arranged counter-clockwise.
// Returns the coordinates of a normal vector that points to the side where these points are counter-clockwise.
cross = (a0, a1, a2, b0, b1, b2, c0, c1, c2) => {
	var xAB = b0 - a0, yAB = b1 - a1, zAB = b2 - a2, xBC = c0 - b0, yBC = c1 - b1, zBC = c2 - b2;
  return [yAB * zBC - zAB * yBC, zAB * xBC - xAB * zBC, xAB * yBC - yAB * xBC];
}</code></pre>

</ul>
<p>Here's a cube rotating on itself with a fixed camera and a fixed point light:
<br>
<br>

<iframe id=i13 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=13"></iframe>

<p>You may remark that in certain cases (simple rotation or scaling), the inverse transpose matrix will be equal to the model matrix.
<br>But for translations or any combination of transformations, it will actually have a different value.
<br>As I said earlier, this value is useful in order to update the face normals with a simple multiplication, instead of recomputing them from scratch (more info <a href="https://stackoverflow.com/questions/13654401/why-transforming-normals-with-the-transpose-of-the-inverse-of-the-modelview-matr">here</a>).

<br><br><hr><br>

<h4>Drawing many cubes</h4>

<ul>
<li>To draw many cubes at once, it's of course possible to declare the vertices coordinates, colors and normals of each cube separately, but that would be very verbose.
<li>Instead, we can consider the cube we already declared as a reusable model.
<li>For each cube we want to draw, we simply need to transform it (by giving it a new model matrix, mvp matrix and inverse transpose matrix), and render it.
</ul>

<p>Here's a demo with 3 red cuboids (deformed cubes)
<br><br>
<iframe id=i14 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=14"></iframe>

<p>To avoid repetitions, I added a drawShape() function in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/shapes.js">shapes.js</a>, with optional scaling along X/Y/Z. Its role is to (re)render the current model as many times as necessary.

<pre><code class="lang-js">// Draw the current shape
drawShape = (gl, program, cameraMatrix, modelMatrix, n, sx = 1, sy = 1, sz = 1) => {
  
  // Set the model matrix (add the custom scale if any)
  var model = gl.getUniformLocation(program, 'model');
  modelMatrix = transform(modelMatrix, {sx, sy, sz});
  gl.uniformMatrix4fv(model, false, modelMatrix);

  // Set the cube's mvp matrix (camera x model)
  var mvpMatrix = multMat4Mat4(cameraMatrix, modelMatrix);
  var mvp = gl.getUniformLocation(program, 'mvp');
  gl.uniformMatrix4fv(mvp, false, mvpMatrix);

  // Set the inverse transpose of the model matrix
  var inverseTransposeMatrix = transpose(inverse(modelMatrix));
  var inverseTranspose = gl.getUniformLocation(program, 'inverseTranspose');
  gl.uniformMatrix4fv(inverseTranspose, false, inverseTransposeMatrix);

  // Render
  gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_SHORT, 0);
};</code></pre>

<br><br><hr><br>


<h4>Hierarchical objects</h4>

<ul>
<li>A <b>hierarchical object</b> is a model made of several basic objects (called <b>segments</b>), for example a robotic arm.
<li><b>Joints</b> are where the segments are linked and rotate relatively to each other, like an elbow or a wrist.
<li>To keep the segments linked to each other, the transformation matrix is inherited from segment to segment (ex: a hand will add its own transformation matrix to the arm's one). 
</ul>
<p>The following demo shows an robotic arm made of three cuboids (click the buttons below to make it move).
<br><br>

<iframe id=i15 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=15"></iframe>
<ul>
<li>You can see from line 146 that the vertical "arm" cuboid can rotate around X, and once it's rotated, we perform a "-2" translation along Y.
<br>As described in the "transformations" chapter, this allows to make the cuboid to rotate around a pivot point placed at its extremity (the "elbow") instead of its center.
<li>Then from line 152, the hand cuboid, which is attached at the end of the arm cuboid, inherits its model matrix, and extends it to add its own rotation and translation.
<br>(the rotation happens along the Y axis, and the translation places it at the end of the arm)
<li>This process can be repeated many times to make a multi-joint object, like an entire robot or a rope made of many segments!
<li>Also, if many segments are attached to the same parent (for example, the fingers of a hand), they must all reuse their parent's matrix (see demo <a href="https://xem.github.io/webgl-guide/book/ch09/MultiJointModel.html">here</a>).

<br><br><img src="images/webgl-guide/6cubes.gif" width=250> 

<br><br><hr><br>

<h4>Debugging</h4>

<p>Syntax errors present in your fragment shaders are logged during their compilation. The most frequent are:
<ul>
<li>Missing semicolon at the end of a line.
<li>Trying to set a value already set by an uniform (uniforms are read-only).
</ul>
<br>
<p>Other errors can be made in the JS program, and can sometimes fail silently. especially:
<ul>
<li>Using the bad count parameter for gl.drawArrays or gl.drawElements (must be the number of vertices).
<li>Using the wrong combination of types for an index buffer and gl.drawElements (Uint16Array only work with gl.UNSIGNED_SHORT).
<li>Not passing the right amount of data in attributes or uniforms (ex: 4 floats in a vec3).
</ul>
<br>
<p>Finally, if no syntax errors were made but nothing appears, check that:
<ul>
<li>The camera looks in the right direction (and with a decent fov angle, around 0.9 rad or 50 degrees).
<li>The light source is not trapped inside your 3D object
<li>Your normals are not inverted (they must point "outside" to let the object reflect the light correctly).
<li>You didn't accidentally set any color's alpha to 0.0.
</ul>

<br><br><hr><br>

<h4>To be continued...</h4>

<p>At this point we've covered all the basis of 2D and 3D rendering.
<br>Unfortunately, browsers don't accept more than 16 WebGL contexts in the same page, so check out the <a href="webgl-guide-part-2.html">PART 2</a> for advanced techniques! :)
</div>
</div>

</main>

</div>

<footer></footer>

<script src="../ui.js"></script>

<script>
header();
footer();
menu();
</script>

<script>
if(navigator.userAgent.includes("WebKit")){

scr = document.createElement("SCRIPT");
scr.src = 'https://polyfill.io/v3/polyfill.min.js?features=es6';
document.body.appendChild(scr);

scr = document.createElement("SCRIPT");
scr.id = 'MathJax-script';
scr.setAttribute('async', true); 
scr.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
document.body.appendChild(scr);
}

</script>

</body>
</html>
