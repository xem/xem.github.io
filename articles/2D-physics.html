<!doctype html>
<meta charset=utf-8>
<meta name="viewport" content="width=device-width, user-scalable=no">
<html>
<head>
<link rel=stylesheet href="../style.css?v=2024-07">
<title>Maxime Euzière</title>
<base target=_blank>
</head>
<body>

<style>
.twitter-tweet { margin: 30px 0 !important; border: 3px solid #ccc; border-radius: 30px; overflow: hidden; transform: scale(.95)}
ul { padding-left: 15px }
</style>

<div class="wrapper">

<header></header>

<div id=menu></div>

<main>

<div class=section>

<h2>Golfing a 2D physics engine in JS</h2>
<br><h3>November 2025</h3>
<br><hr>
<p><img src="images/2D-physics/2D.png" style="float:right; margin: 0 20px; width: 200px"><b>Introduction</b>
<p>I have a long love-hate story with physics in JS.
<p>It all started in 2019, when I read <a href="https://link.springer.com/book/10.1007/978-1-4842-2583-7">this 134 pages book about 2D physics</a>, and summarized its contents in just <a href="https://xem.github.io/articles/images/js1k19/2.png">9 pages</a> on my little notepad.
<p>I used that to create a 1.57kb lib called <a href="https://xem.github.io/codegolf/mini2Dphysics.html">Mini2DPhysics</a> and the JS1K entry <a href="https://xem.github.io/codegolf/emojysics.html">Emojysics</a>.
<p>The problem was that this book, as every book I could find at the time, didn't go beyond basic interactions between spheres and discs (and it definitely didn't need so many pages to do that).
<p>Then <a href="https://link.springer.com/book/10.1007/978-1-4842-7377-7">this 599 pages book</a> released in 2022 by the same editor and some of the original authors, managed to be even more verbose in almost every aspect of 2D game mechanics, except one: advanced physics. And when I say "advanced physics", I'm not asking for really complex stuff, I just want to learn springs, fixed joints, hinge joints, and how to optimize speed and stability.
<p>In 2021, 2022, 2023, 2024 and 2025 I tried many times to learn <a href="https://xem.github.io/articles/3D-physics.html">3D physics</a> because <a href="images/2D-physics/3D.jpg">a lot of good books actually cover this topic</a>, but I haven't managed to completely implement any of them in JS (so far)... which was quite frustrating. (but stay tuned... I will be back!)
<p>Finally, in October 2025, after completing a new edition of <a href="https://xem.github.io/articles/js13k25.html">JS13KGames</a>, I randomly typed "2D physics JS" on Google and stumbled upon (seemingly) my holy Grail: <a href="https://www.reddit.com/r/gamedev/comments/1afq10l/i_created_a_tutorial_about_how_everybody_can/">this 2024 Reddit post</a> announcing a complete <a href="https://www.youtube.com/watch?v=D3oQ8mUF_84&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr">Youtube playlist</a> dedicated to learning 2D physics in JS. The playlist was accompanied by <a href="https://gitlab.com/Marcel.K/tutorials/-/tree/main/2D%20Physics%20Engine">complete source code on Gitlab</a> and <a href="https://www.amazon.fr/dp/B0FL1K2ZZ5">a physical book released in August 2025</a>!

<p>And since I'm so enthusiastic (and probably one of the 10 persons on Earth that could possibly be interested by this book), I bought it, and I'm gonna read it, write my own tiny engine and demos based on its wisdom, and explain everything in this page. Let's go!

<p>My code will be published in public domain on <a href="https://github.com/xem/2Dphysics/tree/gh-pages">the 2DPhysics Github repo</a>, and <a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial">a copy of the original Gitlab repo</a> is also present there for reference..

<!--<p>Our library will only cover 2D physics in side-view, with gravity (as in Angry Birds). Top-view 2D physics (as in pool games) are identical, just gravity-less-->
<br>
<br><hr>

<p><b>Chapter 1: Setting up a Canvas</b>
<p>Here we'll keep the HTML code to the absolute minimum: doctype, canvas and script tags.
<p>The canvas is called <b>a</b> and the 2D context <b>c</b>.
<p><pre><code class="lang-html">&lt;!doctype html>
&lt;canvas id=a width=800 height=600 style="background:#eee">&lt;/canvas>
&lt;script>

// Canvas setup
c = a.getContext("2d");

&lt;/script></code></pre>


<p><b>Links:</b>
<br>- Original: 
<a href="https://www.youtube.com/watch?v=H3HYsOvDymU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=2">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/1/Main.html">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/1">source code</a> (0.4kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/1/">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/1">source code</a> (0.1kb)

<br><hr>
<p><i>From now on, the code snippets in each chapter will show what was added or modified in my Javascript code.</i>
<br><hr>

<p><b>Chapter 2: Main loop</b>


<p>I'm going with a fixed 60fps setInterval loop for simplicity, instead of using requestAnimationFrame and computing deltaTime.

<p><pre><code class="lang-js">// Main loop
setInterval(() => {

  // TODO

}, 16);</code></pre>

<p><b>Links:</b>
<br>- Original:
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=3">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/2/Main.html">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/2">source code</a> (1.3kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/2/">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/2">source code</a> (0.2kb)

<br><hr>

<p><b>Chapter 3: Mouse and keyboard events / Simulation class</b>

<p>The golfed code won't use JS classes. User inputs and states are reduced to the bare minimum: left and right mouse buttons, mouse position, and keyboard key presses. Functions added in the loop: update and draw.

<p><pre><code class="lang-js">// Globals
mx = 0, my = 0,     // mouse x, y
mlb = 0, mrb = 0,   // mouse left and right button

// Event listeners
onmousemove = e => {
  mx = e.pageX - a.offsetLeft;
  my = e.pageY - a.offsetTop;
}

onmousedown = e => {
  if(e.button == 0) mlb = 1;
  if(e.button == 2) mrb = 1;
}

onmouseup = e => {
  if(e.button == 0) mlb = 0;
  if(e.button == 2) mrb = 0;
}

a.oncontextmenu = () => {
  return false; // prevent right click dropdown
}

onkeydown = e => {
  console.log(e.code); // Test logs
}

// Update the physics engine
update = () => {
  console.log(mx, my); // Test logs
}

// Render the scene
draw = () => {

  // Reset canvas
  a.width = a.width;

  // Test: draw a black square
  c.fillRect(100, 100, 20, 20);
}

// Main loop
setInterval(() => {
  update();
  draw();
}, 16);</code></pre>

<p><b>Links:</b>
<br>- Original: 
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=4">1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=5">2</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/3/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/3">source code</a> (2.8kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/3/">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/3">source code</a> (0.8kb)

<br><hr>

<p><img src="images/2D-physics/dir.png" style="float:right; margin: 0 20px 20px; width: 200px"><b>Chapter 4: 2D vectors</b>
<p>2D vectors are objects containing two values (x and y).<p>They can represent a point (with x and y coordinates) or a movement (with x and y offsets).
<p>Here again, no JS class. I will reuse the mini vector lib I created for Mini2DPhysics, with some modifications (added normal, lengh squared and copy, removed cross, rotate and distance for now). Each of these functions returns a new Vec2.

<p><pre><code class="lang-js">// 2D vectors
Vec2 = (x, y) => ({x, y});
normalize = v => scale(v, 1 / len(v));
len = v => dot(v, v) ** .5;
len2 = v => dot(v, v);
normal = v => Vec2(v.y, -v.x);
dot = (v, w) => v.x * w.x + v.y * w.y;
copy = v => Vec2(v.x, v.y);
add = (v, w) => Vec2(v.x + w.x, v.y + w.y);
sub = (v, w) => add(v, scale(w, -1));
scale = (v, n) => Vec2(v.x * n, v.y * n);
<!-- //cross = (v, w) => v.x * w.y - v.y * w.x;-->
</code></pre>

<p><b>Links:</b>
<br>- Original:  <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=6">video</a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/4/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/4">source code</a> (3.8kb)
<br>- Mine: 
<a href="https://xem.github.io/2Dphysics/4/">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/4">source code</a> (1.2kb)

<br><hr>

<p><i>At this point, I finally realized that the book I had in my hands was mostly AI-generated and not (or barely) proofread. I already noticed that the same expressions were repeated too many times and the text didn't feel super natural, not to mention the AI cover, but here it gets worse: the text accompanying the source code starts saying that the code makes no sense and is probably wrong. A human author would never say such a thing about his own code. Quite disappointing for a 35€ book! That being said, let's continue reading ir because it may still lead me to a functional 2D physics engine...</i>
<br><hr>

<p><b>Chapter 5: Drawing points and arrows</b>

<p>This chapter explains how do draw bullets (filled arcs), discs (stroked arcs), lines and arrows, for debug purposes.

<p>We'll settle with just two methods: drawPoint and drawLine.

<p><pre><code class="lang-js">// Debug
drawPoint = (center, radius = 5, color = "#888") => {
  c.beginPath();
  c.fillStyle = color;
  c.arc(center.x, center.y, radius, 0, 7);
  c.fill();
  c.closePath();
}

drawLine = (start, end, color = "#888") => {
  c.beginPath();
  c.strokeStyle = color;
  c.moveTo(start.x, start.y);
  c.lineTo(end.x, end.y);
  c.stroke();
  c.closePath();
}

// Render the scene
draw = () => {
  // Reset canvas
  a.width = a.width;

  // Test: draw some shapes
  c.fillRect(100, 100, 20, 20);
  drawPoint(Vec2(200,200));
  drawLine(Vec2(300, 50), Vec2(400, 150));
}</code></pre>

<p><b>Links:</b>
<br>- Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=7">1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=8">2</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=9">3</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/5/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/5">source code</a> (5.6kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/5/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/5">source code</a> (1.6kb)
<p><img src="images/2D-physics/5.png" style="border:2px solid" width=400>

<br><hr>

<p><b>Chapter 6: Shapes</b>

<p>The author creates a generic Shape class to create and draw the future rigid bodies: circles and polygons.
<p>We'll make our own version in Chapter 8.

<p><b>Links:</b>
<br>Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=10">video</a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/6/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/6">source code</a> (7.2 kb)

<br><hr>

<p><b>Chapter 7: Compute and display the centroid of a polygon</b>
<p>We don't need to compute polygon centroids for this project, as all our shapes will be based on circles and Rectangles.

<p><b>Links:</b>
<br>Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=11">1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=12">2</a>,
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/7/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/7">source code</a> (7.2 kb)

<br><hr>

<p><b>Chapter 8: Rotating and moving shapes</b>

<p>Here, we start implementing our shape objects (circle and rectangle) and the methods that allow them to translate (move) and rotate.
<p>- Translations are performed by adding an offset vector to the shape's center (and its vertices, if it's a rectangle).
<p>- 2D rotations (around the origin [0,0]) are performed by applying a 2D rotation matrix on 2D vectors.
<p><img src="images/2D-physics/rot.png" width=400>
<p>- 2D rotations around a pivot point are done by subtracting the pivot point's coordinates from the point, rotating the point around the origin, and adding the pivot point back. A Vec2 function is added to perform these kinds of rotations.

<p><pre><code class="lang-js">// Globals
shapes = [];

// Vector2
rotate = (v, center, angle) => {
  var x = v.x - center.x;
  var y = v.y - center.y;
  return Vec2(
    x * Math.cos(angle) - y * Math.sin(angle) + center.x,
    x * Math.sin(angle) + y * Math.cos(angle) + center.y
  );
}

// Shapes
circle = (center, radius, angle = 0, color = "#ddd") => {
  var shape = {
    type: "circle",
    center: center,
    radius: radius,
    angle: angle,
    color: color
  };
  
  shapes.push(shape);
  return shape;
}

rectangle = (center, width, height, angle = 0, color = "#ddd") => {
  var shape = {
    type: "rectangle",
    center: center,
    width: width,
    height: height,
    angle: angle,
    color: color,

    // Rectangle vertices
    vertices: [
      Vec2(center.x - width / 2, center.y - height / 2), // top left
      Vec2(center.x + width / 2, center.y - height / 2), // top right
      Vec2(center.x + width / 2, center.y + height / 2), // bottom left
      Vec2(center.x - width / 2, center.y + height / 2)  // bottom right
    ]
  };
  
  if(angle) {
    rotateShape(shape, angle);
  }
  shapes.push(shape);
  return shape;
};

// Translate a shape
var translateShape = (shape, offset) => {

  // Move center
  shape.center = add(shape.center, offset);
  
  // Rectangle (move vertices)
  if(shape.type == "rectangle"){
    for(var i in shape.vertices){
      shape.vertices[i] = add(shape.vertices[i], offset);
    }
  }
}

// Rotate a shape around its center
var rotateShape = (shape, angle) => {

  // Update angle
  shape.angle += angle;
  
  // Rectangle (rotate vertices)
  if(shape.type == "rectangle"){
    for(var i in shape.vertices){
      shape.vertices[i] = rotate(shape.vertices[i], shape.center, angle);
    }
  }
}

// Update the physics engine
update = () => {

  // Test: translate and rotate the shapes
  for(i of shapes){
    rotateShape(i, .01);
    translateShape(i, Vec2(.1, .1));
  }
}

// Render the scene
draw = () => {

  // Reset canvas
  a.width = a.width;

  // Draw shapes
  for(i of shapes){
    c.save();
    c.beginPath();
    
    if(i.type == "circle"){
      c.fillStyle = i.color;
      c.translate(i.center.x, i.center.y);
      c.rotate(i.angle);
      c.arc(0, 0, i.radius, 0, 7);
      c.lineTo(0,0);
      c.closePath();
      c.fill();
      c.stroke();
    }
    
    else if(i.type == "rectangle"){
      c.fillStyle = i.color;
      c.moveTo(i.vertices[0].x, i.vertices[0].y);
      c.lineTo(i.vertices[1].x, i.vertices[1].y);
      c.lineTo(i.vertices[2].x, i.vertices[2].y);
      c.lineTo(i.vertices[3].x, i.vertices[3].y);
      c.closePath();
      c.fill();
      c.stroke();
    }

    c.restore();
  }
}

// Demo
circle(Vec2(100, 100), 50);
rectangle(Vec2(400, 100), 50, 100);</code></pre>


<p><b>Links:</b>
<br>- Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=13">1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=14">2</a>,
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/8/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/8">source code</a> (10.8 kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/8/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/8">source code</a> (4.0 kb)
<p><video controls src="images/2D-physics/8.mp4" width=500></video>

<p>Note: a horizontal radius is drawn on the discs (2D physics engines usually do that to make the discs' rotations visible).

<br><hr>

<p><b>Chapter 9: Circle-circle collision detection</b>

<p>Previous chapters were just setup and cosmetics, the real work starts here!
<p>Detecting collisions between two circles is very easy and convenient: if the distance between their centers is smaller than the sum of their radii, they are colliding.
<p>In the code below, a distance function is added for Vec2's and the colliding circles are colored in red.
<p>The collision detection is just one line in the update method, but it will be more complete in the next chapters.

<p><pre><code class="lang-js">// 2D vectors
dist = (v, w) => len(sub(v, w));

// Update the physics engine
update = () => {

  // Test: rotate all shapes
  for(i of shapes){
    rotateShape(i, .01);
  }
  
  // Test: translate each shape
  translateShape(c1, Vec2(.1, .1));
  translateShape(c2, Vec2(-.1, .1));
  
  // Test: detect circle-circle collisions
  if(c1.type == "circle" && c2.type == "circle"){
    if(dist(c1.center, c2.center) &lt; (c1.radius + c2.radius)){
      c1.color = "red";
      c2.color = "red";
    }
    else {
      c1.color = "#ddd";
      c2.color = "#ddd";
    }
  }
}

// Demo
c1 = circle(Vec2(100, 100), 50);
c2 = circle(Vec2(300, 120), 50);</code></pre>


<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=15">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/9/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/9">source code</a> (11.8 kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/9/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/9">source code</a> (4.5 kb)
<p><video controls src="images/2D-physics/9.mp4" width=500></video>

<br><hr>


<p><b>Chapter 10: Collision manifolds</b>

<p>Physics engines use manifolds (temporary objects) to store information about a collision between two shapes: 
<p>- <b>penetration depth</b> (overlap distance)
<p>- <b>collision normal</b> (force direction, from one shape's center to the other)
<p>- <b>contact point</b> (where the collision takes place on the surface of the first shape)

<p>For each pair of shapes that collide, a single manifold object is created. Both shapes will respond to the same manifold: shape A will use the collision normal to move away from shape B, and B will use the inverse of the collision normal to move away from A.

Our debug methods drawPoint and drawLine are used to show the manifold information, in blue.

<p><pre><code class="lang-js">// Globals
manifold = null;

// Update the physics engine
update = () => {

  // (...)
  
  // Test: detect circle-circle collisions
  if(c1.type == "circle" && c2.type == "circle"){
    direction = sub(c2.center, c1.center);
    distance = dist(c1.center, c2.center);
    if(distance &lt; (c1.radius + c2.radius)){
    
      manifold = {
        depth: (c1.radius + c2.radius) - distance,
        normal: normalize(direction),
        contactPoint: add(c1.center, scale(normalize(direction), c1.radius))
      };
      
      c1.color = "red";
      c2.color = "red";
    }
    else {
      c1.color = "#ddd";
      c2.color = "#ddd";
      manifold = null;
    }
  }
}

// Render the scene
draw = () => {

  // (...)

  // Debug: draw manifold
  if(manifold){
    drawPoint(manifold.contactPoint, 5, "blue");
    drawLine(manifold.contactPoint, add(manifold.contactPoint, scale(manifold.normal, 50)), "blue");
  }
}</code></pre>

<p><b>Links:</b>
<br>- Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=">1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=">2</a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/10/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/10">source code</a> (12.2 kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/10/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/10">source code</a> (5.0 kb)
<p><video controls src="images/2D-physics/10.mp4" width=500></video>

<br><hr>



<p><b>Chapter 11: Pushing circles apart</b>

<p>Pushing overlapping shapes apart is the first mechanism that takes action in a collision response.

<p>It's possible to have just one shape being pushed, or both. For example, in this chapter, only one shape (c2) is pushed, while the other (c1) moves diagonally.

<p><pre><code class="lang-js">// Update the physics engine
update = () => {

  // (...)
  
  // Test: translate one shape
  translateShape(c1, Vec2(.2, .2));
  
  // Test: detect circle-circle collisions
  if(c1.type == "circle" && c2.type == "circle"){
    direction = sub(c2.center, c1.center);
    distance = dist(c1.center, c2.center);
    if(distance &lt; (c1.radius + c2.radius)){
    
      manifold = {
        depth: (c1.radius + c2.radius) - distance,
        normal: normalize(direction),
        contactPoint: add(c1.center, scale(normalize(direction), c1.radius))
      };
      
      // Push c2
      c2.center = add(c2.center, scale(manifold.normal, manifold.depth));
      
      c1.color = "red";
      c2.color = "red";
    }
    else {
      c1.color = "#ddd";
      c2.color = "#ddd";
      manifold = null;
    }
  }
}</code></pre>

<p><b>Links:</b>
<br>- Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=">video 1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=">2</a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/11/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/11">source code</a> (13 kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/11/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/11">source code</a> (5.1 kb)

<p><video controls src="images/2D-physics/11.mp4" width=500></video>

<br><hr>

<p><b>Chapter 12: </b>

<p>

<p><pre><code class="lang-js">
</code></pre>

<p><b>Links:</b>
<br>- Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=">video 1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=">2</a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/12/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/12">source code</a> (13.6 kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/12/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/12">source code</a> ( kb)

<br><hr>


<p><b>Chapter 13: </b>

<p>

<p><pre><code class="lang-js">
</code></pre>

<p><b>Links:</b>
<br>- Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=">video 1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=">2</a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/13/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/13">source code</a> (16.4 kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/13/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/13">source code</a> ( kb)

<br><hr>


<p><b>Chapter 14: </b>

<p>

<p><pre><code class="lang-js">
</code></pre>

<p><b>Links:</b>
<br>- Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=">video 1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=">2</a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/14/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/14">source code</a> (19.1 kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/14/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/14">source code</a> ( kb)

<br><hr>


<p><b>Chapter 15: </b>

<p>

<p><pre><code class="lang-js">
</code></pre>

<p><b>Links:</b>
<br>- Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=">video 1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=">2</a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/15/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/15">source code</a> (19.4 kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/15/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/15">source code</a> ( kb)

<br><hr>


<p><b>Chapter 16: </b>

<p>

<p><pre><code class="lang-js">
</code></pre>

<p><b>Links:</b>
<br>- Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=">video 1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=">2</a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/16/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/16">source code</a> (18.9 kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/16/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/16">source code</a> ( kb)

<br><hr>


<p><b>Chapter 17: </b>

<p>

<p><pre><code class="lang-js">
</code></pre>

<p><b>Links:</b>
<br>- Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=">video 1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=">2</a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/17/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/17">source code</a> (19.1 kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/17/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/17">source code</a> ( kb)

<br><hr>



<p><b>Chapter 18: </b>

<p>

<p><pre><code class="lang-js">
</code></pre>

<p><b>Links:</b>
<br>- Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=">video 1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=">2</a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/18/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/18">source code</a> (21.1 kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/18/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/18">source code</a> ( kb)

<br><hr>


<p><b>Chapter 19: </b>

<p>

<p><pre><code class="lang-js">
</code></pre>

<p><b>Links:</b>
<br>- Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=">video 1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=">2</a>
demo <a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/19/Main.html">1</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/19.1/Main.html">2</a>, 
source code <a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/19">1</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/19.1">2</a> (20.8 kb)

<br>- Mine:
<a href="https://xem.github.io/2Dphysics/19/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/19">source code</a> ( kb)

<br><hr>


<p><b>Chapter 20: </b>

<p>

<p><pre><code class="lang-js">
</code></pre>

<p><b>Links:</b>
<br>- Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=">video 1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=">2</a>
demo <a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/20/Main.html">1</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/20.1/Main.html">2</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/20.2/Main.html">3</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/20.3/Main.html">4</a>, 
source code <a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/20">1</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/20">2</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/20">3</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/20">4</a> (22.8 kb)

<br>- Mine:
<a href="https://xem.github.io/2Dphysics/20/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/20">source code</a> ( kb)

<br><hr>



</main>

</div>

<footer></footer>

<script src="../ui.js?v=2024-07"></script>
<script>
header();
footer();
menu();
</script>
<style>
.inline, .inline * { display: inline; padding: 2px !important; }
pre { display: inline-block; min-width: 40vw }
video { max-width: 70vw; border: 2px solid; }
</style>
</body>
</html>