<!doctype html>
<meta charset=utf-8>
<meta name="viewport" content="width=device-width, user-scalable=no">
<html>
<head>
<link rel=stylesheet href="../style.css?v=2024-07">
<title>Maxime Euzière</title>
<base target=_blank>
</head>
<body>

<style>
.twitter-tweet { margin: 30px 0 !important; border: 3px solid #ccc; border-radius: 30px; overflow: hidden; transform: scale(.95)}
ul { padding-left: 15px }
</style>
<style>
.inline, .inline * { display: inline; padding: 2px !important; }
pre { display: inline-block; min-width: 40vw }
video { max-width: 70vw; border: 2px solid; }
pre, code, code * { font-size: 13px !important; line-height: 16px !important; letter-spacing: -.3px }
</style>

<div class="wrapper">

<header></header>

<div id=menu></div>

<main>

<div class=section>

<h2>Golfing a 2D physics engine in JS</h2>
<br><h3>November 2025</h3>
<br><hr>
<p><img src="images/2D-physics/2D.png" style="float:right; margin: 0 20px; width: 200px"><b>Introduction</b>
<p>I have a long love-hate story with physics in JS.
<p>It all started in 2019, when I read <a href="https://link.springer.com/book/10.1007/978-1-4842-2583-7">this 134 pages book about 2D physics</a>, and summarized its contents in just <a href="https://xem.github.io/articles/images/js1k19/2.png">9 pages</a> on my little notepad.
<p>I used that to create a 1.57kb lib called <a href="https://xem.github.io/codegolf/mini2Dphysics.html">Mini2DPhysics</a>, the JS1K entry <a href="https://xem.github.io/codegolf/emojysics.html">Emojysics</a> in 2019 and the JS13kGames entry <a href="https://js13kgames.com/2024/games/o-hiii-bad-skatepark">O HIII BAD SKATEPARK</a> in 2024.
<p>The problem was that this book, as every book I could find at the time, didn't go beyond basic interactions between discs and rectangles (and it definitely didn't need so many pages to do that).
<p>Then <a href="https://link.springer.com/book/10.1007/978-1-4842-7377-7">this 599 pages book</a> released in 2022 by the same editor and some of the original authors, managed to be even more verbose in almost every aspect of 2D game mechanics, except one: advanced physics. And when I say "advanced physics", I'm not asking for really complex stuff, I just want to learn springs, fixed joints, hinge joints, and how to optimize for speed and stability.
<p>In 2021, 2022, 2023, 2024 and 2025 I tried many times to learn <a href="https://xem.github.io/articles/3D-physics.html">3D physics</a> because <a href="images/2D-physics/3D.jpg">a lot of good books actually cover this topic</a>, but I haven't managed to completely implement any of them in JS (so far)... which was quite frustrating. (but stay tuned... I will be back!)
<p>Finally, in October 2025, after completing a new edition of <a href="https://xem.github.io/articles/js13k25.html">JS13KGames</a>, I randomly typed "2D physics JS" on Google and stumbled upon <a href="https://www.reddit.com/r/gamedev/comments/1afq10l/i_created_a_tutorial_about_how_everybody_can/">this 2024 Reddit post</a> announcing a complete <a href="https://www.youtube.com/watch?v=D3oQ8mUF_84&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr">Youtube playlist</a> dedicated to learning 2D physics in JS, with <a href="https://gitlab.com/Marcel.K/tutorials/-/tree/main/2D%20Physics%20Engine">complete source code on Gitlab</a>... I may have found the holy grail!

<p>In this page, I will follow each chapter of the playlist, show how I implemented my own mini 2D engine based on its source code, and how I enhanced a few things. My code will be published in public domain on <a href="https://github.com/xem/2Dphysics/tree/gh-pages">the 2DPhysics Github repo</a>, and <a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial">a copy of the original Gitlab repo</a> is also present there for reference..

<p>I also ended up buying a copy of <a href="https://www.amazon.fr/dp/B0FL1K2ZZ5">the physical book released in August 2025</a>, which is (sadly) just a line-by-line code explanation written by an AI, with a lot of mistakes. I won't mention it here, but I still really encourage the author to pursue his work (and teach us how to do 3D physics in JS next!), because my 2Dphysics engine mostly exists thanks to him! And if he makes a new edition of his book with better page layout, more legible text and some illustrations, I will gladly buy it too! &lt;3

<br><br><hr>



<p><b>Chapter 1: Setting up a Canvas</b>
<p>Here we'll keep the HTML code to the absolute minimum: doctype, canvas and script tags.
<p>The canvas is called <b>a</b> and the 2D context <b>c</b>.
<p><pre><code class="lang-html">&lt;!doctype html>
&lt;canvas id=a width=800 height=600 style="background:#eee">&lt;/canvas>
&lt;script>

// Canvas setup
c = a.getContext("2d");

&lt;/script></code></pre>


<p><b>Links:</b>
<br>- Original: 
<a href="https://www.youtube.com/watch?v=H3HYsOvDymU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=2">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/1/Main.html">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/1">source code</a> (0.4kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/1/">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/1">source code</a> (0.1kb)

<br><hr>
<p><i>From now on, the code snippets in each chapter show what was added or modified in my Javascript code.</i>
<br><hr>






<p><b>Chapter 2: Main loop</b>


<p>Let's create a fixed 60fps setInterval loop, for simplicity.
<p>Indeed, many 2D engines actually use requestAnimationFrame and deltaTime, but it's more verbose, non-deterministic, and tends to be unpredictable on screens with high refresh rates.

<p><pre><code class="lang-js">// Main loop
setInterval(() => {
  // TODO

}, 16);</code></pre>

<p><b>Links:</b>
<br>- Original:
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=3">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/2/Main.html">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/2">source code</a> (1.3kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/2/">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/2">source code</a> (0.2kb)

<br><hr>





<p><b>Chapter 3: Mouse and keyboard events / Simulation class</b>

<p>The golfed code won't use JS classes. User inputs and states are reduced to the bare minimum: left and right mouse buttons, mouse position, and keyboard key presses. Two functions added in the loop: <b>update</b> and <b>draw</b>.

<p><pre><code class="lang-js">// Globals
mx = 0, my = 0,     // mouse x, y
mlb = 0, mrb = 0,   // mouse left and right button

// Event listeners
onmousemove = e => {
  mx = e.pageX - a.offsetLeft;
  my = e.pageY - a.offsetTop;
}

onmousedown = e => {
  if(e.button == 0) mlb = 1;
  if(e.button == 2) mrb = 1;
}

onmouseup = e => {
  if(e.button == 0) mlb = 0;
  if(e.button == 2) mrb = 0;
}

a.oncontextmenu = () => {
  return false; // prevent right click dropdown
}

onkeydown = e => {
  console.log(e.code); // Test logs
}

// Update the physics engine
update = () => {

  console.log(mx, my); // Test logs
}

// Render the scene
draw = () => {

  // Reset canvas
  a.width = a.width;

  // Test: draw a black square
  c.fillRect(100, 100, 20, 20);
}

// Main loop
setInterval(() => {
  update();
  draw();
}, 16);</code></pre>

<p><b>Links:</b>
<br>- Original: 
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=4">1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=5">2</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/3/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/3">source code</a> (2.8kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/3/">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/3">source code</a> (0.8kb)

<br><hr>





<p><img src="images/2D-physics/dir.png" style="float:right; margin: 0 20px 20px; width: 200px">
<b>Chapter 4: 2D vectors</b>
<p>2D vectors are objects containing two values (<b>x</b> and <b>y</b>).<p>They can represent a point (with x and y coordinates) or a movement (with x and y offsets).
<p>Here again, no JS class. I will reuse the mini vector lib I created for Mini2DPhysics, with a few modifications to match the tuto's conventions.

<p><pre><code class="lang-js">// 2D vectors
Vec2 = (x, y) => ({x, y});
normalize = v => scale(v, 1 / len(v));
len = v => dot(v, v) ** .5;
len2 = v => dot(v, v);
normal = v => Vec2(v.y, -v.x);
dot = (v, w) => v.x * w.x + v.y * w.y;
copy = v => Vec2(v.x, v.y);
add = (v, w) => Vec2(v.x + w.x, v.y + w.y);
sub = (v, w) => add(v, scale(w, -1));
scale = (v, n) => Vec2(v.x * n, v.y * n);
</code></pre>

<p><b>Links:</b>
<br>- Original:  <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=6">video</a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/4/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/4">source code</a> (3.8kb)
<br>- Mine: 
<a href="https://xem.github.io/2Dphysics/4/">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/4">source code</a> (1.2kb)

<br><hr>






<p><b>Chapter 5: Drawing points and arrows</b>

<p>This chapter explains how do draw bullets (filled arcs), discs (stroked arcs), lines and arrows, for debug purposes.

<p>We'll settle with just two methods: <b>drawPoint</b> and <b>drawLine</b>.

<p><pre><code class="lang-js">// Debug
drawPoint = (center, radius = 5, color = "#888") => {
  c.beginPath();
  c.fillStyle = color;
  c.arc(center.x, center.y, radius, 0, 7);
  c.fill();
  c.closePath();
}

drawLine = (start, end, color = "#888") => {
  c.beginPath();
  c.lineWidth = 3;
  c.strokeStyle = color;
  c.moveTo(start.x, start.y);
  c.lineTo(end.x, end.y);
  c.stroke();
  c.closePath();
}

// Render the scene
draw = () => {

  // Reset canvas
  a.width = a.width;

  // Test: draw some shapes
  c.fillRect(100, 100, 20, 20);
  drawPoint(Vec2(200,200));
  drawLine(Vec2(300, 50), Vec2(400, 150));
}</code></pre>

<p><b>Links:</b>
<br>- Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=7">1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=8">2</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=9">3</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/5/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/5">source code</a> (5.6kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/5/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/5">source code</a> (1.7kb)
<p><img src="images/2D-physics/5.png" style="border:2px solid" width=400>

<br><hr>






<p><b>Chapter 6: Shapes</b>

<p>This chapter introduces a generic Shape class to create and draw the future rigid bodies: circles and polygons.
<p>We'll make our own version in Chapter 8.

<p><b>Links:</b>
<br>Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=10">video</a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/6/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/6">source code</a> (7.2 kb)

<br><hr>






<p><b>Chapter 7: Compute and display the centroid of a polygon</b>
<p>We don't need to compute polygon centroids for this project, as all our shapes will be based on circles and rectangles which already have a defined center point.

<p><b>Links:</b>
<br>Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=11">1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=12">2</a>,
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/7/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/7">source code</a> (7.2 kb)

<br><hr>






<p><b>Chapter 8: Rotating and moving shapes</b>

<p>Here, we start implementing our shape objects (circles and rectangles) and the methods that allow them to translate (move) and rotate.
<p>- Translations are performed by adding an offset vector to the shape's center (and all its vertices, if it's a rectangle).
<p>- 2D rotations (around the origin [0,0]) are performed by applying a 2D rotation matrix on 2D vectors.
<p><img src="images/2D-physics/rot.png" width=400>
<p>- 2D rotations around a pivot point are done by subtracting the pivot point's coordinates from the point, rotating the point around the origin, and adding the pivot point back. A Vec2 function is added to perform these kinds of rotations.

<p>A horizontal radius is drawn on the discs (2D physics engines usually do that to make the discs' rotations visible).

<p>Realistic rotations based on gravity and inertia will beintroduced in chapter 24.

<p><pre><code class="lang-js">// Globals
shapes = [];

// Vector2
rotate = (v, center, angle) => {
  var x = v.x - center.x;
  var y = v.y - center.y;
  return Vec2(
    x * Math.cos(angle) - y * Math.sin(angle) + center.x,
    x * Math.sin(angle) + y * Math.cos(angle) + center.y
  );
}

// Shapes
circle = (center, radius, angle = 0, color = "#888") => {
  shape = {
    type: "circle",
    center: center,
    radius: radius,
    angle: angle,
    color: color
  };
  
  shapes.push(shape);
  return shape;
}

rectangle = (center, width, height, angle = 0, color = "#888") => {
  shape = {
    type: "rectangle",
    center: center,
    width: width,
    height: height,
    angle: angle,
    color: color,

    // Rectangle vertices
    vertices: [
      Vec2(center.x - width / 2, center.y - height / 2), // top left
      Vec2(center.x + width / 2, center.y - height / 2), // top right
      Vec2(center.x + width / 2, center.y + height / 2), // bottom left
      Vec2(center.x - width / 2, center.y + height / 2)  // bottom right
    ]
  };
  
  if(angle) {
    rotateShape(shape, angle);
  }
  shapes.push(shape);
  return shape;
};

// Translate a shape
translateShape = (shape, offset) => {

  // Move center
  shape.center = add(shape.center, offset);
  
  // Rectangle (move vertices)
  if(shape.type == "rectangle"){
    for(var i in shape.vertices){
      shape.vertices[i] = add(shape.vertices[i], offset);
    }
  }
}

// Rotate a shape around its center
rotateShape = (shape, angle) => {

  // Update angle
  shape.angle += angle;
  
  // Rectangle (rotate vertices)
  if(shape.type == "rectangle"){
    for(var i in shape.vertices){
      shape.vertices[i] = rotate(shape.vertices[i], shape.center, angle);
    }
  }
}

// Update the physics engine
update = () => {

  // Test: translate and rotate the shapes
  for(var i of shapes){
    rotateShape(i, .01);
    translateShape(i, Vec2(.2, .2));
  }
}

// Render the scene
draw = () => {

  // Reset canvas
  a.width = a.width;

  // Draw shapes
  for(var i of shapes){
    c.save();
    c.beginPath();
    
    if(i.type == "circle"){
      c.fillStyle = i.color;
      c.translate(i.center.x, i.center.y);
      c.rotate(i.angle);
      c.arc(0, 0, i.radius, 0, 7);
      c.lineTo(0,0);
      c.closePath();
      c.fill();
      c.stroke();
    }
    
    else if(i.type == "rectangle"){
      c.fillStyle = i.color;
      c.moveTo(i.vertices[0].x, i.vertices[0].y);
      c.lineTo(i.vertices[1].x, i.vertices[1].y);
      c.lineTo(i.vertices[2].x, i.vertices[2].y);
      c.lineTo(i.vertices[3].x, i.vertices[3].y);
      c.closePath();
      c.fill();
      c.stroke();
    }

    c.restore();
  }
}

// Demo
circle(Vec2(100, 100), 60);
rectangle(Vec2(250, 100), 60, 100);</code></pre>


<p><b>Links:</b>
<br>- Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=13">1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=14">2</a>,
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/8/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/8">source code</a> (10.8 kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/8/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/8">source code</a> (4.1 kb)
<p><video controls src="images/2D-physics/8.mp4?v=3" width=500></video>



<br><hr>






<p><b>Chapter 9: Circle-circle collision detection</b>

<p>Previous chapters were just setup and cosmetics, the real work starts here!
<p>A physics engine has two main tasks: collision detection and collision response. Let's start with detection.
<p>Since all our shapes will be either circles or rectangles, we need to detect three kinds of collisions: circle-circle, circle-rectangle and rectangle-rectangle.
<p>We'll start by the easiest collision detection, between two circles: if the distance between their centers is smaller than the sum of their radii, they are colliding.
<p>In the code below, two circles are created (<b>c1</b> and <b>c2</b>), a distance function <b>dist</b> is added for Vec2's and when the circles collide, they get colored in red. The collision detection is just one line in the update method, but it will be more complete in the next chapters.

<p><pre><code class="lang-js">// 2D vectors
dist = (v, w) => len(sub(v, w));

// Update the physics engine
update = () => {

  // Test: rotate all shapes
  for(var i of shapes){
    rotateShape(i, .01);
  }
  
  // Test: translate each shape
  translateShape(c1, Vec2(-.2, .2));
  translateShape(c2, Vec2(.2, .2));
  
  // Test: detect circle-circle collisions
  if(c1.type == "circle" && c2.type == "circle"){
    if(dist(c1.center, c2.center) &lt; (c1.radius + c2.radius)){
      c1.color = "red";
      c2.color = "red";
    }
    else {
      c1.color = "#888";
      c2.color = "#888";
    }
  }
}

// Demo
c1 = circle(Vec2(220, 140), 60);
c2 = circle(Vec2(80, 100), 60);</code></pre>


<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=15">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/9/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/9">source code</a> (11.8 kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/9/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/9">source code</a> (4.5 kb)
<p><video controls src="images/2D-physics/9.mp4?v=3" width=500></video>

<br><hr>





<p><b>Chapter 10: Collision manifolds</b>

<p>Physics engines use manifolds (temporary objects) to store information about a collision between two shapes. They include: 
<p>- a <b>penetration depth</b> (overlap distance)
<p>- a <b>collision normal</b> (the force's direction, from one shape's center to the other)
<p>- and a <b>contact point</b> (where the collision takes place on the surface of the first shape)

<p>For each pair of shapes that collide, a single manifold object is created. Both shapes will respond to the same manifold: shape A will use the collision normal to move away from shape B, and B will use the inverse of the collision normal to move away from A.

<p>Here, our debug methods drawPoint and drawLine are used to show the manifold information, in blue.

<p><pre><code class="lang-js">// Globals
manifold = null;

// Update the physics engine
update = () => {

  // (...)
  
  // Test: detect circle-circle collisions
  if(c1.type == "circle" && c2.type == "circle"){
    direction = sub(c2.center, c1.center);
    distance = dist(c1.center, c2.center);
    if(distance &lt; (c1.radius + c2.radius)){
    
      manifold = {
        depth: (c1.radius + c2.radius) - distance,
        normal: normalize(direction),
        contactPoint: add(c1.center, scale(normalize(direction), c1.radius))
      };
      
      c1.color = "red";
      c2.color = "red";
    }
    else {
      c1.color = "#888";
      c2.color = "#888";
      manifold = null;
    }
  }
}

// Render the scene
draw = () => {

  // (...)

  // Debug: draw manifold
  if(manifold){
    drawPoint(manifold.contactPoint, 5, "#04F");
    drawLine(manifold.contactPoint, add(manifold.contactPoint, scale(manifold.normal, 50)), "#04F");
  }
}

// Demo (inversed the circles temporarily to display c1 on top of c2)
c2 = circle(Vec2(80, 100), 60);
c1 = circle(Vec2(220, 140), 60);</code></pre>

<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=16">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/10/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/10">source code</a> (12.2 kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/10/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/10">source code</a> (5.0 kb)
<p><video controls src="images/2D-physics/10.mp4?v=3" width=500></video>

<br><hr>






<p><b>Chapter 11: Pushing circles apart</b>

<p>Pushing overlapping shapes apart is the first mechanism that takes action in a collision response.

<p>It's possible to have just one shape being pushed, or both, depending on their mass or mobility.

<p>For example, in this chapter, only one shape (c2) is pushed, while the other (c1) moves diagonally.

<p>This pushing will be implemented more rigorously in chapter 23.

<p><pre><code class="lang-js">// Update the physics engine
update = () => {

  // (...)
  
  // Test: translate one shape
  translateShape(c1, Vec2(.2, .2));
  
  // Test: detect circle-circle collisions
  if(c1.type == "circle" && c2.type == "circle"){
    direction = sub(c2.center, c1.center);
    distance = dist(c1.center, c2.center);
    if(distance &lt; (c1.radius + c2.radius)){
    
      manifold = {
        depth: (c1.radius + c2.radius) - distance,
        normal: normalize(direction),
        contactPoint: add(c1.center, scale(normalize(direction), c1.radius))
      };
      
      // Push c2
      c2.center = add(c2.center, scale(manifold.normal, manifold.depth));
      
      c1.color = "red";
      c2.color = "red";
    }
    else {
      c1.color = "#888";
      c2.color = "#888";
      manifold = null;
    }
  }
}</code></pre>

<p><b>Links:</b>
<br>- Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=17">1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=18">2</a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/11/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/11">source code</a> (13 kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/11/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/11">source code</a> (5.1 kb)

<p><video controls src="images/2D-physics/11.mp4?v=3" width=500></video>

<br><hr>






<p><b>Chapter 12: Compute polygons normals</b>

<p>For rectangles (and other polygons), each edge (side) needs a normal vector, perpendicular to it and facing outwards.
<p>The normals stay the same when the rectangle is translated, but they must be recomputed when it's rotated.

<p><img src="images/2D-physics/12.png" style="border: 2px solid">

<p>In the code below, all the code specific to circles is temporarily removed.
<p>A rectangle <b>r1</b> is introduced. Its normals are represented in green.

<p><pre><code class="lang-js">// shapes
rectangle = (center, width, height, angle = 0, color = "#888") => {
  
  // (...)
  
  // Normals
  calcNormals(shape);
  
  shapes.push(shape);
  return shape;
};

// Rotate a shape around its center (angle in radians)
rotateShape = (shape, angle) => {

  // Update angle
  shape.angle += angle;
  
  // Rectangle (rotate vertices and recompute normals)
  if(shape.type == "rectangle"){
    for(var i in shape.vertices){
      shape.vertices[i] = rotate(shape.vertices[i], shape.center, angle);
    }
    calcNormals(shape);
  }
}

// Compute the normals of a polygon
calcNormals = shape => {
  shape.normals = [];
  for(var i = 0; i &lt; shape.vertices.length; i++){
    shape.normals.push(normal(normalize(sub(shape.vertices[(i + 1) % shape.vertices.length], shape.vertices[i]))));
  }
}

// Render the scene
draw = () => {

  // Reset canvas
  a.width = a.width;

  // Draw shapes
  for(var i of shapes){
    c.save();
    c.beginPath();
    
    if(i.type == "circle"){
      
      // (...)
      
    }
    
    else if(i.type == "rectangle"){
      
      // (...)
      
      // Test: draw normals
      for(j = 0; j &lt; 4; j++){
        middle = scale(sub(i.vertices[(j + 1) % i.vertices.length], i.vertices[j]), .5);
        drawLine(add(i.vertices[j], middle), add(add(i.vertices[j], middle), scale(i.normals[j], 30)), "green");
      }
    }

    c.restore();
  }

  // (...)

}</code></pre>

<p><b>Links:</b>
<br>- Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=19">1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=20">2</a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/12/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/12">source code</a> (13.6 kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/12/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/12">source code</a> (4.9 kb)

<p><video controls src="images/2D-physics/12.mp4?v=3" width=400></video>

<br><hr>







<p><b>Chapter 13: Rectangle-rectangle collisions</b>

<p>Collisions between rectangles (or any convex polygons) are detected using the Seprating-Axis Theorem (SAT):
<p><img src="images/2D-physics/13.png" style="border:2px solid" width=500>
<p>The idea is to project a pair of rectangles on different axis (one axis for each edge of each polygon to test).
<p>- If the projections are separated on at least one axis, the shapes are definitely not colliding.
<p>- If the projections overlap on every axis, the shapes collide. We use the axis with the smallest overlap to build the collision manifold.
<p>Contrary to circle-circle collisions, the collision normal does not point to the center of the other shape: it is perpendicular to the rectangle edge that has the smallest penetration depth.
<p>In this chapter, we create three rectangles, and for each pair of rectangles, if a collision is detected, both shapes get pushed away from each other with the same force. The manifolds are put in an array, drawn in blue, and are attached to the first vertex of the axis that detects the collision.

<p><pre><code class="lang-js">// Globals
manifolds = [];

// SAT: test two rectangles against each other's axis and choose the minimal penetration depth
rectangleRectangleCollision = (r1, r2) => {

  var contact = null;
  
  // Check all axes from rectangle A against rectangle B
  var contactA = getContactPoint(r1, r2);
  if(contactA == null) return null;
  
  // Check all axes from rectangle B against rectangle A
  var contactB = getContactPoint(r2, r1);
  if(contactB == null) return null;
  
  // Choose the smallest penetration depth (most restrictive axis)
  if(contactA.depth &lt; contactB.depth){
    contact = contactA;
  }
  else {
    contact = contactB;
    // Reverse the normal direction to ensure it points from A to B
    contact.normal = scale(contact.normal, -1);
  }
  
  // Return the final contact information (depth, normal, contact point)
  return contact;
}

// SAT: Test all normals of rectangle 1 as potential separating axes
getContactPoint = (r1, r2) => {

  var contact = null;
  var minDepth = Number.MAX_VALUE;
  var supportPoint = null;

  // For each normal of rectangle 1
  for(var i = 0; i &lt; r1.normals.length; i++){
    // Find which vertex of rectangle 2 penetrates deepest along this normal
    supportPoint = findSupportPoint(r1.normals[i], r1.vertices[i], r2.vertices);

    // If there is no overlap along this normal, there is no collision
    if(supportPoint == null) return null;

    // Keep the smallest penetration depth found so far
    if(supportPoint.depth &lt; minDepth){
      minDepth = supportPoint.depth;

      // Store the contact information for this axis
      contact = {
        depth: minDepth,              // penetration distance
        normal: r1.normals[i],        // collision normal (axis of penetration)
        contactPoint: supportPoint.vertex // point of contact on rectangle 2
      };
    }
  }
  // Return the axis with the minimum overlap
  return contact;
}

// SAT: Find which vertex from the other rectangle penetrates the deepest along a given axis
findSupportPoint = (normalOnEdge, pointOnEdge, otherPolygonVertices) => {

  var maxDepth = 0;
  var supportPoint = null;
  var depth = null;

  // For each vertex of the other rectangle
  for(var i = 0; i &lt; otherPolygonVertices.length; i++){
    // Project the vertex onto the axis defined by the current normal
    // The 'depth' here represents how far the vertex is behind the edge (penetration distance)
    depth = dot(sub(otherPolygonVertices[i], pointOnEdge), scale(normalOnEdge, -1));

    // Keep the vertex that penetrates the most (maximum depth)
    if(depth > maxDepth){
      maxDepth = depth;
      supportPoint = {
        vertex: otherPolygonVertices[i], // the vertex with the deepest penetration
        depth: depth                     // its penetration distance
      };
    }
  }

  // Return the vertex that is deepest along this normal
  return supportPoint;
}

// Update the physics engine
update = () => {

  var push, manifold;
  
  // Reset manifolds
  manifolds = [];
  
  // Reset shapes colors
  for(var i of shapes){
    i.color = "#888";
  }

  // Test: rotate a shape
  rotateShape(r1, -.01);
  
  // Test: translate a shape
  translateShape(r1, Vec2(.2, .2));
  
  // Consider all pairs of shapes
  for(var i = 0; i &lt; shapes.length; i++){
    for(var j = i; j &lt; shapes.length; j++){
      if(i != j){
        
        // Detect rectangle-rectangle collisions
        if(shapes[i].type == "rectangle" && shapes[j].type == "rectangle"){
          manifold = rectangleRectangleCollision(shapes[i], shapes[j]);
          if(manifold){
            shapes[i].color = "red";
            shapes[j].color = "red";
            push = scale(manifold.normal, manifold.depth * 0.5);
            translateShape(shapes[j], push);
            translateShape(shapes[i], scale(push, -1));
            manifolds.push(manifold);
          }
        }
      }
    }
  }
}

// Render the scene
draw = () => {

  
  // (...)
  
  // Debug: draw manifolds
  for(var i of manifolds){
    drawPoint(i.contactPoint, 5, "#04F");
    drawLine(i.contactPoint, add(i.contactPoint, scale(i.normal, 50)), "#04F");
  }
}

// Demo
r1 = rectangle(Vec2(100, 60), 100, 50);
r2 = rectangle(Vec2(180, 170), 75, 75);
r3 = rectangle(Vec2(240, 150), 20, 50);</code></pre>

<p><b>Links:</b>
<br>- Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=21">1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=22">2</a>
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=23">3</a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/13/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/13">source code</a> (16.4 kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/13/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/13">source code</a> (8.5 kb)

<p><video controls src="images/2D-physics/13.mp4?v=3" width=500></video>
<br><hr>





<p><b>Chapter 14: Circle-rectangle collisions</b>

<p>To detect a collision between a rectangle and a circle, we need to find which point of the rectangle is closest to the center of the circle. This point can be a corner, or any point on one edge of the rectangle.

<p><img src="images/2D-physics/14.png" style="border:2px solid">

<p><pre><code class="lang-js">// Detect collision between a circle and a rectangle
circleRectangleCollision = (circle, rectangle) => {

  // First, try to detect a collision between the circle and the rectangle's edges
  var contact = circleVsRectangleEdges(circle, rectangle);

  // If no edge collision was found, test against the rectangle's corners
  if(!contact){
    contact = circleVsRectangleCorners(circle, rectangle);
  }

  // Return the resulting contact information (if any)
  return contact;
}

// Test collision between a circle and the edges of a rectangle
circleVsRectangleEdges = (circle, rectangle) => {

  var nearestEdgeVertex = null;
  var nearestEdgeNormal = null;
  var dirToNext, circleDirToNextProjection, circleDirToNormalProjection;

  // Loop over each edge of the rectangle
  for(var i = 0; i &lt; rectangle.vertices.length; i++){
    // Vector from the current vertex of the rectangle to the circle center
    vertToCircle = sub(circle.center, rectangle.vertices[i]);

    // Direction vector along the current edge
    dirToNext = sub(rectangle.vertices[(i + 1) % rectangle.vertices.length], rectangle.vertices[i]);

    // Project the circle center direction onto the edge direction
    circleDirToNextProjection = dot(vertToCircle, normalize(dirToNext));

    // Project the circle center direction onto the edge normal
    circleDirToNormalProjection = dot(vertToCircle, rectangle.normals[i]);

    // Check if the circle center is within the edge segment bounds
    // (projection along the edge is between 0 and edge length)
    // and on the "inner" side of the edge (normal projection ≥ 0)
    if(circleDirToNormalProjection >= 0 && circleDirToNextProjection > 0 && circleDirToNextProjection &lt; len(dirToNext)){
      // This edge is the nearest potential collision candidate
      nearestEdgeNormal = rectangle.normals[i];
      nearestEdgeVertex = rectangle.vertices[i];
    }
  }

  // If no valid edge was found, no collision is possible along edges
  if(nearestEdgeNormal == null || nearestEdgeVertex == null){
    return null;
  }

  // Compute how far the circle center is from the edge along the normal
  var projectionToEdgeNormal = dot(nearestEdgeNormal, sub(circle.center, nearestEdgeVertex));

  // If the circle overlaps the edge (distance &lt; radius), report a collision
  if(projectionToEdgeNormal - circle.radius &lt; 0){
    return {
      // Penetration depth (how far the circle intrudes)
      depth: -(projectionToEdgeNormal - circle.radius),

      // Normal points from rectangle toward the circle
      normal: scale(nearestEdgeNormal, -1),

      // Approximate contact point on the circle’s perimeter
      contactPoint: add(circle.center, scale(nearestEdgeNormal, -circle.radius))
    };
  }

  // No edge collision
  return null;
}

// Test collision between a circle and the corners of a rectangle
circleVsRectangleCorners = (circle, rectangle) => {

  var dirToCircleCenter;

  // Loop over all rectangle vertices
  for(var i = 0; i &lt; rectangle.vertices.length; i++){
    // Vector from the circle center to the current corner
    dirToCircleCenter = sub(rectangle.vertices[i], circle.center);

    // If the corner is inside the circle’s radius, a collision occurs
    if(len2(dirToCircleCenter) &lt; (circle.radius ** 2)){
      return {
        // Penetration depth (difference between radius and distance)
        depth: circle.radius - len(dirToCircleCenter),

        // Normal pointing from circle center toward the corner
        normal: normalize(dirToCircleCenter),

        // Contact point is the rectangle corner itself
        contactPoint: rectangle.vertices[i]
      };
    }
  }

  // No corner inside the circle → no collision
  return null;
}

// Update the physics engine
update = () => {

  var push, manifold, circle, rectangle;
  
  // Reset manifolds
  manifolds = [];
  
  // Reset shapes colors
  for(var i of shapes){
    i.color = "#888";
  }

  // Test: rotate a shape
  rotateShape(r1, -.01);
  
  // Test: translate a shape
  translateShape(r1, Vec2(.2, .1));
  
  // Consider all pairs of shapes
  for(var i = 0; i &lt; shapes.length; i++){
    for(var j = i; j &lt; shapes.length; j++){
      if(i != j){
        
        // Detect circle-rectangle collisions
        if(shapes[i].type == "rectangle" && shapes[j].type == "circle"){
          rectangle = shapes[i];
          circle = shapes[j];
          manifold = circleRectangleCollision(circle, rectangle);
        }
        
        else if(shapes[i].type == "circle" && shapes[j].type == "rectangle"){
          circle = shapes[i];
          rectangle = shapes[j];
          manifold = circleRectangleCollision(circle, rectangle);
        }
        
        // Collision response
        if(manifold){
          shape1.color = "red";
          shape2.color = "red";
          push = scale(manifold.normal, manifold.depth * 0.5);
          translateShape(rectangle, push);
          translateShape(circle, scale(push, -1));
          manifolds.push(manifold);
        }
      }
    }
  }
}

// Demo
r1 = rectangle(Vec2(80, 60), 120, 50);
c2 = circle(Vec2(180, 130), 50);</code></pre>

<p><b>Links:</b>
<br>- Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=24">1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=25">2</a>
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=26">3</a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/14/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/14">source code</a> (19.1 kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/14/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/14">source code</a> (12.5 kb)
<p><video controls src="images/2D-physics/14.mp4?v=3" width=500></video>

<br><hr>







<p><b>Chapter 15: RigidBody</b>

<p>This chapter introduces a rigidBody class with new properties: <b>mass</b>, <b>invMass</b>, <b>velocity</b> and <b>forceAccumulator</b>.

<p>For simplicity, we will simply add them to our circles and rectangles.

<p>- Mass is a number representing the object's weight. 

<p>- Velocity is a Vec2 representing the object's speed (evolution of position over time).

<p>- Acceleration is the evolution of velocity over time.

<p>- According to Newton's 2nd law of motion (F = ma or a = F/m), the acceleration of an object is equal to the sum of the forces applied to it (pushes, gravity, friction...), divided by its mass.
<br>A forceAccumulator Vec2 attribute is introduced to represent this sum of forces. It will be reset after each frame.
<br>An invMass (1/mass) attribute is introduced specifically to avoid doing the "F/m" division repeatedly.

<p><pre><code class="lang-js">// Shapes
circle = (center, radius, mass = 1, angle = 0, velocity = Vec2(0, 0), color = "#888") => {
  shape = {
    type: "circle",
    center: center,
    radius: radius,
    mass: mass,
    invMass: 1 / mass,
    velocity: velocity,
    angle: angle,
    forceAccumulator: Vec2(0, 0),
    color: color
  };
  
  shapes.push(shape);
  return shape;
}

rectangle = (center, width, height, mass = 1, angle = 0, velocity = Vec2(0, 0), color = "#888") => {
  shape = {
    type: "rectangle",
    center: center,
    width: width,
    height: height,
    mass: mass,
    invMass: 1 / mass,
    velocity: velocity,
    angle: angle,
    forceAccumulator: Vec2(0, 0),
    color: color,

    // (...)
};</code></pre>

<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=27">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/15/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/15">source code</a> (19.4 kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/15/">demo</a> (nothing new to see there), <a href="https://github.com/xem/2Dphysics/tree/gh-pages/15">source code</a> (12.7 kb),

<br><hr>






<p><b>Chapter 16: Combining RigidBody and Shapes</b>

<p>No need to do that because our shapes are already functional rigid bodies.

<p><b>Links:</b>
<br>Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=28">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/16/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/16">source code</a> (18.9 kb)

<br><hr>






<p><b>Chapter 17: Integration</b>

<p>Integration consists in computing the shapes' acceleration, velocity and position at the end of a frame.

<p>The code below uses the semi-implicit Euler method, which is a good compromise between simplicity and stability.

<p>According to Newton's first law of motion, objects keep the same trajectory and speed as long as they don't encounter another force.

<p>Since integration is implemented, and friction and gravity are not yet implemented, the shapes will keep a constant speed after a collision.

<p><pre><code class="lang-js">// Globals
deltaTime = 1;

// Shape integration
integrate = (shape, deltaTime) => {

  // compute acceleration
  var acceleration = scale(shape.forceAccumulator, shape.invMass);
  
  // apply acceleration to velocity
  shape.velocity = add(shape.velocity, scale(acceleration, 1));
  
  // apply velocity to position
  translateShape(shape, scale(shape.velocity, 1));
  
  // reset force accumulator
  shape.forceAccumulator = Vec2(0, 0);
}

// Update the physics engine
update = () => {

  // (...)
        
  // Collision response
  if(manifold){
    shape1.color = "red";
    shape2.color = "red";
    push = scale(manifold.normal, manifold.depth * 0.5);
    rectangle.forceAccumulator = add(rectangle.forceAccumulator, push);
    circle.forceAccumulator = add(circle.forceAccumulator, scale(push, -1));
    manifolds.push(manifold);
  }

  // (...)
  
  // Integration
  for(i of shapes){
    integrate(i, deltaTime);
  }
}</code></pre>

<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=29">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/17/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/17">source code</a> (19.1 kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/17/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/17">source code</a> (13.3 kb)
<p><video controls src="images/2D-physics/17.mp4?v=3" width=500></video>

<br><hr>






<p><b>Chapter 18: Other integration methods</b>

<p>This chapter explores other ways to integrate rigid bodies. We'll ignore it for now.

<p><b>Links:</b>
<br>Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=30">1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=31">2</a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/18/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/18">source code</a> (21.1 kb)

<br><hr>







<p><b>Chapter 19: Bouncing balls</b>

<p>Let's make balls behave realistically: gravity, bouncing, friction and damping (velocity attenuation over time)

<p>The bouncing on the ground is currently implemented by inverting the ball's velocity when it reaches a certain height threshold.

<p><pre><code class="lang-js">// Shape integration
integrate = (shape, deltaTime) => {

  var acceleration = scale(shape.forceAccumulator, shape.invMass); // compute acceleration
	shape.velocity = add(shape.velocity, scale(acceleration, 1)); // apply acceleration to velocity
	translateShape(shape, scale(shape.velocity, 1)); // apply velocity to position
	shape.forceAccumulator = Vec2(0, 0); // reset force accumulator
  shape.velocity = scale(shape.velocity, .99); // velocity damping
}

// Update the physics engine
update = () => {

  // (...)
  
  // Ball update
  for(i of shapes){
  
    // Apply gravity
    i.forceAccumulator = add(i.forceAccumulator, gravity);
    
    // Integration
    integrate(i, deltaTime);

    // Bouncing (temp)
    if(i.center.y > 300){
      i.center.y = 300;
      i.velocity = scale(i.velocity, -1);
    }
  }
}

// Demo
c1 = circle(Vec2(100, 100), 20);</code></pre>

<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=32">1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=33">2</a>
demo <a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/19/Main.html">1</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/19.1/Main.html">2</a>, 
source code <a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/19">1</a> (20.6 kb), 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/19.1">2</a> (20.8 kb)

<br>- Mine:
<a href="https://xem.github.io/2Dphysics/19/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/19">source code</a> (12.4 kb)
<p><video controls src="images/2D-physics/19.mp4?v=3" width=500></video>

<br><hr>







<p><b>Chapter 20: Linear impulses</b>

<p>Linear impulses (pushes) can help us create realistic collision responses according to the relative velocities of the objects, their masses and their materials (i.e. fricion and restitution coefficients).

<p>- Restitution (bounciness) represents how much energy is conserved after a collision (0: no elasticity - 1: perfect elastic).
<p>- Friction (slidyness) will be used later in tangential collision responses (0: frictionless - 1: maximum friction).
<p>In this chapter, the default values (friction = 0, restitution = 1) are used, and the masses are ignored.
<p>Also, the update method now handles all three kinds of collisions, and the gravity is disabled for now, to let shapes collide with each other.
<p>The red coloring on collisions is commented.

<p><pre><code class="lang-js">// Shapes
circle = (center, radius, mass = 1, friction = 0, restitution = 1, angle = 0, velocity = Vec2(0, 0), color = "#888") => {
  shape = {
    type: "circle",
    center: center,
    radius: radius,
    mass: mass,
    invMass: 1 / mass,
    friction: friction,
    restitution: restitution,
    velocity: velocity,
    
    // (...)
}

rectangle = (center, width, height, mass = 1, friction = 0, restitution = 1, angle = 0, velocity = Vec2(0, 0), color = "#888") => {
  shape = {
    type: "rectangle",
    center: center,
    width: width,
    height: height,
    mass: mass,
    invMass: 1 / mass,
    friction: friction,
    restitution: restitution,
    velocity: velocity,
    
    // (...)
};

// Correct positioning
positionalCorrection = (shape1, shape2, manifold) => {

  // todo
}

// Resolve collision
resolveCollision = (shape1, shape2, manifold) => {

  var relativeVelocityAlongNormal = dot(sub(shape2.velocity, shape1.velocity), manifold.normal);
  if(relativeVelocityAlongNormal > 0) return; // shapes are already going away from each other
  var e = 1; // total elasticity (currently 100%)
  var j = -(1 + e) * relativeVelocityAlongNormal; // impulse magnitude
  var impulseVector = scale(manifold.normal, j);
  shape1.velocity = add(shape1.velocity, scale(impulseVector, -.5));
  shape2.velocity = add(shape2.velocity, scale(impulseVector, .5));
}

// Update the physics engine
update = () => {

  var push, manifold, shape1, shape2, direction, distance;
  
  // Reset manifolds
  manifolds = [];
  
  // Reset shapes colors
  for(var i of shapes){
    i.color = "#888";
  }
  
  // Consider all pairs of shapes
  for(var i = 0; i &lt; shapes.length; i++){
    for(var j = i; j &lt; shapes.length; j++){
      if(i != j){
      
        shape1 = shapes[i];
        shape2 = shapes[j];

        // Reset manifold
        manifold = null;
        
        // Detect circle-circle collisions
        if(shape1.type == "circle" && shape2.type == "circle"){
          direction = sub(shape2.center, shape1.center);
          distance = dist(shape1.center, shape2.center);
          if(distance &lt; (shape1.radius + shape2.radius)){
            manifold = {
              depth: (shape1.radius + shape2.radius) - distance,
              normal: normalize(direction),
              contactPoint: add(shape1.center, scale(normalize(direction), shape1.radius))
            };
          }
        }
      
        // Detect rectangle-rectangle collisions
        else if(shape1.type == "rectangle" && shape2.type == "rectangle"){
          manifold = rectangleRectangleCollision(shape1, shape2);
        }

        // Detect circle-rectangle collisions
        else if(shape1.type == "rectangle" && shape2.type == "circle"){
          [shape1, shape2] = [shape2, shape1];
          manifold = circleRectangleCollision(shape1, shape2);
        }
        
        else if(shape1.type == "circle" && shape2.type == "rectangle"){
          manifold = circleRectangleCollision(shape1, shape2);
        }
        
        // Collision response
        if(manifold){
          //shape1.color = "red";
          //shape2.color = "red";
          push = scale(manifold.normal, manifold.depth * 0.5);
          positionalCorrection(shape1, shape2, manifold);
          resolveCollision(shape1, shape2, manifold);
          manifolds.push(manifold);
        }
      }
    }
  }
  
  for(i of shapes){
    // Apply gravity
    //i.forceAccumulator = add(i.forceAccumulator, gravity);
    
    // Integration
    integrate(i, deltaTime);
  }
}

// Demo
c1 = circle(Vec2(190, 100), 20, 1, 0, 1, 0, Vec2(1, 1));
c2 = circle(Vec2(320, 30), 20, 1, 0, 1, 0, Vec2(-2, 2));
r1 = rectangle(Vec2(200, 220), 100, 20);
r2 = rectangle(Vec2(200, 280), 50, 50, 1, 0, 1, 0, Vec2(0, -1));</code></pre>

<p><b>Links:</b>
<br>- Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=34">1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=35">2</a>
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=36">3</a>
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=37">4</a>
demo <a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/20/Main.html">1</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/20.1/Main.html">2</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/20.2/Main.html">3</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/20.3/Main.html">4</a>, 
source code <a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/20">1</a> (22.2 kb), 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/20.1">2</a> (22.2 kb), 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/20.2">3</a> (22.4 kb), 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/20.3">4</a> (22.8 kb)

<br>- Mine:
<a href="https://xem.github.io/2Dphysics/20/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/20">source code</a> (15.0 kb)
<p><video controls src="images/2D-physics/20.mp4?v=3" width=500></video>

<br><hr>







<p><b>Chapter 21: weight </b>

<p>As we saw earlier, objects react to impulses proportionally to their inverse masses.
<p>Fixed objects (also called kinematic or immovable) have an infinite mass and an invMass equal to 0, hence no reaction to impulses.
<p>For simplicity, the shapes constructors consider "mass = 0" as infinite mass. 
<p>The demo is updated to include light, heavy and fixed shapes.

<p><pre><code class="lang-js">// Shapes
circle = (center, radius, mass = 1, friction = 0, restitution = 1, angle = 0, velocity = Vec2(0, 0), color = "#888") => {
  
  shape = {
    type: "circle",
    center: center,
    radius: radius,
    mass: mass,
    invMass: mass == 0 ? 0 : 1 / mass,
    
    // (...)

rectangle = (center, width, height, mass = 1, friction = 0, restitution = 1, angle = 0, velocity = Vec2(0, 0), color = "#888") => {
  shape = {
    type: "rectangle",
    center: center,
    width: width,
    height: height,
    mass: mass,
    invMass: mass == 0 ? 0 : 1 / mass,
    
    // (...)

};

// Resolve collision
resolveCollision = (shape1, shape2, manifold) => {

  var relativeVelocityAlongNormal = dot(sub(shape2.velocity, shape1.velocity), manifold.normal);
  if(relativeVelocityAlongNormal > 0) return; // shapes are already going away from each other
  var e = 1; // total elasticity
  var invMassSum = shape1.invMass + shape2.invMass;
  var j = (-(1 + e) * relativeVelocityAlongNormal) / invMassSum; // impulse magnitude
  var impulseVector = scale(manifold.normal, j);
  shape1.velocity = add(shape1.velocity, scale(impulseVector, -shape1.invMass));
  shape2.velocity = add(shape2.velocity, scale(impulseVector, shape2.invMass));
}

// Demo
c1 = circle(Vec2(190, 100), 20, 1, 0, 1, 0, Vec2(1, 1));
c2 = circle(Vec2(250, 120), 20, 0, 0, 1);
r1 = rectangle(Vec2(200, 220), 100, 20, .2);
r2 = rectangle(Vec2(200, 280), 50, 50, 10, 0, 1, 0, Vec2(0, -1));</code></pre>

<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=38">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/21/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/21">source code</a> 
(23.6 kb)

<br>- Mine:
<a href="https://xem.github.io/2Dphysics/21/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/21">source code</a> (15.1 kb)
<p><video controls src="images/2D-physics/21.mp4?v=3" width=500></video>

<br><hr>








<p><b>Chapter 22: kinematic bodies</b>

<p>This chapter introduces an isKinematic property and returns early from collision resolution if both shapes are kinematic.

<p>We will simply test if their invMass is 0 instead.

<p><pre><code class="lang-js">// Resolve collision
resolveCollision = (shape1, shape2, manifold) => {

  var relativeVelocityAlongNormal = dot(sub(shape2.velocity, shape1.velocity), manifold.normal);
  if(relativeVelocityAlongNormal > 0) return; // shapes are already going away from each other
  if(shape1.invMass == 0 && shape2.invMass == 0) return; // both shapes are kinematic
  
  // (...)
}</code></pre>

<p><b>Links:</b>
<br>Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=39">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/22/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/22">source code</a> 
(24.9 kb)

<br><hr>








<p><b>Chapter 23: Positional corrections</b>

<p>positionalCorrection is implemented to prevent objects from overlapping: they are instantly moved away from each other proportionally to their invMass.
<p>The restitution (bounciness) of the shapes is also included in the impulse magnitude.
<p>Finally, the gravity is restored and a fixed ground is added to the demo.
<br>In physics, gravity is a constant (all objects fall at the same speed).
<br>However, our integration method makes all the forces applied to an object proportional to their inverse mass.
<br>To compensate that, in the update method, each object will receive a gravity force proportional to its mass ((G x m) / m = G).

<p><pre><code class="lang-js">// Correct positioning
positionalCorrection = (shape1, shape2, manifold) => {

  var correction = 0.7;
  var correctionAmount = manifold.depth / (shape1.invMass + shape2.invMass) * correction;
  var correctionVector = scale(manifold.normal, correctionAmount);
  if(shape1.invMass > 0){
    translateShape(shape1, scale(correctionVector, -shape1.invMass));
  }
  if(shape2.invMass > 0){
    translateShape(shape2, scale(correctionVector, shape2.invMass));
  }
}

// Resolve collision
resolveCollision = (shape1, shape2, manifold) => {

  
  // (...)
  
  var e = Math.min(shape1.restitution, shape2.restitution); // total elasticity
  
  // (...)
}

// Update the physics engine
update = () => {

  // Apply gravity
  for(var i of shapes){
    console.log(i.mass);
    i.forceAccumulator = add(i.forceAccumulator, scale(gravity, i.mass));
  }

  // (...)
  
  // Integration
  for(i of shapes){
    integrate(i, deltaTime);
  }
}</code></pre>

<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=40">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/23/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/23">source code</a> 
(25.9 kb)

<br>- Mine:
<a href="https://xem.github.io/2Dphysics/23/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/23">source code</a> (15.7 kb)
<p><video controls src="images/2D-physics/23.mp4?v=3" width=500></video>

<br><hr>









<p><b>Chapter 24: Inertia</b>

<p>Inertia represents the resistance of an object to rotational forces.

<p>In this chapter, we introduce the <b>inertia</b>, <b>inverseInertia</b> and <b>angularVelocity</b> properties for circles and rectangles.
<p>Like the velocity, the angular velocity of each shape is also damped over time, and it is applied to its angle during integration.
<p>Contrary to velocity, angularVelocity is a Number (because the angle is a Number too).
<p>The inertia is a constant computed in the shapes' constructors:
<p>- Circles inertia is equal to (mass * radius²) / 2.
<p>- Rectangles inertia is equal to (mass * (width² + height²)) / 12.
<p>- Complex polygons inertia is detailed in the original code but not used here.

<p>The shapes now have all they need to rotate naturally after a collision, and the next two chapters will implement that.

<p><pre><code class="lang-js">// Shapes
circle = (
  center,
  radius,
  mass = 1,
  friction = 0,
  restitution = 1,
  angle = 0,
  velocity = Vec2(0, 0),
  angularVelocity = 0,
  color = "#888"
) => {

  var inertia = (mass * (radius ** 2)) / 2;
  
  shape = {
    type: "circle",
    center: center,
    radius: radius,
    mass: mass,
    invMass: mass == 0 ? 0 : 1 / mass,
    friction: friction,
    restitution: restitution,
    angle: angle,
    velocity: velocity,
    angularVelocity: angularVelocity,
    inertia: inertia,
    invInertia: inertia == 0 ? 0 : 1 / inertia,
    forceAccumulator: Vec2(0, 0),
    color: color
  };
  
  shapes.push(shape);
  return shape;
}

rectangle = (
  center,
  width,
  height,
  mass = 1,
  friction = 0,
  restitution = 1,
  angle = 0,
  velocity = Vec2(0, 0),
  angularVelocity = 0,
  color = "#888"
) => {

  var inertia = (mass * ((width ** 2) + (height ** 2))) / 12;
  
  shape = {
    type: "rectangle",
    center: center,
    width: width,
    height: height,
    mass: mass,
    invMass: mass == 0 ? 0 : 1 / mass,
    friction: friction,
    restitution: restitution,
    angle: angle,
    velocity: velocity,
    angularVelocity: angularVelocity,
    inertia: inertia,
    invInertia: inertia == 0 ? 0 : 1 / inertia,
    forceAccumulator: Vec2(0, 0),
    color: color,

    // Rectangle vertices
    vertices: [
      Vec2(center.x - width / 2, center.y - height / 2), // top left
      Vec2(center.x + width / 2, center.y - height / 2), // top right
      Vec2(center.x + width / 2, center.y + height / 2), // bottom left
      Vec2(center.x - width / 2, center.y + height / 2)  // bottom right
    ]
  };
  
  // Rotation
  if(angle) {
    rotateShape(shape, angle);
  }
  
  // Normals
  calcNormals(shape);
  
  shapes.push(shape);
  return shape;
};

// Shape integration
integrate = (shape, deltaTime) => {

  // compute acceleration
  var acceleration = scale(shape.forceAccumulator, shape.invMass);
  
  // apply acceleration to velocity
  shape.velocity = add(shape.velocity, scale(acceleration, 1));

  // apply velocity to position
  translateShape(shape, scale(shape.velocity, 1));

  // apply angular velocity to angle
  rotateShape(shape, shape.angularVelocity * 1); 

  // reset force accumulator
  shape.forceAccumulator = Vec2(0, 0); 

  // velocity damping
  shape.velocity = scale(shape.velocity, .99); 

  // angular velocity damping
  shape.angularVelocity *= 0.99; 
}

// Demo
rectangle(Vec2(350, 350), 300, 20, 0, 0.5, .9, 0.2);
circle(Vec2(190, 100), 30, 10, 1, .1);
circle(Vec2(290, 100), 30, 10, .1, .1);
circle(Vec2(390, 100), 30, 10, .01, .1);
rectangle(Vec2(500, 100), 100, 50, 10, 1, .1);
rectangle(Vec2(290, -700), 100, 50, 10, .01, .1);</code></pre>

<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=41">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/24/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/24">source code</a> 
(27.0 kb)

<br>- Mine:
<a href="https://xem.github.io/2Dphysics/24/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/24">source code</a> (16.3 kb)
<p><video controls src="images/2D-physics/24.mp4?v=3" width=500></video>

<br><hr>









<p><b>Chapter 25: rotational impulses</b>

<p>Just like position has velocity and acceleration, angle has angular velocity and torque (angular acceleration).

<p>Angular impulses can affect an object's torque every time a force is not applied towards its center of gravity.

<p>A <b>cross</b> function is added to Vec2, to compute a cross-product.
<br>It returns a value between -1 and 1 representing the angle between two vectors (from 1: parallel, to 0: perpendicular, to -1: opposed).

<p>The resolveCollision method is rewritten to allow rectangles to rotate after a collision. I left the code heavily commented for now.

<p>Circles are not affected by this code because they are not polygons, so they can only rotate based on tangential impulses, which are caused by friction. Chapter 26 will cover this.

<p><pre><code class="lang-js">cross = (v, w) => v.x * w.y - v.y * w.x;

// Resolve collision
resolveCollision = (shape1, shape2, manifold) => {

  // If both objects are kinematic, skip
  if(shape1.invMass == 0 && shape2.invMass == 0) return;

  // Vectors from each object's center to the contact point
  var penetrationToCentroidA = sub(manifold.contactPoint, shape1.center);
  var penetrationToCentroidB = sub(manifold.contactPoint, shape2.center);

  // Linear velocity contribution at the contact point due to angular velocity
  var angularVelocityPenetrationCentroidA = Vec2(
    -shape1.angularVelocity * penetrationToCentroidA.y,
     shape1.angularVelocity * penetrationToCentroidA.x
  );
  var angularVelocityPenetrationCentroidB = Vec2(
    -shape2.angularVelocity * penetrationToCentroidB.y,
     shape2.angularVelocity * penetrationToCentroidB.x
  );

  // Total velocity at the contact point = linear + rotational
  var relativeVelocityA = add(shape1.velocity, angularVelocityPenetrationCentroidA);
  var relativeVelocityB = add(shape2.velocity, angularVelocityPenetrationCentroidB);

  // Relative velocity between both contact points
  var relativeVel = sub(relativeVelocityB, relativeVelocityA);

  // Project relative velocity onto the collision normal
  var velocityInNormal = dot(relativeVel, manifold.normal);

  // If the objects are moving apart (positive relative velocity along the normal), skip
  if(velocityInNormal > 0) return;

  // Restitution coefficient (bounciness)
  var e = Math.min(shape1.restitution, shape2.restitution);

  // Compute the "lever arm" cross product (how far from the center the impulse acts)
  var pToCentroidCrossNormalA = cross(penetrationToCentroidA, manifold.normal);
  var pToCentroidCrossNormalB = cross(penetrationToCentroidB, manifold.normal);

  // Effective inverse mass including both linear and rotational contributions
  var invMassSum = shape1.invMass + shape2.invMass;
  var rigiAInvInertia = shape1.invInertia;
  var rigiBInvInertia = shape2.invInertia;
  var crossNSum =
    pToCentroidCrossNormalA * pToCentroidCrossNormalA * rigiAInvInertia +
    pToCentroidCrossNormalB * pToCentroidCrossNormalB * rigiBInvInertia;

  // Compute the scalar impulse magnitude (j)
  var j = -(1 + e) * velocityInNormal;
  j /= (invMassSum + crossNSum);

  // Convert scalar impulse into a vector along the collision normal
  var impulseVector = scale(manifold.normal, j);

  // Apply impulse to linear velocities (in opposite directions)
  shape1.velocity = sub(shape1.velocity, scale(impulseVector, shape1.invMass));
  shape2.velocity = add(shape2.velocity, scale(impulseVector, shape2.invMass));

  // Apply rotational impulse based on lever arm and inverse inertia
  shape1.angularVelocity += -pToCentroidCrossNormalA * j * rigiAInvInertia;
  shape2.angularVelocity +=  pToCentroidCrossNormalB * j * rigiBInvInertia;
}</code></pre>

<p><b>Links:</b>
<br>Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=42">1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=43">2</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=44">3</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=45">4</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=46">5</a>, 
demo <a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/25/Main.html">1</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/25.1/Main.html">2</a>, 
source code <a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/25">1</a> (29.6kb)
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/25.1">2</a> 
(29.5 kb)

<br>- Mine:
<a href="https://xem.github.io/2Dphysics/25/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/25">source code</a> (18.4 kb)
<p><video controls src="images/2D-physics/25.mp4?v=3" width=500></video>

<br><hr>









<p><b>Chapter 26: frictional impulses</b>

<p>The last step needed to make balls roll on themselves after a collison, but also to make all the shapes fall along a slope with a specific resistance, is to implement friction.

<p><pre><code class="lang-js">// Resolve collision
resolveCollision = (shape1, shape2, manifold) => {

  // If both objects are kinematic, skip
  if(shape1.invMass == 0 && shape2.invMass == 0) return;
  
  // Normal impulse

  // (...)

  // Frictional impulse

  // Compute the component of the relative velocity along the collision normal
  var velocityInNormalDirection = scale(manifold.normal, dot(relativeVel, manifold.normal));

  // Subtract that from the total relative velocity to get the tangential direction
  var tangent = sub(relativeVel, velocityInNormalDirection);

  // Reverse tangent direction (optional, depending on sign convention)
  tangent = scale(tangent, -1);

  // Use the smallest friction coefficient between the two shapes
  var minFriction = Math.min(shape1.friction, shape2.friction);

  // Compute lever arms (distance vectors crossed with tangent direction)
  // Used to determine rotational influence for each body
  var pToCentroidCrossTangentA = cross(penetrationToCentroidA, tangent);
  var pToCentroidCrossTangentB = cross(penetrationToCentroidB, tangent);

  // Effective inverse mass for the tangential direction (accounts for rotation)
  var crossSumTangent =
    pToCentroidCrossTangentA * pToCentroidCrossTangentA * rigiAInvInertia +
    pToCentroidCrossTangentB * pToCentroidCrossTangentB * rigiBInvInertia;

  // Compute the tangential (frictional) impulse magnitude
  // This resists sliding motion along the tangent direction
  var frictionalImpulse = -(1 + e) * dot(relativeVel, tangent) * minFriction;

  // Divide by total effective mass (linear + rotational)
  frictionalImpulse /= (invMassSum + crossSumTangent);

  // Limit frictional impulse so it doesn’t exceed the normal impulse
  if(frictionalImpulse > j){ frictionalImpulse = j; }

  // Convert scalar friction impulse into a vector along the tangent
  var frictionalImpulseVector = scale(tangent, frictionalImpulse);

  // Apply friction impulse to linear velocities of both bodies
  shape1.velocity = sub(shape1.velocity, scale(frictionalImpulseVector, shape1.invMass));
  shape2.velocity = add(shape2.velocity, scale(frictionalImpulseVector, shape2.invMass));    

  // Apply angular (rotational) impulse due to friction
  shape1.angularVelocity += -pToCentroidCrossTangentA * frictionalImpulse * rigiAInvInertia;    
  shape2.angularVelocity +=  pToCentroidCrossTangentB * frictionalImpulse * rigiBInvInertia;
}</code></pre>


<p>A little warning here: when I showed this code to ChatGPT, it suggested a few modifications (to take with a pinch of salt):
<p>- "(1+e) * " has no physical sense in friction. We should do this instead:
<br><pre><code class="lang-js">var frictionalImpulse = -dot(relativeVel, tangent) * minFriction;</code></pre>
<br>- Coulomb friction must be clamped:
<br><pre><code class="lang-js">if (Math.abs(frictionalImpulse) > j * minFriction)
    frictionalImpulse = j * minFriction * Math.sign(frictionalImpulse);</code></pre>

<p>We will consider these ideas later.

<p><b>Links:</b>
<br>- Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=47">1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=48">2</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=49">3</a>, 
demo <a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/26/Main.html">1</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/26.1/Main.html">2</a>, 
source code <a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/26">1</a> (33.6 kb), 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/26.1">2</a> 
(36.1 kb)

<br>- Mine:
<a href="https://xem.github.io/2Dphysics/26/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/26">source code</a> (20.8 kb)
<p><video controls src="images/2D-physics/26.mp4?v=3" width=500></video>

<br><hr>

<i>We are now at the same level as my 2019 library mini2Dphysics. The next 10 chapters will finally cover the last features that interest me.</i>

<br><hr>









<p><b>Chapter 27: Anchor points</b>

<p>To start implementing joints between rigid bodies, we need a way to define anchor points.

<p>These anchor points are defined relatively to a shape's center, and are recomputed in World coordinates when the shape is rotated or translated.

<p>For debug purposes, they are drawn in green.

<p><pre><code class="lang-js">// Shapes
circle = ( /* ... */ ) => {
  
  var shape = {
    // (...)
    color: color,
    anchorPoints: []
  };
  
  shapes.push(shape);
  return shape;
}

rectangle = ( /* ... */ ) => {
 
  var shape = {
    
    // (...)
    
    color: color,
    anchorPoints: [],

    // (...)
  };
};

// Add anchor point (local coordinates)
addAnchor = (anchor, shape) => {
  shape.anchorPoints.push(add(anchor, shape.center));
}

// Translate a shape
translateShape = (shape, offset) => {

  // (...)
  
  // Move anchor points
  for(var i in shape.anchorPoints){
    shape.anchorPoints[i] = add(shape.anchorPoints[i], offset);
  }
}

// Rotate a shape around its center (angle in radians)
rotateShape = (shape, angle) => {

  // (...)
  
  // Rotate anchor points
  for(var i in shape.anchorPoints){
    shape.anchorPoints[i] = rotate(shape.anchorPoints[i], shape.center, angle);
  }
}

// Render the scene
draw = () => {

  // Reset canvas
  a.width = a.width;

  // Draw shapes
  for(var i of shapes){
    
    // (...)
    
    // Debug: draw anchor points
    for(var j of i.anchorPoints){
      drawPoint(j, 5, "green");
    }
  }

  // (...)
}

// Demo
rectangle(Vec2(350, 350), 300, 20, 0, 0.5, .9, 0.2);
circle(Vec2(190, 100), 30, 10, 1, .1);
c1 = circle(Vec2(290, 100), 30, 10, .1, .1);
circle(Vec2(390, 100), 30, 10, .01, .1);
rectangle(Vec2(500, 100), 100, 50, 10, 1, .1);
r1 = rectangle(Vec2(290, -700), 100, 50, 10, .01, .1);
addAnchor(Vec2(15, 15), c1);
addAnchor(Vec2(-30, 15), r1);</code></pre>

<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=50">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/27/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/27">source code</a> 
(37.2 kb)

<br>- Mine:
<a href="https://xem.github.io/2Dphysics/27/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/27">source code</a> (21.3 kb)
<p><video controls src="images/2D-physics/27.mp4?v=3" width=500></video>

<br><hr>









<p><b>Chapter 28: Apply a force outside the center</b>

<p>Anchor points will be used to apply forces on objects. When the anchor is not exactly on the center of a shape, their force provokes a linear and a rotational motion.

<p>A <b>torqueAccumulator</b> (Number) is added to the shapes constructors.

<p>Mouse inputs will be used to apply forces freely in the demo.
<p>An <b>isPointInside</b> function is created to check if a shape is clicked.
<p>The integrate method is completed too.

<p><pre><code class="lang-js">// Globals
selectedRigidBody = null;
selectedPosition = null;
selectedAnchorId = null;

// Is point inside a shape
isPointInside = (point, shape) => {

  // Circle
  if(shape.type == "circle"){
		var distanceToCenter = len(sub(shape.center, point));	
		return shape.radius > distanceToCenter;
	}
  
  // Rectangle
  else {
    var isInside = false;
		for(var i = 0; i &lt; shape.vertices.length; i++){
			var vertex = shape.vertices[i];
			var normal = shape.normals[i];
			var vertToPoint = sub(point, vertex);
			var d = dot(vertToPoint, normal);
			if(d > 0) return false;
			else isInside = true;
		}
		return isInside;
  }
}

// Add force on a point (world coordinates)
addForceAtPoint = (point, shape, force) => {
  var direction = sub(point, shape.center);
  shape.forceAccumulator = add(shape.forceAccumulator, force);
  shape.torqueAccumulator += cross(direction, force);
}

// Shape integration
integrate = (shape, deltaTime) => {

  // compute acceleration and rotational acceleration
  var acceleration = scale(shape.forceAccumulator, shape.invMass);
  var rotationalAcceleration = shape.torqueAccumulator * shape.invInertia;
  
  // apply acceleration to velocity
  shape.velocity = add(shape.velocity, scale(acceleration, 1));

  // apply velocity to position
  translateShape(shape, scale(shape.velocity, 1));
  
  // apply rotational acceleration to angular velocity
  shape.angularVelocity += rotationalAcceleration * 1;

  // apply angular velocity to angle
  rotateShape(shape, shape.angularVelocity * 1); 

  // velocity damping
  shape.velocity = scale(shape.velocity, .99); 

  // angular velocity damping
  shape.angularVelocity *= 0.99; 

  // reset force accumulator
  shape.forceAccumulator = Vec2(0, 0); 
  
  // reset torque accumulator
  shape.torqueAccumulator = 0;
}

// Mouse interactions
handleMouseObjectInteraction = () => {
  var mousePos = Vec2(mx, my);

  // Left button pressed
  if(mlb){
    for(var i = 0; i &lt; shapes.length; i++){
      var mouseInside = isPointInside(mousePos, shapes[i]);
      if(mouseInside && selectedRigidBody == null){
        selectedRigidBody = shapes[i];
        selectedPosition = copy(mousePos);
        var localPos = sub(mousePos, shapes[i].center);
        addAnchor(localPos, shapes[i]);
        selectedAnchorId = shapes[i].anchorPoints.length - 1;
      }
    }
  }
  
  // Left button released
  else {
    if(selectedRigidBody != null){
      selectedRigidBody.anchorPoints.pop();
      selectedRigidBody = null;
    }
    selectedAnchorId = null;
    selectedPosition = null;
  }
  
  // Apply force
  if(selectedRigidBody && selectedPosition){
    var start = selectedRigidBody.anchorPoints[selectedAnchorId];
    var force = sub(mousePos, start);
    addForceAtPoint(start, selectedRigidBody, scale(force, 0.01));			
  }
}

// Update the physics engine
update = () => {

  // (...)
  
  // Mouse interactions
  handleMouseObjectInteraction();
}

// Demo
rectangle(Vec2(350, 350), 400, 20, 0, 0.5, .9); // not tilted
</code></pre>

<p><b>Links:</b>
<br>- Original:  
video <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=51">1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=56">2</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/28/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/28">source code</a> 
(39.6 kb)

<br>- Mine:
<a href="https://xem.github.io/2Dphysics/28/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/28">source code</a> (23.8 kb)
<p><video controls src="images/2D-physics/28.mp4?v=3" width=500></video>

<br><hr>

also: red on collision

<p><b>Chapter 29: </b>

<p>

<p><pre><code class="lang-js">
</code></pre>

<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=52">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/29/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/29">source code</a> 
(41.9 kb)

<br>- Mine:
<a href="https://xem.github.io/2Dphysics/29/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/29">source code</a> ( kb)
<p><video controls src="images/2D-physics/29.mp4?v=3" width=500></video>

<br><hr>









<p><b>Chapter 30: </b>

<p>

<p><pre><code class="lang-js">
</code></pre>

<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=53">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/30/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/30">source code</a> 
(43.6 kb)

<br>- Mine:
<a href="https://xem.github.io/2Dphysics/30/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/30">source code</a> ( kb)
<p><video controls src="images/2D-physics/30.mp4?v=3" width=500></video>

<br><hr>










<p><b>Chapter 31: </b>

<p>

<p><pre><code class="lang-js">
</code></pre>

<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=54">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/31/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/31">source code</a> 
(45.3 kb)

<br>- Mine:
<a href="https://xem.github.io/2Dphysics/31/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/31">source code</a> ( kb)
<p><video controls src="images/2D-physics/31.mp4?v=3" width=500></video>

<br><hr>










<p><b>Chapter 32: </b>

<p>

<p><pre><code class="lang-js">
</code></pre>

<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=55">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/32/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/32">source code</a> 
(46.0 kb)

<br>- Mine:
<a href="https://xem.github.io/2Dphysics/32/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/32">source code</a> ( kb)
<p><video controls src="images/2D-physics/32.mp4?v=3" width=500></video>

<br><hr>










<p><b>Chapter 33: </b>

<p>

<p><pre><code class="lang-js">
</code></pre>

<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=57">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/33/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/33">source code</a> 
(53.3 kb)

<br>- Mine:
<a href="https://xem.github.io/2Dphysics/33/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/33">source code</a> ( kb)
<p><video controls src="images/2D-physics/33.mp4?v=3" width=500></video>

<br><hr>










<p><b>Chapter 34: </b>

<p>

<p><pre><code class="lang-js">
</code></pre>

<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=58">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/34/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/34">source code</a> 
(48.9 kb)

<br>- Mine:
<a href="https://xem.github.io/2Dphysics/34/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/34">source code</a> ( kb)
<p><video controls src="images/2D-physics/34.mp4?v=3" width=500></video>

<br><hr>










<p><b>Chapter 35: </b>

<p>

<p><pre><code class="lang-js">
</code></pre>

<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=59">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/35/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/35">source code</a> 
(50.1 kb)

<br>- Mine:
<a href="https://xem.github.io/2Dphysics/35/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/35">source code</a> ( kb)
<p><video controls src="images/2D-physics/35.mp4?v=3" width=500></video>

<br><hr>










<p><b>Chapter 36: </b>

<p>

<p><pre><code class="lang-js">
</code></pre>

<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=60">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/36/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/36">source code</a> 
(63.1 kb)

<br>- Mine:
<a href="https://xem.github.io/2Dphysics/36/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/36">source code</a> ( kb)
<p><video controls src="images/2D-physics/36.mp4?v=3" width=500></video>

<br><hr>


TODO: remove ", 1" in integration? (in the videos it's ", deltaTime" )


</main>

</div>

<footer></footer>

<script src="../ui.js?v=2024-07"></script>
<script>
header();
footer();
menu();
</script>
</body>
</html>