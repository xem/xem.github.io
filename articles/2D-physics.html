<!doctype html>
<meta charset=utf-8>
<meta name="viewport" content="width=device-width, user-scalable=no">
<html>
<head>
<link rel=stylesheet href="../style.css?v=2024-07">
<title>Maxime Euzière</title>
<base target=_blank>
</head>
<body>

<style>
.twitter-tweet { margin: 30px 0 !important; border: 3px solid #ccc; border-radius: 30px; overflow: hidden; transform: scale(.95)}
ul { padding-left: 15px }
</style>

<div class="wrapper">

<header></header>

<div id=menu></div>

<main>

<div class=section>

<h2>Golfing a 2D physics engine in JS</h2>
<br><h3>November 2025</h3>
<br><hr>
<p><img src="images/2D-physics/2D.png" style="float:right; margin: 0 20px; width: 200px"><b>Introduction</b>
<p>I have a long love-hate story with physics in JS.
<p>It all started in 2019, when I read <a href="https://link.springer.com/book/10.1007/978-1-4842-2583-7">this 134 pages book about 2D physics</a>, and summarized its contents in just <a href="https://xem.github.io/articles/images/js1k19/2.png">9 pages</a>.
<p>I used that to create a 1.57kb lib called <a href="https://xem.github.io/codegolf/mini2Dphysics.html">Mini2DPhysics</a> and the JS1K entry <a href="https://xem.github.io/codegolf/emojysics.html">Emojysics</a>.
<p>The problem was that this book, as every book I could find at the time, didn't go beyond basic interactions between spheres and discs.
<p>Even <a href="https://link.springer.com/book/10.1007/978-1-4842-7377-7">this 599 pages book</a> released in 2022 by the same editor and some of the original authors, managed to be even more verbose in almost every aspect of 2D game mechanics, except one: advanced physics. And when I say "advanced physics", I'm not asking for really complex stuff, I just want to learn springs, fixed joints, hinge joints, and how to optimize speed and stability.
<p>In 2021, 2022, 2023, 2024 and 2025 I tried many times to learn <a href="https://xem.github.io/articles/3D-physics.html">3D physics</a> because <a href="images/2D-physics/3D.jpg">a lot of good books actually cover this topic</a>, but I haven't managed to properly implement any of them in JS (so far)... and that was quite frustrating!
<p>Finally, in October 2025, after completing a new edition of <a href="https://xem.github.io/articles/js13k25.html">JS13KGames</a>, I randomly typed "2D physics JS" on Google and stumbled upon the holy Grail: <a href="https://www.reddit.com/r/gamedev/comments/1afq10l/i_created_a_tutorial_about_how_everybody_can/">this 2024 Reddit post</a> announcing a complete <a href="https://www.youtube.com/watch?v=D3oQ8mUF_84&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr">Youtube playlist</a> dedicated to learning 2D physics in JS. The playlist was accompanied by <a href="https://gitlab.com/Marcel.K/tutorials/-/tree/main/2D%20Physics%20Engine">complete source code on Gitlab</a> and <a href="https://www.amazon.de/dp/B0FL1K2ZZ5">a physical book released in August 2025!</a>. And since I'm so enthusiastic (and probably one of the 10 person on Eart that could possibly be interested by this book), I bought it. And I'm gonna read it and golf the source code here (first, write a tiny and readable version, then make it as small as possible). Let's go!

<p>My code will be published in public domain on <a href="https://github.com/xem/2Dphysics/tree/gh-pages">the 2DPhysics Github repo</a>, and <a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial">a copy of the original Gitlab repo</a> is also there for reference and for the live demos (thanks to Github Pages).
<br>
<br><hr>

<p><b>Chapter 1: Setting up a Canvas</b>
<p>Here we'll keep the HTML code to the absolute minimum: doctype, canvas and script tags.
<p>The canvas is called <b>a</b> and the 2D context <b>c</b>.
<p><pre><code class="lang-html">&lt;!doctype html>
&lt;canvas id=a width=800 height=600 style="background:#eee">&lt;/canvas>
&lt;script>

// Canvas setup
c = a.getContext("2d");

&lt;/script></code></pre>


<p><b>Links:</b>
<br>- Original: 
<a href="https://www.youtube.com/watch?v=H3HYsOvDymU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=2">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/1/Main.html">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/1">source code</a> (0.4kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/1/">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/1">source code</a> (0.1kb)

<br><hr>
<p><i>From now on, the code snippets in each chapter will show what was added or modified in my Javascript code.</i>
<br><hr>

<p><b>Chapter 2: Main loop</b>


<p>I'm going with a fixed 60fps setInterval loop for simplicity, instead of using requestAnimationFrame and computing deltaTime.

<p><pre><code class="lang-js">// Main loop
setInterval(() => {

  // TODO

}, 16);</code></pre>

<p><b>Links:</b>
<br>- Original:
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=3">video</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/2/Main.html">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/2">source code</a> (1.3kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/2/">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/2">source code</a> (0.2kb)

<br><hr>

<p><b>Chapter 3: Mouse and keyboard events / Simulation class</b>

<p>The golfed code won't use JS classes. User inputs and states are reduced to the bare minimum: left and right mouse buttons, mouse position, and keyboard key presses. Functions added in the loop: update and draw.

<p><pre><code class="lang-js">// Globals
mx = 0, my = 0,     // mouse x, y
mlb = 0, mrb = 0,   // mouse left and right button

// Event listeners
onmousemove = e => {
  mx = e.pageX - a.offsetLeft;
  my = e.pageY - a.offsetTop;
}

onmousedown = e => {
  if(e.button == 0) mlb = 1;
  if(e.button == 2) mrb = 1;
}

onmouseup = e => {
  if(e.button == 0) mlb = 0;
  if(e.button == 2) mrb = 0;
}

a.oncontextmenu = () => {
  return false; // prevent right click dropdown
}

onkeydown = e => {
  console.log(e.code); // Test logs
}

// Update the physics engine
update = () => {
  console.log(mx, my); // Test logs
}

// Render the scene
draw = () => {

  // Reset canvas
  a.width = a.width;

  // Test: draw a black square
  c.fillRect(100, 100, 20, 20);
}

// Main loop
setInterval(() => {
  update();
  draw();
}, 16);</code></pre>

<p><b>Links:</b>
<br>- Original: 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=4">video 1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=5">video 2</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/3/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/3">source code</a> (2.8kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/3/">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/3">source code</a> (0.8kb)

<br><hr>

<p><img src="images/2D-physics/dir.png" style="float:right; margin: 0 20px 20px; width: 200px"><b>Chapter 4: 2D vectors</b>
<p>2D vectors are objects containing two values (x and y).<p>They can represent a point (with x and y coordinates) or a movement (with x and y offsets).
<p>Here again, no JS class. I will reuse the mini vector lib I created for Mini2DPhysics, with some modifications (added normal, lengh squared and copy, removed cross, rotate and distance for now).

<p><pre><code class="lang-js">// 2D vectors
Vec2 = (x, y) => ({x, y});
normalize = v => scale(v, 1 / (len(v) || 1));
len = v => dot(v, v) ** .5;
len2 = v => dot(v, v);
normal = v => Vec2(v.y, -v.x);
dot = (v, w) => v.x * w.x + v.y * w.y;
copy = v => Vac2(v.x, v.y);
add = (v, w) => Vec2(v.x + w.x, v.y + w.y);
sub = (v, w) => add(v, scale(w, -1));
scale = (v, n) => Vec2(v.x * n, v.y * n);
<!-- //cross = (v, w) => v.x * w.y - v.y * w.x;
//rotate = (v, center, angle, x = v.x - center.x, y = v.y - center.y) => Vec2(x * Math.cos(angle) - y * Math.sin(angle) + center.x, x * Math.sin(angle) + y * Math.cos(angle) + center.y);
//dist = (v, w) => length(substract(v, w));
-->
</code></pre>

<p><b>Links:</b>
<br>- Original:  <a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=6">video</a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/4/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/4">source code</a> (3.8kb)
<br>- Mine: 
<a href="https://xem.github.io/2Dphysics/4/">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/4">source code</a> (1.2kb)

<br><hr>

<p><b>Chapter 5: Drawing points and arrows</b>

<p><i>At this chapter, I finally realized that the book I had in my hands was 100% AI-generated and not (or barely) proofread. I already noticed that the same expressions were repeated too many times and the text didn't feel super natural, not to mention the AI cover, but here it gets worse: the text accompanying the source code starts saying that the code makes no sense and is probably wrong. A human author would never say such a thing about his own code. Quite disappointing for a 35€ book!</i>

<p>That being said, let's pursue the reading because it may still lead me to a functional 2D physics engine!

<p>This chapter explains how do draw bullets (filled arcs), discs (stroked arcs), lines and arrows, for debug purposes.

<p>We'll settle with just two methods: drawPoint and drawLine.

<p><pre><code class="lang-js">// Debug
drawPoint = (center, radius = 5, color = "#888") => {
  c.beginPath();
  c.fillStyle = color;
  c.arc(center.x, center.y, radius, 0, 7);
  c.fill();
  c.closePath();
}

drawLine = (start, end, color = "#888") => {
  c.beginPath();
  c.strokeStyle = color;
  c.moveTo(start.x, start.y);
  c.lineTo(end.x, end.y);
  c.stroke();
  c.closePath();
}

// Render the scene
draw = () => {
  // Reset canvas
  a.width = a.width;

  // Test: draw some shapes
  c.fillRect(100, 100, 20, 20);
  drawPoint(Vec2(200,200));
  drawLine(Vec2(300, 50), Vec2(400, 150));
}</code></pre>

<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=7">video 1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=8">video 2</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=9">video 3</a>, 
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/5/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/5">source code</a> (5.6kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/5/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/5">source code</a> (1.6kb)

<br><hr>

<p><b>Chapter 6: Shapes</b>

<p>The author creates a generic Shape class to create and draw the future rigid bodies: circles and polygons.
<p>We'll have our own version in Chapter 8.

<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=10">video </a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/6/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/6">source code</a> (kb)

<br><hr>

<p><b>Chapter 7: Compute and display the centroid of a polygon</b>
<p>We don't need to compute polygon centroids for this project, as all our shapes will be based on circles and Rectangles.

<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=11">video 1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=12">video 2</a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/7/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/7">source code</a> (7.2 kb)

<br><hr>

<p><b>Chapter 8: Rotating and moving shapes</b>

<p>Here, we start implementing our shape objects and the methods that allow them to translate (move) and rotate.
<p>The code below only handles circles and rectangles, but other types of polygons can be added easily.
<p>2D rotations (around the origin [0,0]) are performed by applying a 2D rotation matrix on 2D vectors.
<p><img src="images/2D-physics/rot.png">
<p>2D rotations around a pivot point are done by subtracting the pivot coordinates, performing the rotation around the origin, and adding the pivot back.

<p><pre><code class="lang-js">// Globals
shapes = [];

// Vector2
rotate = (v, center, angle) => {
  var x = v.x - center.x;
  var y = v.y - center.y;
  return Vec2(
    x * Math.cos(angle) - y * Math.sin(angle) + center.x,
    x * Math.sin(angle) + y * Math.cos(angle) + center.y
  );
}

// Shapes
circle = (center, radius, angle) => {
  var shape = {
    type: "circle",
    center: center,
    radius: radius,
    angle: angle
  };
  
  shapes.push(shape);
  return shape;
}

rectangle = (center, width, height, angle) => {
  var shape = {
    type: "rectangle",
    center: center,
    width: width,
    height: height,
    angle: angle,

    // Rectangle vertices
    vertices: [
      Vec2(center.x - width / 2, center.y - height / 2), // top left
      Vec2(center.x + width / 2, center.y - height / 2), // top right
      Vec2(center.x + width / 2, center.y + height / 2), // bottom left
      Vec2(center.x - width / 2, center.y + height / 2)  // bottom right
    ]
  };
  
  if(angle) {
    rotateShape(shape, angle);
  }
  shapes.push(shape);
  return shape;
};

// Translate a shape
var translateShape = (shape, offset) => {

  // Move center
  shape.center = add(shape.center, offset);
  
  // Rectangle (move vertex)
  if(shape.type == "rectangle"){
    for(var i in shape.vertices){
      shape.vertices[i] = add(shape.vertices[i], offset);
    }
  }
}

// Rotate a shape around its center
var rotateShape = (shape, angle) => {

  // Update angle
  shape.angle += angle;
  
  // Rectangle (rotate vertices)
  if(shape.type == "rectangle"){
    for(var i in shape.vertices){
      shape.vertices[i] = rotate(shape.vertices[i], shape.center, angle);
    }
  }
}

// Update the physics engine
update = () => {

  // Test: translate and rotate the shapes
  for(i of shapes){
    rotateShape(i, .01);
    translateShape(i, Vec2(.1, .1));
  }
}

// Render the scene
draw = () => {

  // Reset canvas
  a.width = a.width;

  // Draw shapes
  for(i of shapes){
    
    if(i.type == "circle"){
      c.save();
      c.beginPath();
      c.translate(i.center.x, i.center.y);
      c.rotate(i.angle);
      c.arc(0, 0, i.radius, 0, 7);
      c.lineTo(0, 0);
      c.closePath();
      c.stroke();
      c.restore();
    }
    
    else if(i.type == "rectangle"){
      c.save();
      c.beginPath();
      c.moveTo(i.vertices[0].x, i.vertices[0].y);
      c.lineTo(i.vertices[1].x, i.vertices[1].y);
      c.lineTo(i.vertices[2].x, i.vertices[2].y);
      c.lineTo(i.vertices[3].x, i.vertices[3].y);
      c.closePath();
      c.stroke();
      c.restore();
    }
  }
}

// Demo
circle(Vec2(100, 100), 50);
rectangle(Vec2(400, 100), 50, 100);
</code></pre>


<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=13">video 1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=14">video 2</a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/8/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/8">source code</a> (10.8 kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/8/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/8">source code</a> (4.0 kb)
<p><video controls src="images/2D-physics/8.mp4" width=600></video>


<br><hr>

<!--<p><b>Chapter 9: </b>

<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=13">video 1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=14">video 2</a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/8/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/8">source code</a> ( kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/8/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/8">source code</a> ( kb)

<br><hr>

<p><b>Chapter 10: </b>

<p><b>Links:</b>
<br>- Original:  
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=13">video 1</a>, 
<a href="https://www.youtube.com/watch?v=cNx-5xjjRIU&list=PLSwCokO0cV86rDRBZmx-XbPIMYgzqIMZr&index=14">video 2</a>
<a href="https://xem.github.io/2Dphysics/pixelphysics_tutorial/2DPhysicsEngine/8/Main.html">demo</a>, 
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/pixelphysics_tutorial/2DPhysicsEngine/8">source code</a> ( kb)
<br>- Mine:
<a href="https://xem.github.io/2Dphysics/8/">demo</a>,
<a href="https://github.com/xem/2Dphysics/tree/gh-pages/8">source code</a> ( kb)

<br><hr>

<p>
-->

</main>

</div>

<footer></footer>

<script src="../ui.js?v=2024-07"></script>
<script>
header();
footer();
menu();
</script>
<style>
.inline, .inline * { display: inline; padding: 2px !important; }
pre { display: inline-block; min-width: 40vw }
video { max-width: 70vw; border: 2px solid; }
</style>
</body>
</html>