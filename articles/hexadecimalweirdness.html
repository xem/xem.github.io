<!doctype html>
<meta charset=utf-8>
<meta name="viewport" content="width=device-width, user-scalable=no">
<html>
<head>
<link rel=stylesheet href="../style.css?v=2022">
<title>Maxime Euzière</title>
</head>
<body>

<div class="wrapper">

<header></header>

<div id=menu></div>

<main>

<div class=section>

<h2>Hexadecimal weirdness</h2>

<h3>September 2012</h3>

<p>In 2012, I was playing with binary numbers in JS, in order to make a GBA emulator, and I found a weird bug/feature.

<p>It lead me to write <a href="https://wtfjs.com/wtfs/2012-09-19-Hexadecimal-weirdness">this wtfjs article</a>.

<p>At the same time, I discovered <b>140byt.es</b>, a collection of 140 bytes JS functions, and tried to make my "fixed" binary functions small enough to fit in a tweet. The result is visible <a href="../codegolf/binaryoperations.html">HERE</a>.

<p>That's how my codegolf career began!

<p><hr>
<br>

<iframe src="https://wtfjs.com/wtfs/2012-09-19-Hexadecimal-weirdness"height=1200></iframe>

</div>

<!--

<h1>2012 09 19 Hexadecimal weirdness</h1><p>In JS you can represent numbers in hexadecimal, right?</p>
<p><code>
    var hex = 0xFF55;
</code></p>
<p>You can also perform shift operations, right?
Left shift is equivalent to a multiplication...</p>
<pre><code class="lang-js"><code>    var hex = 0xFF55 &lt;&lt; 8;  // Shift 8 bits = add 0x00 at the end.
    alert(hex.toString(16)); // 0xFF5500
</code></pre><p>But from a certain point, this produces negative numbers</p>
<pre><code class="lang-js"><code>    // Before 0x800000 it's ok
    alert((0x777777 &lt;&lt; 8).toString(16)); // 0x77777700

    // After 0x800000 it's not ok
    alert((0x888888 &lt;&lt; 8).toString(16)); // -77777800, WTF?

    // The only way to remain positive is to multiply instead of shifting
    alert((0x888888 * 0x100).toString(16)); // 88888800
</code></pre><p>Thanks JS for making left shift different than a multiplication!</p>
<p>I do have an explanation!</p>
<p>ES5 states that the left-shift operator is a signed shift on 32 bits represented by two's complement which means
that the highest order bit defines the sign.</p>
<p>7 in hexa = 0111 in binary (every number below 7 starts with 0)
8 in hexa = 1000 in binary (every number above 8 starts with 1)</p>
<p>So in binary:</p>
<p>(0x777777 &lt;&lt; 8) in hexa = 0111 0111 0111 0111 0111 0111 0111 0000 0000 in binary  (the 32nd bit is still 0)</p>
<p>(0x888888 &lt;&lt; 8) in hexa = 1000 1000 1000 1000 1000 1000 0000 0000 in binary  (the 32nd bit becomes 1 =&gt; negative)</p>
<p>As for why multiplying 0x888888 <em> 0x100 yields a different result, both operands to the </em> operator are numeric, so
each is casted to a IEEE 64-bit double, then multiplied, which means this is what is really happening:</p>
<pre><code class="lang-js"><code>    0x888888 * 0x100 === 8947848.0 * 256.0 === 2290649088.0
</code></pre><p>When this is converted into a string with base 16, what you get is 88888800.</p>
<p>— <a href="https://twitter.com/MaximeEuziere">@MaximeEuziere</a>

-->

</main>

</div>

<footer></footer>

<script src="../ui.js?v=2022"></script>
<script>
header();
footer();
menu();
</script>

</body>
</html>