<!doctype html>
<meta charset=utf-8>
<meta name="viewport" content="width=device-width, user-scalable=no">
<html>
<head>
<link rel=stylesheet href="../style.css?v=4">
<title>Maxime Euzière</title>
<body>

<div class="wrapper">

<header></header>

<div id=menu></div>

<main>

<div class=section id=js13k19>
<h2>JS13kGames 2019</h2>
<h3>august-september 2019</h3>

<br>
<hr>
<br>

<h3>Intro</h3>

<p>Hi! This is a WIP article!

<!--<p><b>TL;DR:</b>

<p>
<ul>
<li> ... is playable <a href="">HERE</a> (source code <a href="">HERE</a>)
<li> ... is playable <a href="">HERE</a> (source code <a href="">HERE</a>)
<li>Tools developed before and during this compo:
<br>- <a href="https://xem.github.io/terser-online/">Terser-online</a>
<br>- <a href="https://github.com/xem/CSS3Dframework">CSS3Dframework</a>
<br>- <a href="https://twitter.com/MaximeEuziere/status/1157563570823081984">MiniDragAndDrop</a>
<br>- <a href="https://xem.github.io/miniPixelArt/">MiniPixelArt</a>
<br>- <a href="https://xem.github.io/mini2Dphysics">Mini2Dphysics</a>
<br>- <a href="">MiniPartition</a>
</ul>

<p>Results:
<ul>
<li>...
</ul>
-->
<br>
<br>
<hr>
<br>

<style>
blockquote { width: 450px; max-width: 100%; border: 2px solid #def; border-radius: 5px; padding: 0 10px 10px; }
img { border: 1px solid }
</style>

<h3>Before the compo</h3>

<h4>Ideas list</h4>

<p>Since last JS13kGames, while waiting for the theme, I prepared a list of ideas that looked like this:
<script src="https://gist.github.com/xem/4e0282d261bc9bf749dce741812799cc.js"></script>

<h4>Tools</h4>
<p>I also made some tools, such as:
<br>- <a href="https://xem.github.io/terser-online/">this online ES6 minifier</a> (optimized for js1k/js13k extreme compression),
<br>- <a href="https://xem.github.io/miniPixelArt/">this pixel-art editor</a> (with tiny JS export),
<br>- <a href="https://github.com/xem/CSS3Dframework">this CSS3D framework</a> (that helps making CSS3D scenes super easily),
<br>- <a href="https://twitter.com/MaximeEuziere/status/1151566587570397186">this music partition editor</a> (wip, with the great help of @d_gnhia),
<br>- <a href="https://github.com/xem/mini2Dphysics">this mini 2D physics engine</a> (that I submitted during JS1K 2019).
<br>- <a href="https://github.com/xem/miniOrchestra">this multi-instrument  music editor</a> (based on <a href="//github.com/xem/miniMusic">MiniMusic</a>, but with many more options, also thanks to @d_nghia).
<br>
<p>Fun fact: @udxs made a meme about me and all the tools I've made:
<br>
<p><img src="./images/js13k19/1.jpg" width='80%'>
<br>
<p>It's a running gag since:
<p><img src="./images/js13k19/1.5.png" width='80%'>
<br>
<p>These tools are now present in the <a href="https://js13kgames.github.io/resources/">resource page of JS13k</a>, along with 24 others tools I had made since 2015.
<p>@end3r, who organizes JS13k every year, even mentioned my contribution <a href="https://medium.com/js13kgames/help-promote-js13k-532616fbe217">in his "HELP PROMOTE JS13K" blog post</a>! Thanks to him!
<br>
<p>During all the month of the compo, I've seen a lot of people thanking me on Slack and on Twitter for my sound, art and compression tools, and telling me they're happily using them.
<br>I'm so glad I could help them make their games look and sound better through my tools! <3

<br>
<br>
<h4>Storyteller?</h4>
<p>I was VERY interested in the first idea of the list: a comics puzzle game inspired by the indie game <a href="http://www.storyteller-game.com/">Storyteller</a>.
<br>For a better idea of the concept, take a look at this video:
<br><iframe width="400" height="350" src="https://www.youtube.com/embed/JmKjsVHi-tM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<br>
<br>I made <a href="https://twitter.com/MaximeEuziere/status/1157563570823081984">a mini drag&drop library</a>, just in case I'd make this game for JS13k19.
<br>I also started coding a mini game engine prototype with emoji, because I was too curious to discover how such a system could be implemented.
<br>
<p><img src="images/js13k19/2.png" width=500>
<br>
<p>It was actually easier than I thought: the engine basically needs to know the characters' characteristics and emotions in a given frame (and sometimes the previous frame) and a list of hardcoded rules to determine the outcome of the current frame.
<br>
<p>Based on the video above, I was able to write a list of 44 rules (without implementing them).
<br>Most of them consist of a single, easy test.
<br>For example, "if someone is close to a treasure: he/she becomes rich; If someone else is closer to the treasure in the next frame: he/she stole the treasure to the other person and the other person hates him/her").
<br>
<p>The most important rule of the game (and the most complex one) is the one that make two people become lovers. This can happen:
<br>- if both are alive;
<br>- if both of them are the same species (human or vampire);
<br>- if both are close physically (if two women are present in the scene, a man will love the closest one, and vice versa);
<br>- if both are single (or not loyal to their lover);
<br>- if both are straight and of different sex, or gay and same sex, or bi;
<br>- if they're of the same social status (both poor, or both rich, or a princess and a hero);
<br>- if none of them is mourning a lover dead at the previous frame;
<br>- if none of them is heartbroken;
<br>- if none of them is angry at the other;
<br>- if none of them is shocked by a crime made by the other;
<br>- if none of them is greedy and close to a treasure;
<br>- if none of them is an Old Mentor (single for life);
<br>- if none of them is a human near to a vampire (because vampires make every human ar fall in love with them).
<br>
<p>This can seem complicated, but with the right data structures, it's just a matter of "if" tests performed in the right order.
<br>
<p>In the end, I did not make this game for JS13k19, but I had a lot of fun figuring out how it worked. And I'm also glad I could develop MiniDragAndDrop while preparing it.
<br>
<br>
<hr>
<br>
<h3>Week 1</h3>
<h4>The theme</h4>
<p>Day 1: The theme "BACK", was very inspiring, even though it seemed very similar to a previous theme called "REVERSE"...
<p>Fun fact: I spent all the previous year saying to @end3r that the theme of next JS13k should be "BACKSEAT", in reference to Notch's answer when I pointed at some optimizations he could add in his code last year.
<br>
<p><p><img src="images/js13k19/3.png">
<br>
<p>A few minutes before the start of the compo, @end3r pushed the joke a bit further by hinting this:
<br>
<p><img src="images/js13k19/4.png">
<br>
<h4>Ideas</h4>
<p>I started scribbling some ideas on my notepad:
<br><p><img src="images/js13k19/5.png">
<br>
<p>Three ideas from my list could easily be adapted to this theme:
<br>- The Storyteller clone (a.k.a. "Backstory", because you have to change the comic's events to match a story's conclusion)
<br>- The Trackmania Original demake (a.k.a. "Back on track", because it revives an old game and some of its puzzles actually require to go backward on the track to win)
<br>- The Mario 64 demake (because replaying it today would be a long jump back in time)
<br>
<p>Other ideas directly inspired by the theme also included:
<br>- "Backward": a collection of iconic video games levels that you have to play from the end to the start, with a completely inverted goal (for example, in Backwards Mario, you start from the flag and go througs the course from right to left. In backwards Pac-Man, you need to fill the area with gums. Etc!)
<br>- "Back in time": a platform game where you have the ability to go back in time, and use your past/future selves to pass obstacles.
<br>
<h4>Choosing an idea...</h4>
<p>My choice was finally to do something like <b>Trackmania</b>.
<br>
<p><img src="images/js13k19/6.png" width=300>
<br>
<p><b>Adios, other ideas!</b>
<br>
<br>- Storyteller's author (who was okay to let me make a game inspired by his concept) told me that his game is close to an official release, so I didn't want to "steal" his level ideas...
<br>- The Mario 64 demake would be so much work, and I won't have enough free time to do it well in one month...
<br>- The game compiling famous levels played backwards may infrige a lot of copyrights, even if I alter the graphics and audio, and moreover, I'm not sure at all if it would be fun to play...
<br>- The Back in time platformer would be cool, but it may be redundant with a lot of time travel entries made this year, and with my 2016 game <a href="https://js13kgames.com/entries/super-chrono-portal-maker">Super Chrono Portal Maker</a> which also used this mechanic a lot...
<br>
<p><b>Why Trackmania then?</b>
<br>
<br>- With this theme, and this "backseat" joke behind it, i HAD to make a racing game!
<br>- I thought "what's my favourite racing game?" and the obvious answer was Trackmania.
<br>- Trackmania (from 2003), a.k.a. Trackmania Original (the 2005 remake), is one of my favourite games, and it's almost impossible to install it on a modern PC: It's not available on Steam/GoG/Epic, and even if you buy the CD of the game (like I did), you're forced to crack it in order to play on Windows 8 or 10.
<br>- I have almost no idea how to implement it, even less in 13kb, and it's the kind of challenge I'm looking for.
<br>
<p>So I decided that a demake of this game would not only be a great programming and compression challenge, and a new type of game for me (racing), but also a good way for everyone to enjoy the good parts of this rare game 16 years after its release!
<br>
<h4>Choosing a game name</h4>
<p>When I wrote this idea in my list, I thought "13Kmania" would be a good name. (Especially in french, where "treize K mania" sounds a lot like "Trackmania".
<p>But to be more theme-friendly, I decided to use "Back on Track" instead!
<br>
<h4>Specs</h4>
<p>Day 2. Since my entry is a hommage to an abandonware (eh, it's even downloadable on archive.org for free!), I won't try to be super original, but instead, make a game that feels like the real one, with the same puzzles and races, just a lot simpler visually.
<br>It'll still be a huge task for me because I'll have to make vehicles, dozens of connectable road blocks, a map editor, and a convincing racing simulation in 13kb, in 3D, and in 31 days. 😰
<br>By the way: this project will have zero planning. I'll code what I want everyday and we'll see where it goes! (this is probably an extra challenge, but it might be fun at least)
<br>
<h4>Technology</h4>
<p>I know 3 ways to do 3D in a mini game: CSS3D, vanilla WebGL (with raymarching), and points projection.
<br>I first tried to go with point projection to try to make a game that is less resource-intensive. Unfortunately, I got stuck very early, when I tried to draw a (road) polygon that moved behind the camera. At this moment, the projection becomes erratic and I have no idea how to fix it...
<br><p><img src="images/js13k19/7.gif" width=200>
<br>(this gif shows my attempts to make a square that goes from front to back under the camera, in perspective. As soon as the distance between a point and the camera is negative, I have no way to project my polygons reliably)
<br>
<p>WebGL would look very nice but I'm afraid I'll lose too much time trying to make it work.
<br>
<p>So, let's go with CSS3D, and this time, with the help of my mini framework that hides most of the complexity!
<br>Space will be tight, so I removed everything I didn't need from my framework (set_unit(), set_perspective(), pyramid(), cylinder(), many "origins" and all the optional CSS...) and started the project with a ~1kb overhead (instead of 1.7kb for the full package)
<br>
<h4>Baby you can drive my car</h4>
I created two red cubes for the car's body, 4 grey circles for the wheels, 4 grey rectangles perpendicular to the wheels to simulate their depth (when they're seen from behind), added two different shades of red for the back and right faces of the car (for "lighting"), plugged the famous <a href="https://xem.github.io/articles/jsgamesinputs.html">73b JS keyboard controls</a> plus a bit of trigonometry, and after a couple hours, we already have a little controllable car!
<p>Let's go!
<br>
<br><p><img src="images/js13k19/8.gif" width=300>
<br>
<br>Polygon count: 20 (+3 for the ground).
<br>Byte count: 6.59kb commented, 4.55kb minified, 1.69kb zipped.
<br>Hours count: 2 (I only count the hours where I actively work with my pen or my code editor, not all the idle thinking in between :p) 
<br><a href="http://xem.github.io/js13k19/day2">DEMO</a>
<br>
<br>~~
<br>
<h4>Backseating the camera</h4>
Day 3: let's make the camera follow the car but not too rigidly:
<br>Instead of having a fixed view of the back side of the car, it's preferable to see it turn on itself a little when the player presses "left" or "right". The distance car-camera stays fixed though..
<br>
<p>Let's do a bit of math:
<br><p><img src="images/js13k19/9.png">
<br>- At any given moment, the car is at a position [x:y], and rotated on the map with an angle a (here, 45° or Pi/4 radians)
<br>- If the player presses "left" or "right", the angle a decreases or increases.
<br>- If the player presses "up", the car moves 10px along its angle. To do that, we add (cos(a) * 10px) to x and we subtract (sin(a) * 10px) to y.
<br>- If the player presses "down", the car moves back 10px. To do that, we subtract (cos(a) * 10px) to x and we add (sin(a) * 10px) to y.
<br>- To keep seeing the car from behind, the camera must be centered on the new position [x:y], but with an angle equal to -a (-45°).
<br>- The distance car-camera stays fixed "for free" because it is the perspective distance of our CSS3D scene.
<br>- Finally, to make the camera follow the car less rigidly, add a little delay to its position and rotation changes. By chance, this can be done with a CSS transition: "#scene{transition:.25s linear}"
<br>Repeat this 30 times per second and you have a mini racing game!<br>
<br>
<p>Just for the record: this is not easy at all for me. I'm getting more and more used to it, but it still took me a while to figure out which numbers and trigonometric functions I had to use at each step! (and I'm pretty sure the rest will be much harder)
<br>Also, I noticed that Chrome goes crazy when we try to update elements with CSS transitions 30 times per second. So the transitions will be only be enabled on Firefox.
<br>
<h4>Acceleration</h4>
Let's take a moment to make the car accelerate when we press up and decelerate / goes back when we press down.
<br>To do this, we don't update the car's position directly at each frame with a fixed amount.
<br>Instead, we increase or decrease a variable representing the car's speed, and add this speed to the car's position at each frame.
<br>
<p><img src="images/js13k19/10.gif" width=300>
<br>Polygon count: still 23.
<br>Byte count: 6.73kb commented, 4.64kb minified, 1.72kb zipped.
<br>Hours count: 3.
<br><a href="http://xem.github.io/js13k19/day3">DEMO</a>
<br>
<br>~~
<br>
<h4>Where we're going, we need roads! (and barriers)</h4>
<p>Day 4. In Trackmania, all the races and puzzles are made with blocks on a 3D grid.
<br>The most basic block is a brown square laid on the snowy ground (as you can see in the previous GIF's).
<br>When the players place a square block next to another square block (or any other road block that accepts it), they have the possibility to link them, which creates a continuous portion of road.
<br>The two blocks can also stay independent, and have a gutter of snow between them.
<br>To do this, I made my scene consist of a grid of 10in * 10in (where 1in = 96px).
<br>If an independent square block is placed in a cell, it'll be 9in * 9in, centered, and surrounded by snow.
<br>If two square blocks are linked, the game adds a 1in-wide link between them.
<p><img src="images/js13k19/11.png">
<br>(my tests look like this. Yes, it's ugly, and doesn't have any curves. But we gotta start somewhere!)
<br>
<br>
<p>As you can see, Trackmania also adds solid barriers on the sides of every road portion consisting of a least 2 linked square blocks.
<br>I made an algorithm that checks the links of every block and automatically places little barriers (in the form of vertial, grey, CSS3D planes) where they are necessary.
<br>I adapted it to extend their length in the direction of the link, in order to have a continuous barrier between two linked squares.
<p><img src="images/js13k19/12.png">
<p>Tadaaa! Now the (real) challenge is to make the car collide with these barriers. It may take some time.
<br>
<br>
<br>Polygon count: 20 for the car, 120 for these 27 road blocks, their links and their barriers.
<br>Byte count: 11.0kb commented, 6.85kb minified, 2.28kb zipped. (wow, that's huge. I mean, for me.)
<br>Hours count: 4.
<br><a href="http://xem.github.io/js13k19/day4">DEMO</a>
<br>
<br>~~
<br>
<h4>Cleanup and golf #1</h4>
<p>Day 5. Every few days, I re-read my (anarchic) code base and make it clean, commented and lightly golfed.
<br>I started this 5th day by doing this, and it was quite good, because the minified code fell down to 6.02kb and the zipped code to 2.07kb (and 2.03kb with Advzip).
<br>For the record, to benefit from Advzip extra compression, download Advcomp <a href="https://www.advancemame.it/download">here</a>, put advzip.exe in the same folder than your zip, and execute <b>.\advzip.exe -z -4 -i 1000 .\min.zip</b> in the command line.
<br>(To squeeze a dozen extra bytes at the end of the project, replace 1000 by a bigger number, like 100000. It will take a few minutes to complete though!)
<br>
<h4>Collisions!</h4>

<p>Let's start with very basic collision detection: considering that all the road blocks are square, and have 0 to 4 barriers on their sides, and considering that the car can only collide from its front side when going forward and from its back side when going backward.
<p><img src="images/js13k19/13.png">
<p>This can be done pretty easily, by computing on which cell the green point is placed (depending on the direction of the car - forward or backward), and if this point is further than a barrier, the car receives an inverted speed, which makes it bounce gently against the wall instead of passing through it. (In terms of code, the car behaves as if all the grey space after a barrier is an obstacle measuring 0.5in).
<p>Two problems appeared quickly.
<br>- The first one is that a back collision with an angle car-wall around 45 degrees will be detected too late, and the car will start clipping through before being stopped. The solution is to compute collisions on the four sides of the car and not only front and back. (I'll do that later though.)
<p><img src="images/js13k19/14.png">
<p>- The second one is that the car would randomly ignore certain barriers when it drives at full speed against it. But all the devs who do 2D or 3D collisions know this problem. If you have an obstacle in front of you, and your speed and alignment makes you stand before the obstacle at one frame and after the obstacle in the next frame, you'll pass through it. The solution (that I implemented) is to perform many little increments at each frame (5 in my case), and test the collisions at each increment. If one of the increments detects a collision, the car gets stopped at this frame, and this solution is effective 100% of the time. You just have to do enough increments to ensure that one increment at max speed is shorter than the size of any obstacle you can encounter on the map.
<p><img src="images/js13k19/15.png">
<br>
<h4>Live debugger</h4>
<p>Of course, all this can't really be coded blindly, nor by watching hundreds of logs in the JS console, that's why I made a textarea that's always visible on screen and that can be updated 30 times per second. It's very handy!
<br>For example, here, the logs indicate which side of the car is tested, if it's out-of-bounds, on which cell it is, and conclude by telling if the car is driving on the snow (if out of bounds), against a barrier (if there's a collision), or nothing (if it's on the road).
<p><img src="images/js13k19/16.gif" width=400>

<br>

<h4>Screenshot saturday</h4>
<p>It's time to polish a little (by making a little circuit, adding a start line and a cinematic introduction) and present it to the world:
<blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 5.<br>Here are some news of my CSS3D racing game:<br>- Automatic barriers positioning<br>- Collisions with barriers are working!<br>- Many controls and camera adjustments<br>- Code cleaned up<br>- Polygons so far: 233.<br>- Zip size so far: 2.63kb!<a href="https://twitter.com/hashtag/screenshotsaturday?src=hash&amp;ref_src=twsrc%5Etfw">#screenshotsaturday</a> <a href="https://t.co/Q8e7A3rckb">pic.twitter.com/Q8e7A3rckb</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1162769405845155840?ref_src=twsrc%5Etfw">August 17, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 

<br>
<br>Polygon count: 20 + 213.
<br>Byte count: 17.6kb commented, 7.90kb minified, 2.63kb zipped.
<br>Hours count: 6.
<br><a href="http://xem.github.io/js13k19/day5">DEMO</a>
<br>
<hr>
<br>

<p>Wait. 213 polygons seem huge for 31 road blocks with barriers... Upon inspection, I realized each barrier was drawn twice or more (once for each link shared with another road block).

<p>Let's remove them altogether and replace them with black borders. Let's also merge every pair of orange and grey planes into a single orange plane with a grey border.
<p>As a result, the polygon count is down to 87 in total!



<br>
<h4>Show your curves!</h4>
<p>Day 6. My friend told me it was nice but too bit pointy... and I agree.
<br>So let's do another algorithm that automatically rounds every road block with two consecutive road links. This is simply made with a 100% CSS border-radius applied to every corner that is opposite to links.

<p><img src="images/js13k19/17.png">
<br>(Before vs. after vs. after with automatic barriers that follow the curves of the road!)

<br>
<h4>Collisions v2</h4>
<p>Now that all blocks are not square anymore, computing collisions is a bit trickier. Actually, it's a lot harder: it took me all the week-end to figure out how to handle collisions on both sides of every barrier, reliably.
<br><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 6. (3.17 kb)<br>It took me most of the week-end, and it&#39;s not totally finished yet, but the road now has curves. And these curves have functioning collisions. (the black lines represent solid barriers).<br><br>I also reduced my polygon budget a lot: 233 =&gt; 87 <a href="https://t.co/3XEObIjQmB">pic.twitter.com/3XEObIjQmB</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1163175569724530690?ref_src=twsrc%5Etfw">August 18, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>To put it simply, the game engine still needs to check straight barriers collisions like before, and allow to cross from a road block to another if they are linked, or between a road block without barrier and the outside (the snow), and vice-versa.
<br>But once it has ensured all these conditions, it also needs to make all the rounded barriers' collisions work as intended.
<br>To do that, each road block with a curve receives an equation (in the form of a JS function) that is able to tell if the car is on the road or outside.
<br>The result of this equation can be used to determine if the car is trying to go from inside to outside (or the opposite) and block it.
<br>"Block it" was the hardest part of the job: after many buggy attempts, I decided to respond to every collisions with a strong opposite force, which makes the car bounce on every wall, with an opposite speed, before being able to continue going forward in the right direction. (Trackmania kinda did that too, so it's fine! Hee hee).

<br>The collision-testing function is 80 lines long, and is executed with the front side of the car as parameter when the car is going forward, and the back side if it's going backward.

<br>
<p>So, about these equations. It turns out, I couldn't find them by myself, so I asked some help on Twitter and Slack.
<br><blockquote class="twitter-tweet"><p lang="en" dir="ltr">Help?<br>Is there an equation that can tell me if a point [x;y] is inside the black area? (the bottom-right side of a circle with a 50px radius, where x and y are between 0 and 50)<a href="https://twitter.com/hashtag/Math?src=hash&amp;ref_src=twsrc%5Etfw">#Math</a> <a href="https://twitter.com/hashtag/Gamedev?src=hash&amp;ref_src=twsrc%5Etfw">#Gamedev</a> <a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> <a href="https://t.co/Gjhf50joxt">pic.twitter.com/Gjhf50joxt</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1163006546785263616?ref_src=twsrc%5Etfw">August 18, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 
<br>A lot of people flew to help me with the same approach presented in various ways, but all of them implied to compare the distance from the car to the center of the quarter-circle and the radius. This distance can be computed with Pythagore or directly Math.hypot().
<br>To optimize the CPU usage though, people advised me to avoid quare roots as much as I could, so I obeyed and compared the square of deltaX + the square of deltaY to the square of the radius. Perfect! 👌

<br>

<p>To end this week, I finally separated my project in 8 different files, and added comments everywhere so my future self (and people on Github) will be able to understand what I have been doing!

<br>
<br>Polygon count: 20 + 67.
<br>Byte count: 20.0kb commented, 10.00kb minified, 3.17kb zipped.
<br>Hours count: 9.
<br><a href="http://xem.github.io/js13k19/day6">DEMO</a>


<br>
<hr>
<br>
<h3>Week 2</h3>

<h4>3D barriers</h4>

<p>Day 7. I used this day to finish debugging the collision detection of last week-end, then I quickly tested to copy the barriers on multiple layers to make them look less flat. It consumed a lot of bytes and polygons, and wasn't looking as nice as I wanted, because of the lack of anti-aliasing when rendering things in CSS3D on Firefox. Moreover, it was super buggy (visually) on Webkit: all the rounded blocks refused to appear at all! So I discarded this test, and without it, Webkit's display is more or less OK.
<br><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 7.<br>I wanted to make the barriers look higher by copying them on two different layers, but I&#39;m not sure it&#39;s worth it.<br>It costs many extra polygons, and the lack of anti-aliasing is kinda problematic... <a href="https://t.co/9iN4PC36zb">pic.twitter.com/9iN4PC36zb</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1163349106473033728?ref_src=twsrc%5Etfw">August 19, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<br>
<p>Hours count: 11.
<br><a href="http://xem.github.io/js13k19/day7">DEMO</a>
<br>
<hr>
<br>
<h4>TRACK EDITOR!</h4>

<h4>Fighting with CSS</h4>
<p>Day 8. Time to start a big and very important part of the game, the 3D track editor!
<br>Though, very soon, a problem of size appeared: I wanted to display a grid on top of my scene, and dezoom it enough to let the player see the track from above. But when I did that, everything disappeared. The reason was that the scale of my scene was too big for the browser to show at once in CSS3D (I already had this problem when I made LOSSST in 2017: the rooms had to stay very small to avoid being cut or appear glitchy).
<br>Indeed, my grid was comprised of 20 x 20 cells and each cell had a size of 20 x 20 in. (in total: 38400 px x 38400 px).
<br>So the first thing to do was to resize everything: the grid, the car, the road parts, and everything in the JS code that referred to them (camera, display, collision detection).
<br>I also put the base size (100px instead of 20in) in a variable, so it can be adjusted later more easily. With this size, the grid measures 2000px x 2000px and browsers can happily show it!
<br>By the way, I couldn't add 400 polygons in my scene to represent each cell of the grid, it would have made the game extremely slow. Instead, all the lines and columns of the grid are drawn with a repeated linear-gradient, in CSS.

<br><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 8.<br><br>I was tired of writing my roads in JSON...<br>So, It seems like I&#39;m starting a circuit editor.<br>I think it&#39;ll take some days, and a lot of kilobytes, before I have something that looks nice and works! 😬<br>(but here are the first steps anyway) <a href="https://t.co/X8D0RUqtZH">pic.twitter.com/X8D0RUqtZH</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1163896639033135104?ref_src=twsrc%5Etfw">August 20, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<br>
<h4>Inventory</h4>

<p>As you can see in this screenshot, I also started working on the editor's UI, especially the inventory.
<br>My goal is to make each cell of the inventory display one road block and which quantity of this block is remaining.
<br>I could draw these blocks using SVG or PNG's, but to save bytes, I'll draw each inventory road part directly in CSS3D, by reusing the same model as the one used on the track, but rotated 45° and dezoomed to fit in about 20 x 20 px.
<br>It'll require a good organization to make every block of the game, reusable on the track and in the inventory. But that's doable!
<br>
<p>Byte count: 24.3kb commented (I don't try to minify/zip as long as the code contains logs everywhere)
<br>Hours count: 13.
<br><a href="http://xem.github.io/js13k19/day8">DEMO</a>
<br>
<hr>
<br>
<h4>Tools!</h4>
<p>Day 9. Today I have a better idea of what I need to do and how. I'm not stuck with CSS3D limits anymore, so I can focus on the editor's features, namely: moving and rotating the grid, moving the "cursor" (the green square) along with the camera, and place road blocks using the cursor.
<br>
<blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 9.<br><br>My project is a mess, there&#39;s code to clean everywhere, but hey! The track editor has a grid that can go up and down and rotate, and a cursor that moves on the grid, and we can start building!<br><br>(you can&#39;t make stuff like that cleanly anyway, can you?) <a href="https://t.co/tXWOaxNOkx">pic.twitter.com/tXWOaxNOkx</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1164237127481253890?ref_src=twsrc%5Etfw">August 21, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 
<br>Note that I reused most of Trackmania's keyboard shortcuts: arow keys move the cursor, space key draws a block, del key deletes a removable block. All the rest can be done by clicking on the left menu.
<br>Speaking of keyboard shortcuts: I altered the JS keyboard handler a little to support both space, del and enter keys, and I added extra variables for space and arrow keys to handle them when they're pressed once, or when they're held down, because both cases are treated differently. The pressed key flags are reset after each frame, while the other keep being set until the player releases them. It looks like this:
<pre><code class="lang-js">var s = 0, u = 0, l = 0, d = 0, r = 0; // hold (space / up / left / down / right)
var S = 0, U = 0, L = 0, D = 0, R = 0; // press
var _ = 0, $ = 0; // press suppr key, enter key
onkeydown = onkeyup = z => top['lurdl*d*l_ur*u*s$***'[(z.which+3)%20]] = top['LURDL*D*L_UR*U*S$***'[(z.which+3)%20]] = z.type[5]</code></pre>

<br>Byte count: 26.0kb commented.
<br>Hours count: 15.
<br><a href="http://xem.github.io/js13k19/day9">DEMO</a>
<br>
<hr>
<br>
<h4>More blocks</h4>
<p>Day 10. I added the possibility to select blocks in the inventory, rotate them and place them...
<br>I also noticed that my game declares A LOT of global vars, and it's not finished yet!
<br>LOSSST (2017) also had a ton of variables but it wasn't really a problem. The hardest part (for me) was the ton of different CSS variables that I had to rename to 1 char at the last minute. In Back on Track, there will be very few CSS compared to LOSSST. For example, up to now, I only wrote 19 CSS rules, using only 10 CSS classes and 8 ids, which is very few.  
<br><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 10.<br><br>I already have 58 global vars.<br>The 1-char var names A-Z a-z, $ and _ are not enough to hold them all! 😓<br><br>Besides that, the editor now features 3 blocks that can be placed and rotated on the grid. (basic road, start &amp; end flags). They&#39;re not hardcoded anymore! 🥳 <a href="https://t.co/do5V79n5aL">pic.twitter.com/do5V79n5aL</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1164637709597642757?ref_src=twsrc%5Etfw">August 22, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 
<br>Byte count: 28.6kb commented.
<br>Hours count: 16.
<br><a href="http://xem.github.io/js13k19/day10">DEMO</a>
<br>
<hr>
<br>
<h4>UI</h4>
<p>Day 11: I started this day by a little enhancement to my editor's menu:
<br>
<p><img src="images/js13k19/18.png">
<br>All the actions that can be done with the keyboard (move cursor, add and remove road blocks) are now none exclusively with the keyboard.
<br>
<br>Moreover, the menu's buttons are now smaller and contain Unicode arrows to be a bit clearer!
<br>It took some time though, because Unicode arrows are a big mess in terms of OS/browser support.
<br>Hopefully, people on Slack helped me find a little subset of all the Unicode Arrows that can be displayed about everywhere, and I tweeted the result <a href="https://twitter.com/MaximeEuziere/status/1164810114710163456">here</a>.
<br>
<pre><code class="lang-js">←→↑↓↔↕↖↗↘↙⤡⤢↚↛↮⟵⟶⟷⇦⇨⇧⇩⬄⇳⬁⬀⬂⬃⬅➡⬆⬇⬉⬈⬊⬋⬌⬍⇠⇢⇡⇣⤌⤍⤎⤏⤑⤐↼⇀↽⇁↿↾⇃⇂⥊⥋⥌⥍⥎⥐⥑⥏⥒⥓⥖⥗⥔⥕⥘⥙⥚⥛⥞⥟⥜⥝⥠⥡⥢⥤⥣⥥⇋⇌⥦⥨⥧⥩⥪⥬⥫⥭⥮⥯⇈⇊⇇⇉⇆⇄⇅⇵⇐⇒⇑⇓⇔⇕⇖⇗⇘⇙⇍⇏⇎⟸⟹⟺⤂⤃⤄⤆⤇⬱⇶⇚⇛⤊⤋⭅⭆⟰⟱⇤⇥⤒↨⤝⤞⤟⤠↤↦↥↧⬶⤅⟻⟼↸⇱⇲⇜⇝⬳⟿↜↝↭⇷⇸⇹⇺⇻⇞⇟⇼↰↱↲↳⬐⬎⬑⬏↴↵↩↪⤣⤤⤥⤦↫↬⤙⤚⤛⤜⥼⥽⥾⥿🔁🔂🔃🔄⤶⤷⤴⤵➩➪➫➬➭➮➯➱⇪⇫⇬⇭⇮⇯➳➵➴➶➸➷➹➙➘➚➾⇰➛➜➔➝➞➟➠➧➨➺➻➼➽↶↷⤾⤿⤸⤺⤹⤻↺↻⟲⟳⥀⥁</code></pre>

<br>Note: these arrows can have very different look across different OS's, and about half of them will break completely the layout of monospace text, but besides that, they work!

<br>
<p>I also saw that the arrow keys (making the cursor move) became all wrong when the grid (i.e. the whole scene) was rotated 90, 180 or 270°.
<br>Indeed, if the scene is rotated 90°, top becomes left, left becomes bottom, etc.
<br>So I improvised a little hack (I mean, a coding trick) to reassign the arrow keys according to the scene's angle. It worked on the first try!
<pre><code class="lang-js">// Adjust arrows based on grid angle
for(i = 0; i < gridrz/90; i++){
  [U,R,D,L] = [R,D,L,U]
}</code></pre>

<br>
<h4>Links, barriers, turns, equations (again)</h4>
<p>But let's get back to serious business! Let's plug in the algorithms I made last week: the one that creates links between road blocks, the one that generates the barriers, the one that makes the curves, and the one that generates the equations for every curved block.
<br>It took some hours to have it all behave well, but I did it!
<br><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 11.<br><br>Guys! Check this out!<br><br>It took me all day and required 4kb of code, but I made this thing work at last:<br><br>My track editor now computes curves and barriers instantly and automatically when I link two road blocks AND when I delete blocks too!🤩<a href="https://twitter.com/hashtag/screenshotsaturday?src=hash&amp;ref_src=twsrc%5Etfw">#screenshotsaturday</a>-1 <a href="https://t.co/4V7dGar652">pic.twitter.com/4V7dGar652</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1164909253884358656?ref_src=twsrc%5Etfw">August 23, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<br>It also took some time to implement the "hold space and move the cursor" mechanic to create a link between two existing blocks, or between an existing block and a new block created at the same time.
<br>I have to admit I'm very happy of this achievement. For the first since this project started, I'm thinking that maybe, if there's no bad surprise, it could probably become something nice.

<br>Fun fact: I made a random tweet explaining that I had lost 30 minutes for a stupid typo in a for loop. This tweet has had more likes and answers than any of my other #js13k tweets this year. I guess it's much more relatable than anything else I'm doing, eh? 🤷

<br><blockquote class="twitter-tweet"><p lang="en" dir="ltr">Guess who lost 30 min because of this line?<a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> <a href="https://t.co/qLVcXqWBxa">pic.twitter.com/qLVcXqWBxa</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1164889745299824643?ref_src=twsrc%5Etfw">August 23, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<br>And to finish this day very well (or not well at all), <a href="https://twitter.com/MaximeEuziere/status/1164986420198592512">I almost lost all my progress of the last 24 hours</a> because of my laptop acting super weird. Lesson learned: PUSH OFTEN, not just once per day!

<br>
<br>Byte count: 32.1kb commented.
<br>Hours count: 19.
<br><a href="http://xem.github.io/js13k19/day11">DEMO</a>
<br>
<hr>
<br>
<h4>Completing the inventory</h4>
<p>Day 12: Today, let's modelize new road parts! I played all the puzzles and races of the snow and desert environments and listed those:
<ul>
<li>start flag (OK)
<li>end flag (OK)
<li>checkpoint flag
<li>flat road (OK)
<li>accelerator
<li>accelerator going down
<!--li>- accelerator going up-->
<li>jumper
<li>short slope
<li>long slope rounded on the bottom, like ◞
<li>long slope rounded on the top, like ◜
<li>road that goes slanted on the side (ignoring it for now because ugh!)
</ul>

<br>
<p>The good news is that it's not a lot. I only have 8 new parts to make.
<br>The less good news is that most of these blocks have special features and limitations that will require a lot of code to implement:
<ul>
<li>all the blocks except the flat roads will have barriers on their front and their back until they're linked to another block.
<li>jumpers can only have one link on their back
<li>slopes and slopes-accelerator are special because they have one link on a certain height's plane and the other link on the upper plane.
<li>and on top of that, long slopes occupy two cells of the grid.
<li>snow, desert and castle environments have different ways to use barriers and prop/supports when the road is higher than the ground, and different ways to link slopes, but we'll see that another day!
</ul>

<br>
<p>But let's start by the 3D models. With CSS3Dframework, it's just a matter of 2 or 3 lines of code per block.
<br>The checkpoint flag is similar to the start and end flags.

<br><p><img src="images/js13k19/19.png">

<br>
<p>The accelerators (flat and slanted) are covered with yellow triangles. This can be done in many different ways (CSS, SVG, Unicode...), but I went with the one that seemed to require the least amount of code and resources: a repeating double linear-gradient in background.
<br>I took an example on <a href="https://leaverou.github.io/css3patterns/#half-rombes">Lea Verou's CSS3 patterns gallery</a>, simplified the code, and applied it to a road block. TADAAA.

<br><p><img src="images/js13k19/20.png">

<br><p>The jumper and slopes are simply made of one or two slanted planes.

<br><p><img src="images/js13k19/21.png">

<br><p>As I said on day 8, the parts shown in the inventory are the same "3D models" as the ones on the track, but displayed in a tiny space and with a 45° angle. Each slot of the inventory is a separate CSS3D container with a "500px" perspective, similarly to the scene. Here's how the scene and the inventory look with every block represented:

<br><p><img src="images/js13k19/22.png">

<br><p>There's another special place where these road blocks are rendered: the editor's cursor. But it's less tricky here because it's rendered in the scene with all the other blocks. It's just that it can be replaced with any other block instantly when clicking an inventory item.

<br><p>Oh, also: as I said <a href="https://twitter.com/MaximeEuziere/status/1165311745524752387">here on Twitter</a>, this whole scene only uses 61 polygons, which is very reasonable!

<br>
<br>Byte count: 35.2kb commented.
<br>Hours count: 21.
<br><a href="http://xem.github.io/js13k19/day12">DEMO</a>

<br>
<hr>
<br>
<h4>Connect all the things!</h4>
<p>Day 13: During the next days, my goal is to make all these new blocks connectable with each other. All the blocks except the basic road square don't need to be manually linked to their neighbours: when you place these blocks on the scene, if a compatible block is already present at one of their link points, and has the right orientation, the link will be automatic. And inversely, a new basic road block will automatically be linked to a neighbour non-basic road block if both are linkable together.

<br>
<p>The most annoying part here is to organize the data. each cell of the 3D world must know a ton of information:
<ul>
<li>if it's fixed or deletable
<li>what inventory item it refers to
<li>if it's free or occupied by a road block or a prop,
<li>if it can make links on its up/right/down/left side and at which coordinates,
<li>if it has a link on its up/right/down/left side,
<li>if it is flat or rounded on its up/right/down/left side,
<li>if it has a barrier on its up/right/down/left side,
<li>the coordinates of its surrogate block(s) in case of double block or slope
<br>the coordinate of the main block in case of surrogate
<li>its angle (0 90, 180 or 270),
<li>and its out-of-bounds equation.
</ul>

<pre><code class="lang-js">// Example data for a basic road block (id #0) that is rounded on the bottom left and linked to other blocks on its up and right sides.

space[x][y][z] = {
  fixed: 0,
  free: 0,
  id: 0,
  inventoryid: 0,
  linkable: { u: [x, y-1, z], r: [x+1, y, z], d: [x, y+1, z], l: [x-1, y, z]},
  links: { u: [x, y-1, z], r: [x+1, y, z], d: 0, l: 0 },
  flat: { u: 1, r: 1, d: 0, l: 0 },
  barriers: { u: 0, r: 0, d: 1, l: 1 },
  surrogates 0,
  surrogate_of: 0,
  slope: 0,
  angle: 0,
  equation: `Math.hypot(x-${x},y-${y},z-${z})>size*.8`
}</code></pre>

<br><p>Every time a block is added or removed in the scene, all these pieces of information must be computed or updated, for that block, and for all its neighbours. (plus the neighbours on the higher level if it's a slope).

<br><p>I cleaned the code and the data to be able to do this well, and since it's saturday, let's take a moment to minimize and zip what we have so far:

<br>

<blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 13.<br>I&#39;m optimizing the organization of the editor&#39;s code and my data models.<br>It takes a while to figure out the best solution.<br>Anyway, the fun fact is that my minified JS is exactly 13kb!<br>And my zip is only 4.25kb, after all the things I&#39;ve added these past few days🤯 <a href="https://t.co/BlfRI7mTmU">pic.twitter.com/BlfRI7mTmU</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1165729472773087232?ref_src=twsrc%5Etfw">August 25, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<br>Byte count: 33.9kb commented, 4.25kb zipped!
<br>Hours count: 23.
<br><a href="http://xem.github.io/js13k19/day13">DEMO</a>

<br><p>This zip size reminds me that I can actually write A LOT of code, even if it's dirty or copy pasted everywhere, and still, stay far below the zip limit. That's a relief!
<br>
<hr>
<br>
<br>
<h3>Week 3</h3>
<h4>Pillars</h4>
<p>Day 14: Today is the end of my summer holidays, so I'll have to work on my game before and after work, and of course on the weekends.

<br><p>So to start gently, today I added pillars! There are pillars below every slope block, but there are also extra (or extended) pillars below every elevated block, i.e. the ones that are higher than the ground.
<br>Each pair of pillars is a single plane, where the background is a vertical linear-gradient representing two black columns.
<br><p>An elevated block will have a maximum of 2 extra polygons for its pillars, or 3 for the long blocks that cover two cells. So, all in all, the byte count and the polygon count didn't explode today, and that's a great news!

<br><p><img src="images/js13k19/23.png">

<br><p>For example, this scene contains 75 polygons. It could be reduced a little with some extra optimizations, but the count is roughly correct.

<br><p>After posting the <a href="https://twitter.com/MaximeEuziere/status/1166031352199897090">obligatory WIP tweet</a>, I received many enthusiastic messages of people and friends realizing that it'll be a real 3D game, and that it could be much more fun this way!

<br>
<br>Byte count: 37.8kb commented.
<br>Hours count: 23.
<br><a href="http://xem.github.io/js13k19/day14">DEMO</a>

<br>
<hr>
<br>
<p>Day 15: Let's do this (slightly annoying) links thing. And to begin, the "start", "end" and "checkpoint" blocks.
<ul>
<li>They have barriers on the left and right sides, if they're placed on the ground.
<li>"Start" has a third barrier on the back, and "end" on the front.
<li>"Start" and "end" can only have one link with another block, on the front and on the back, respectively. "Checkpoint" can have both.
<li>If the links don't exist (yet), a barrier is added on the corresponding side(s).
<li>If there's a block on the cell placed in front (or back, or both) that is linkable at its corresponding side, the two blocks get linked.
<li>The out-of-bounds (OOB) equation is the same as the basic square block (inbounds if 20<X<80; 20<Y<80; Z=0. Y is extended up to 0 and/or 100 if there's a link on the back or on the front).
</ul>

<br>And of course, all of this is complicated because all the blocks can be rotated. Depending on their angle, the "forward" side of a block will effectively be the one placed on its right, back or left side. It's a bit puzzling at first, especially to place barriers and rounded corners at  the right places, but I'm getting used to it.

<br><p><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 15.<br><br>I&#39;m (finally) making all the editor&#39;s blocks connectable with each other!<br><br>- Road blocks can be linked in all four directions.<br>- Start block can only be linked forward.<br>- End block can only be linked backward.<br>- Checkpoint can be linked forward and backward.<br><br>TBC. <a href="https://t.co/nJS0EM0iks">pic.twitter.com/nJS0EM0iks</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1166431687028482049?ref_src=twsrc%5Etfw">August 27, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 

<br>
<br>Byte count: 44.0kb commented!
<br>Hours count: 25.
<br><a href="http://xem.github.io/js13k19/day15">DEMO</a>

<br>
<hr>

<p>Day 16: We're already at the half of the compo! Well, let's continue implementing links with the jumper (that can only have one link on its back) and the accelerator (front and back).
<br>
Their OOB equations are a bit different though. Accelerator has its Y value going from 0 to 100, and jumper from 50 to 100 (if their angle equals zero). Also, the jumper is not flat, so its equation will contain a Z value between 0 (on the edge) and 25px (on the middle)  
<br>
All the other blocks are slopes, but we'll see that later!

<br><p><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 16.<br><br>My editor now supports links with the (red) jumper and with the accelerator.<br><br>The commented source code is getting huge: 47kb!😨 (I abuse copy-paste a little tho...)<br><br>I&#39;m fixing the texture of the accelerator and the next step is to make the slopes work!<br><br>TBC. <a href="https://t.co/sINTs4jBku">pic.twitter.com/sINTs4jBku</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1166763652634030090?ref_src=twsrc%5Etfw">August 28, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<br>Slopes are similar to checkpoint and accelerators in the sense that they can only have links on the front and back sides.
<br>
Of course, one thing really differs: the fact that they're linkable to a cell on the same level and a cell one level higher.
<br>Also, they don't have barriers on the sides and on top of the slope, at least in the snow world. Some adjustments will be needed in the other worlds.
<br>Anyway, the "linkable" object in the data model I showed on day 13 is going to come in handy here: concretely, each cell will know if it can have links in each of its four directions, but also at which coordinates the linked blocks must be placed.
<br>For example, a slope going up at coordinates [x,y,z] will be linkable to the cell [x,y+1,z] on the back, and to the cell [x,y-1,<b>z+1</b>] on the front.
<p><br>Oh! An extra check has to be made when placing a block: the cell directly above a slope can't be used for another block, to avoid this kind of collision:

<br><p><img src="images/js13k19/24.png">

<br>Inversely, a slope can't be placed on the cell directly under an existing block, for the same reason.
<br>Finally, in the original game, the "slope up" double-block couldn't be placed on the ground, I'm not sure why.

<br><p><img src="images/js13k19/25.png">

<br>I thought this was because these blocks HAD to be connected to a descending block, but no: we can totally have two such blocks face to face: 🤷

<br><p><img src="images/js13k19/26.png">

<br><p>It definitely looks like a bug. and I won't copy it.
<br>I started the implementation today, but see you tomorrow!
<br><p>PS: before going to bed, I'm realizing that this project is probably the most complex program I have written so far as a JS dev. The complexity of my own code is difficult to handle for me, especially with all those interconnectable pieces on a 3D grid, but it's still cool because it's the kind of challenge I wanted for this year's compo. 
<br>Unfortunately (or not), this complexity won't be really visible for the players or the judges, unless they take a look at my source code... 
<br>But hey, what's important is to make something fun! Invisible complexity is not a bad thing in a fun game.
<br>I can't really complain anyway, because many JS devs (and other JS13K contestants) have already told me that it's super impressive, especially for a CSS3D game, so overall, my efforts are definitely not unnoticed. :D

<br>
<br>Byte count: 47.1kb commented!
<br>Hours count: 26.
<br><a href="http://xem.github.io/js13k19/day16">DEMO</a>

<br>
<hr>
<br>

<p>Day 17: After a lot of background work to set and handle the data correctly, I finally made everything connectable! (the scene shown below uses 164 polygons)

<br><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> Day 17 update.<br>YAY, I DID IT!<br>Everything is connectable, even the slopes!<br>It&#39;s rough, but all is in place. <a href="https://t.co/p6MQnLXm5K">pic.twitter.com/p6MQnLXm5K</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1167169771441446912?ref_src=twsrc%5Etfw">August 29, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<br>

<p>I was also mentioned in this super sweet tweet by @CarelessLabs:

<br><blockquote class="twitter-tweet"><p lang="en" dir="ltr">In awe of all the <a href="https://twitter.com/hashtag/JS13k?src=hash&amp;ref_src=twsrc%5Etfw">#JS13k</a> entries progress, so many talented devs, artists and musicains. Check out <a href="https://twitter.com/js13kGames?ref_src=twsrc%5Etfw">@js13kGames</a> here are several of those taking part:<a href="https://twitter.com/femtosonic?ref_src=twsrc%5Etfw">@femtosonic</a><a href="https://twitter.com/remvst?ref_src=twsrc%5Etfw">@remvst</a><a href="https://twitter.com/KilledByAPixel?ref_src=twsrc%5Etfw">@KilledByAPixel</a><a href="https://twitter.com/dhmstark?ref_src=twsrc%5Etfw">@dhmstark</a><a href="https://twitter.com/EdJLynch?ref_src=twsrc%5Etfw">@EdJLynch</a><a href="https://twitter.com/castpixel?ref_src=twsrc%5Etfw">@castpixel</a> <a href="https://twitter.com/Calada2?ref_src=twsrc%5Etfw">@Calada2</a> <a href="https://twitter.com/MaximeEuziere?ref_src=twsrc%5Etfw">@MaximeEuziere</a> <a href="https://twitter.com/stas?ref_src=twsrc%5Etfw">@stas</a><a href="https://twitter.com/64Mega?ref_src=twsrc%5Etfw">@64Mega</a><a href="https://twitter.com/MallinsonBen?ref_src=twsrc%5Etfw">@MallinsonBen</a> <a href="https://t.co/fxb580APVo">pic.twitter.com/fxb580APVo</a></p>&mdash; Careless Coder (@CarelessLabs) <a href="https://twitter.com/CarelessLabs/status/1167214674938605569?ref_src=twsrc%5Etfw">August 29, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 

<br>
<br>Byte count: 59.6kb commented
<br>Hours count: 28.
<br><a href="http://xem.github.io/js13k19/day17">DEMO</a>

<br>
<hr>

<br>
<h4>Let's go pixel-perfect</h4>
<p>Day 18: So all the blocks are linked, that's for sure. Though, all the links on the scene are still identical to the ones between basic road blocks, and it's not ideal. Let's enable the almighty CSS debug tool: <b>*{border:1px solid red}</b> !

<br><p><img src="images/js13k19/28.png">

<br>
<p>All the links represented by a blue arrow are between a slope and a flat road block. I need to detect this case and make them shorter, so that they don't go over or under the slope at all.
<br>The green arrow (the second on the right) represents a link between two slopes. In that case, the link must not be drawn at all, because the slopes are long enough to touch each other.

<br><p><img src="images/js13k19/29.png">

<br>
<p>After many tries and adjustments, All the "semi-links" between a flat block and a slope are finally okay (blue arrows), and all the links between two slopes are not rendered, as intended (green arrows)!

<br>Now that this is okay, let's zoom radically and make micro adjustments to have all the parts interconnect more smoothly (when I modelized them a few days ago, it was a bit rough and imprecise, but now I have all that I need to finalize them).

<br><p><img src="images/js13k19/30.png">

<br>
For example, the simple slopes had pillars that were a bit too high and went through the road, and their angle and length was a little wrong too, which is highlighted with the zoom and red borders. But why was the angle wrong in the first place? When I reduced the blocks' heights from 100 to 50px, I also reduced the angle from 45° to 45/2 = 22.5°. And that's where I was wrong.

<br><blockquote class="twitter-tweet"><p lang="en" dir="ltr">I have a (dumb) Maths question for <a href="https://twitter.com/hashtag/JS13k?src=hash&amp;ref_src=twsrc%5Etfw">#JS13k</a> !<br>Each of these two slopes are placed in a virtual cell that measures 100px (width) * 100px (height) * 50px (height), represented by this roughly drawn blue box.<br>Why is the slope angle equal to 26.5° and not 45/2=23.5° ? 🤔 <a href="https://t.co/Qb8E5U7YRj">pic.twitter.com/Qb8E5U7YRj</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1167429404374573056?ref_src=twsrc%5Etfw">August 30, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<br><p><img src="images/js13k19/31.png">

<br>
<p>The answer came from @remvst, @randytayler and @mmastrac (thanks to them!)
<br>The angle I wanted is actually: <b>atan2(100,50)</b> in radians, i.e. about 26.5°.

<br>
<p>I made the same kind of adjustments for all slopes and all links. Here's a little close-up:
<br><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 18.<br><br>Yesterday, the blocks were indeed &quot;linked&quot; together, but with little gaps and overlaps everywhere. These little defects will be visible during the race.<br><br>So today, I made every connection absolutely seamless!<br>(you can see better with the red wireframe debugger) <a href="https://t.co/OpEEqVfp1O">pic.twitter.com/OpEEqVfp1O</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1167524036492038144?ref_src=twsrc%5Etfw">August 30, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 
 

<br>
<br>Byte count: 62.2kb commented
<br>Hours count: 31.
<br><a href="http://xem.github.io/js13k19/day18">DEMO</a>

<br>
<hr>

<br>
<h4>Fixes</h4>
<p>Day 19: I spent the morning and a good part of the afternoon fixing all the little details in the editor that I kept for the end, (and cleaned up the code a little while doing it), such as:
<ul>
<li>When we link two road blocks by pressing space + arrow, don't recompute all the links / barriers / turns at each frame, but only when the block is actually added in the scene (it seems obvious said like that, but until I found it, the editor became laggy every time "space" was pressed)
<li>When we create a slope, remember the coordinates of all its surrogates. (Note: for a slope, the cell directly above it is an invisible surrogate to avoid placing another block here. for a long slope, there are 3 surrogates: the second half of the slope, and the block above each half of the slope).
<li>When we want to create a slope, ensure that all its surrogates are on a free spot.
<li>When we delete a slope, also delete all its surrogates.
<li>When we press DEL while the cursor is on a surrogate, delete the main block to which the surrogate is attached.
<li>Automatically link a basic and a non-basic road blocks if they are neighbours (no need to press space + arrow to make these links).
<li>Make the flags shorter.
<li>When we delete a slope, also delete all the links it has with its neighbours.
</ul>

<br>I made another silly tweet that had more success than my usual WIP tweets:

<br><p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">I just had a &quot;why doesn&#39;t it work?! (...) oh, that&#39;s why. But then, how could it have worked before?!&quot; moment.<a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1167715823034802176?ref_src=twsrc%5Etfw">August 31, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 

<br>
<h4>Decorations</h4>
<p>Then, the evening, I modelized three decoration items that are also an important part of the game:
<br>- Two kind of obstacles: the trees and the ice/rock blocks (made out of cubes)
<br>- The ice planes, on which the car cannot brake or turn.
<br><p>The original game also features holes, but it would require too many polygons and computations to implement, especially for jointed holes, so I'll replace them with obstacles.

<br><p>I showed the trees and rocks in this #screenshotsaturday video, along with a track being builded from start to end:
<br><br><p><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 19<br><br>Track editor is officially complete, with 10 different road parts, trees (always facing the camera) &amp; mountains. Graphics are not final yet.<br><br>Project so far:<br>- 35 hours of code<br>- 2382 lines of code<br>- 78kb commented<br>- 35k minified<br>- 6.6k zipped!<a href="https://twitter.com/hashtag/screenshotsaturday?src=hash&amp;ref_src=twsrc%5Etfw">#screenshotsaturday</a> <a href="https://t.co/DVw4FZgFdC">pic.twitter.com/DVw4FZgFdC</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1167888218324230144?ref_src=twsrc%5Etfw">August 31, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 

<br><p>The trees are made with emoji, and they're made of "billboards", i.e. planes that always face the camera. It's a feature I used in LOSSST in 2017, and implemented in CSS3Dframework.
<br>
To put it simply, every time the camera rotates with an angle "a", all the billboards rotate with an angle "-a" to keep facing the camera. The CSS transitions make both rotations (the scene and the trees) effortless.

<br><p><img src="images/js13k19/25.gif">

<br><p>The ice is made with planes sharing the same CSS linear-gradient and background-position, so they can be superposed and seem like a single piece of ice.

<br><p><img src="images/js13k19/32.png">

<br><p>As I said in the tweet above, even with all these hours and lines of code, I only filled half of my zip, which is great (and terrifying)! The big amounts of copy-pastes with just one little change in the middle are certainly part of this very good compression ratio.

<br><p>Thanks also to everyone on Slack and on Twitter (such as <a href="https://twitter.com/______Patton/status/1167906463609540608">@______patton</a> today) for their hype and support!

<br>
<br>Byte count: 71.8kb commented, 34.4kb minified, 6.63kb advzipped.
<br>Hours count: 35
<br><a href="http://xem.github.io/js13k19/day19">DEMO</a>

<br>
<hr>
<br>

<h4>Export!</h4>
<p>Day 20: The game will feature many built-in puzzles and races, and each of these tracks will be made with the editor.
<br>So, while I'll make all these tracks, I'm adding a temporary export button in the menu, that will give me a big, condensed JSON object containing the position and angle of all the road blocks and the list of all the useful road links.
<br>However, the inventories of each puzzle will be edited manually, as well as the ice planes, because building an UI dedicated to make them editable would take me more time than making them manually.
<br>I'm also adding an import button allowing me to paste JSON and build a level from a hardcoded JSON. This will allow me to edit my levels and ensure that my loading code works normally.

<br><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 20.<br><br>Since all the tracks built in the game will be made using the editor, I needed some admin tools to export and import levels correctly. Here they are!<a href="https://twitter.com/hashtag/screenshotsaturday?src=hash&amp;ref_src=twsrc%5Etfw">#screenshotsaturday</a> + 1 <a href="https://t.co/sMeuupHtlu">pic.twitter.com/sMeuupHtlu</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1168243696678166529?ref_src=twsrc%5Etfw">September 1, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<br><p>This is not super visible in the captures above, but here's the format used for export and import:
<br>- "roads" is an array containing arrays representing each block in this form: <b>[x,y,z,id,angle]</b>
<br>- "roadlinks" is an array containing every link between two basic blocks in this form: <b>[[x1,y1,z1][x2,y2,z2]]</b>
<br>Note: the links between a basic and a non-basic block or two non-basic blocks are automatic, so they're not included here.

<br><p>For example, for this little track containing 8 blocks and 8 links, but only 6 links between two basic blocks:

<br><p><img src="images/js13k19/33.png">

<br>Here is the exported JSON (it could be less verbose, but it would take a lot of time and code to decode, and it's not a priority right now):

<pre><code class="lang-js">{"roads":[[3,6,0,1,0],[3,5,0,0,0],[4,5,0,0,0],[5,5,0,0,0],[5,6,0,0,0],[4,6,0,0,0],[4,4,0,0,0],[4,3,0,2,0]],"roadlinksmin":[[[3,5,0],[4,5,0]],[[4,5,0],[5,5,0]],[[5,5,0],[5,6,0]],[[5,6,0],[4,6,0]],[[4,6,0],[4,5,0]],[[4,5,0],[4,4,0]]]}</code></pre>

<p>Of course, when I load this data, I have to reconstruct every automatic link not listed in the roadlinks array and draw everything on the scene.

<br><p>(Note from the next day: This was only good in theory. Turns out, relinking automatically everything was finally more time and code consuming than keeping all the links in the JSON, so I finally reverted that.)

<br>
<br>Byte count: 73.7kb commented
<br>Hours count: 37
<br><a href="http://xem.github.io/js13k19/day20">DEMO</a>

<br>
<hr>
<br>
<h3>Week 4</h3>

<h4>Music!</h4>

<p>Day 21: Today, I asked my prodigious musician friend @d_nghia to reinterpret little samples of Trackmania Original, using my tool <a href="https://xem.github.io/miniOrchestra/">MiniOrchestra</a>.

<br>The original OST is available on <a href="https://www.youtube.com/playlist?list=PLxKPJbOker-C5nkFDy64-UxBAAxxVu9HO">this Youtube playlist</a>.

<br>To save time and space, I asked him to do only a few seconds of the menu, and a few dozen seconds of the snow race and the snow editor, that I will play in loop in the corresponding parts of my game.

<br>While doing this, he found many bugs and limitations in MiniOrchestra, so I fixed them "in live" to help him work in the best possible conditions.

<br>His most complex "race" composition looks like this in MiniOrchestra:

<br><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 21<br><br>I&#39;m working on the 32 built-in tracks of the game!<br><br>In the meantime, my teammate/friend/musician <a href="https://twitter.com/d_nghia?ref_src=twsrc%5Etfw">@d_nghia</a> made me 3 incredible musical themes that will be played in the menus, the editor and the races!<br><br>(Here&#39;s how the race theme looks in <a href="https://t.co/GezceFapiD">https://t.co/GezceFapiD</a> ! <a href="https://t.co/W2kdNiGgO1">pic.twitter.com/W2kdNiGgO1</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1168610116578488320?ref_src=twsrc%5Etfw">September 2, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 

<br>And the corresponding exported code looks like this:

<br><pre><code class="lang-js">[{"octave":"220","duration":".19","decaystart":".18","decayduration":".005","interval":".2","volume":".3","wave":"sine","data":[[0,16],[1,16],[6,18],[3,18],[5,18],[8,20],[9,20],[11,21],[13,21],[14,21],[21,23],[22,23],[24,20],[25,20],[27,21],[29,21],[30,21],[23,23],[16,23],[17,23],[18,23],[19,23],[20,23],[32,16],[33,16],[35,18],[37,18],[38,18],[40,20],[41,20],[43,21],[45,21],[46,21],[48,23],[49,23],[50,23],[51,23],[52,23],[53,23],[54,23],[55,23],[56,20],[57,20],[59,21],[61,21],[62,21],[31,18],[63,18],[65,16],[64,16],[67,18],[69,18],[70,18],[72,20],[73,20],[75,21],[77,21],[78,21],[80,23],[81,23],[82,23],[83,23],[84,23],[85,23],[86,23],[87,23],[88,20],[89,20],[91,21],[93,21],[94,21],[95,18],[96,16],[97,16],[99,18],[101,18],[102,18],[104,20],[105,20],[107,21],[109,21],[110,21],[112,23],[113,23],[114,23],[115,23],[116,23],[117,23],[118,23],[119,23],[120,20],[121,20],[123,21],[125,21],[126,21],[127,18],[128,16],[129,16],[136,18],[137,18],[144,23],[145,23],[152,20],[153,20],[155,21],[157,21],[158,21],[160,16],[161,16],[168,18],[169,18],[176,23],[181,23],[190,21],[135,17],[167,17],[177,23],[180,23],[184,20],[185,20],[187,21],[189,21]]},{"octave":"440","duration":".19","decaystart":".18","decayduration":".005","interval":".2","volume":".1","wave":"sawtooth","data":[[0,16],[0,9],[1,9],[1,16],[3,18],[3,11],[5,18],[6,18],[5,11],[6,11],[8,20],[8,13],[9,13],[9,20],[11,21],[11,14],[13,21],[14,21],[13,14],[14,14],[16,23],[17,23],[19,23],[21,23],[22,23],[23,23],[20,23],[18,23],[24,20],[25,20],[24,13],[25,13],[27,21],[27,14],[29,21],[30,21],[29,14],[30,14],[32,9],[33,9],[32,16],[33,16],[35,11],[37,11],[38,11],[35,18],[37,18],[38,18],[40,20],[41,20],[40,13],[41,13],[43,14],[45,14],[46,14],[43,21],[45,21],[46,21],[48,23],[49,23],[51,23],[52,23],[53,23],[54,23],[55,23],[50,23],[56,20],[57,20],[56,13],[57,13],[59,21],[59,14],[61,14],[62,14],[61,21],[62,21],[128,16],[129,16],[128,9],[129,9],[136,18],[137,18],[136,11],[137,11],[144,23],[145,23],[153,20],[153,13],[158,14],[158,21],[160,9],[161,9],[160,16],[161,16],[168,11],[169,11],[168,18],[169,18],[176,23],[181,23],[16,16],[18,16],[19,16],[21,16],[22,16],[23,16],[20,16],[17,16],[48,16],[49,16],[50,16],[52,16],[53,16],[54,16],[55,16],[51,16],[145,16],[144,16],[176,16],[159,21],[159,14],[156,14],[156,21],[154,20],[154,13],[181,16],[185,20],[190,21],[185,13],[190,14],[177,16],[177,23],[186,13],[186,20],[188,21],[191,21],[191,14],[188,14],[180,16],[180,23]]},{"octave":"440","duration":".19","decaystart":".18","decayduration":".005","interval":".2","volume":".06","wave":"sawtooth","data":[[64,16],[65,16],[64,9],[65,9],[67,18],[69,18],[70,18],[67,11],[69,11],[70,11],[72,20],[73,20],[72,13],[73,13],[75,21],[75,14],[77,14],[78,14],[77,21],[78,21],[80,23],[81,23],[82,23],[83,23],[84,23],[85,23],[86,23],[87,23],[80,16],[82,16],[85,16],[86,16],[87,16],[84,16],[83,16],[81,16],[88,13],[89,13],[88,20],[89,20],[91,14],[93,14],[94,14],[91,21],[93,21],[94,21],[96,9],[96,16],[101,11],[101,18],[104,20],[104,13],[109,14],[109,21],[97,9],[97,16],[99,11],[102,11],[99,18],[102,18],[105,13],[105,20],[107,21],[107,14],[110,14],[110,21],[112,23],[113,23],[114,23],[115,23],[116,23],[117,23],[118,23],[119,23],[112,16],[113,16],[114,16],[115,16],[116,16],[117,16],[118,16],[119,16],[120,13],[121,13],[120,20],[121,20],[123,21],[125,21],[126,21],[123,14],[125,14],[126,14]]},{"octave":"440","duration":".19","decaystart":".18","decayduration":".005","interval":".2","volume":".22","wave":"square","data":[[64,18],[65,16],[66,13],[72,18],[73,16],[74,13],[80,18],[81,16],[82,13],[88,18],[89,16],[90,13],[91,16],[92,11],[93,10],[94,11],[95,13],[96,18],[97,16],[98,13],[104,18],[105,16],[106,13],[112,18],[113,16],[114,13],[120,18],[121,16],[122,13],[123,16],[124,11],[125,10],[126,11]]},{"octave":"440","duration":"1.5","decaystart":".5","decayduration":"1","interval":".2","volume":".22","wave":"square","data":[[67,16],[75,16],[83,16],[99,16],[107,16],[115,16],[127,16]]}]</pre></code>

<br>The total size for the three tracks and the player is very reasonable: 6.05kb minified, and about 1.74kb zipped). 

<br><p>And in the meantime, I asked <a href="https://twitter.com/MaximeEuziere/status/1168571426632343552">on Twitter</a> how to stop an Oscillator  "O" attached to a GainNode "G" attached to an AudioContext "A" anytime. Turns out, the answer (found on StackOverflow) is to do <b>A.close()</b>.

<h4>Built-in tracks!</h4>

<p>But let's not stop there, the clock is ticking!
<br>So I spent the evening (re)playing and screenshotting every race and puzzle track of the original game. 8 + 8 for the snow world, and 8 + 8 for the desert world. Unfortunately, the third world doesn't work on my PC so I won't do it for now.
<br>I have noticed a few road parts that were not modelized yet, but I won't redo them all, only the two that are really necessary: the ascending accelerator, and (spoiler warning) the straight line with a hole in the middle.
<br>I'll do them tomorrow.

<br>
<br>Byte count: 80.2kb commented
<br>Hours count: 39
<br><a href="http://xem.github.io/js13k19/day21">DEMO</a>

<br>
<hr>
<br>


<p>Day 22: After adding the two new blocks...

<br><p><img src="images/js13k19/34.png">

<br>I started rebuilding the 32 tracks of the game with my editor, and adding inventories and ice planes manually where they were needed.
<br>The tracks are not exact copies, but they're as close as possible to the originals.
<br>While making these tracks, I found many little bugs in the editor (misplaced links, barriers, surrogates here and there), so it's a good thing I went through this soon enough to fix them!

<br><p>11 tracks added today, representing about 1.58kb zipped...

<br>
<br>Byte count: 90.9kb commented
<br>Hours count: 41
<br><a href="http://xem.github.io/js13k19/day22">DEMO</a>

<br>
<hr>
<br>

<p>Day 23: 12 new tracks added today... and more editor fixes.
<br>I'm stopping there for now because they take a lot of room and time.
<br>Tomorrow, I start the 3D racing implementation!

<br><p>On a personal note, I'm going through a lot of doubt right now.
<br>I see all the other 3D entries being made, and mine looks very basic in comparison. What if people don't find it fun? What if it doesn't run well enough on everyone's desktop? or worse, what if I don't manage to ship it on time? I'm doing my best, but I'm still very unsure of the outcome.

<br><p><img src="images/js13k19/2.jpg">

<br>
<br>Byte count: 112kb commented
<br>Hours count: 43
<br><a href="http://xem.github.io/js13k19/day23">DEMO</a>

<br>
<hr>
<br>

<h4>Menu-ing!</h4>

<p>Day 24: To fix the bad mood from yesterday, I created the title screen, the menu, and connected the menu buttons, the editor and the race to give me an idea of the final game's experience.
<br>I also added the timer when the race is being played.
<br>And it worked! My confidence is now much higher than 24 hours ago.

<br><p> <blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 14.<br><br>Today I linked the title screen (not spoiled here), the menu (with 16 puzzles/32), the editor and the race screens like that.<br><br>I&#39;m still working on enhancing the driving controls.<br>Here it&#39;s still very jerky, but you get the idea... 😁 <a href="https://t.co/JlilVWBEoH">pic.twitter.com/JlilVWBEoH</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1169709455040290823?ref_src=twsrc%5Etfw">September 5, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 

<br>
<br>Byte count: 115kb commented (or 102kb after keeping only the 16 puzzles shown in the menu)
<br>Hours count: 45
<br><a href="http://xem.github.io/js13k19/day24">DEMO</a>

<br>
<hr>
<br>

<h4>DRIVING SIMULATION</h4>
<p>Day 25: It's (more than) time to start this big part of the game: the driving simulation.
<br>I'm very afraid to get lost in a plate of spaghetti code, so I will divide that in plenty of mini-achievements, like I did for the editor.

<br>

<h4>Fix the camera</h4>
<p>1) At first (see "Day 3"), I thought CSS transitions were enough to create the angle delay between the car and the camera. 
<br>Then I realized they were broken on Webkit.
<br>Even later, I realized that it used too much CPU on Firefox, so I disabled it.
<br>Today, I replaced it with an extra "visual" angle, that is increased or decreased when we turn left or right, and returns to zero when we stop turning.
<br>This angle is added to the camera's angle, but not to the car's angle, which allows us to see the sides of the car when we turn. It's not a lot, but it's much more pleasing like that.

<p>2) Something was annoying me since I introduced the height buttons in the editor. The camera lost its alignment with the cursor.
<br>I can't ignore this problem anymore, because the camera will have to follow the car, at whatever height it is!
<br>So I tried many rewrites to my CSS3D camera function (from CSS3D framework), and I finally understood what was wrong: the "Z" position was polluted with the "rx" angle, i.e. it didn't represent a vertical offset anymore but rather, a slanted vertical offset. So I introduced a new value called "el" (elevation), that moves the camera vertically, independently of its angle.
<br>The new code looks like that:

<br><pre><code class="lang-js">C.camera = o => {
  
  // (...)
 
  // Update scene's origin (X, Y, Z-el)
  scene.style.transformOrigin = `${camX}px ${camY}px ${camZ-el}px`;
 
  // Update camera position and angle (translate X,Y,Z, then rotate RX,RY,RZ, then elevation)
  scene.style.transform = `translateX(${-camX}$px)translateY(${-camY}px)translateZ(${-camZ}px)rotateX(${camRX}deg)rotateY(${camRY}deg)rotateZ(${camRZ}deg)translateZ(${-el}px)`;
}</code></pre>


<p>img


<h4>Gravity</h4>
<p>At any moment, the game engine must know if the car is in the air or on the ground (or the road), and move the car accordingly.
<br>The car undergoes Earth-like gravity, so it will fall by default, and it will stop if it hits the ground (or the road).
<br>If the car falls on a slope, it will need to rotate accordingly in the X and Y axis... (I'll try that tomorrow).


<p><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 25.<br><br>Today I fixed all that was wrong with the camera, and started the speedometer, the fine tuning of the controls, the (3D) gravity, the slight rotation of the car in front of the camera, the new collision system...<br><br>After all that, the big challenge will be slopes! <a href="https://t.co/VusoPmF5Rx">pic.twitter.com/VusoPmF5Rx</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1170058482256687106?ref_src=twsrc%5Etfw">September 6, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 

<br>

<h4>Change the car scale</h4>
<p>Until now, the car collided pretty much everywhere because it was almost as large as the road. So I followed the example of the original game and remade the car much smaller, and placed the camera much closer to it.
<br>I also made the wheels more visible from behind.
<br>Anyway: at this scale, the road suddenly appears really big and interesting to drive through!
<br>Also, to save time and space, at this scale, it's okay to consider the car as a single point, so, for now, I'll remove both front and back collision detectors. Everything will be computed according to the center of the car, so all my schemas and code from week 1 are no longer relevant. Nevermind... 

<p>img

<br>
<br>Byte count: still 102kb (many lines of code removed in the meantime)

<br>Hours count: 47
<br><a href="http://xem.github.io/js13k19/day25">DEMO</a>

<br>
<hr>
<br>

<h4>Collisions v3</h4>

<p>Day 26: Today, let's create two different equations for every road block: one that says when the car touches the road when it falls on it from above, and another, very similar to the one we had earlier, saying if a certain point of the block is inbounds or not.
<br>For example:
<br>- a basic road block placed on the ground with no links will have a fall equation like "z = 0" and an inbounds equation "x > 0 && x &lt; 100 && y > 0 && y &lt; 100".
<br>- A slope oriented to the north will have a fall equation like "z = 50 - y / 2" (the car's Z coordinate will be compared to this value).
<br>- A rounded block will have an inbounds equation similar to the ones we saw on day 13, but inverted ("sqrt(dx,dy)<80" instead of "sqrt(dx,dy)>80").
<br>On top of that, all the barriers must provoke a collision, just like before.
<br>If the car is quitting the road, it will fall until it hits the ground (or another road block), and if it lands on the ground, it will be able to drive out-of-bounds, but slower (if it's in the snow), or without being able to turn left or right (if it's on the ice).

<h4>Slopes</h4>

<p>Slopes are very close to the collision detection (that's why I mentioned it in the previous paragraph), but one detail still needs to be solved: how to get up or down a slope with the car?
<br>The answer is three-fold:
<br>- Quick solution: as long as the car's state is "not in the air", the car moves forward or backwards as usual, and at each frame, its height is updated according to the "fall" equation of the slope.
<br>- Moreover, the car should rotate along its X and Y axis to "follow" the slope, as I said yesterday, but I'll do that later if I have enough time, as it's not a vital part of the gameplay and I'm a bit late on my schedule. (NB: I already kinda did this in this <a href="https://codepen.io/xem/pen/LWWwYX">js1k 2017 prototype</a>!)
<br>- Ultimately, I should also prevent the car from driving through the slope if it's under it...
<br>(Note from the next day: I thought I'd skip this feature because it would have been too complex but it turns out it worked instantly when I simply checked that the car could only go on the slope if it was already higher than 5px under the slope). 


<br><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 26.<br><br>It&#39;s still very drafty, but I have gravity and slopes that start working almost normally. And at 60fps.<br><br>Program for tomorrow: a lot of debug, implement checkpoints, end flag and accelerators, and some kind of momentum (we need jumps!)<a href="https://twitter.com/hashtag/screenshotsaturday?src=hash&amp;ref_src=twsrc%5Etfw">#screenshotsaturday</a> <a href="https://t.co/w41yJXfOLf">pic.twitter.com/w41yJXfOLf</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1170409341645721601?ref_src=twsrc%5Etfw">September 7, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 


<br>
<br>Byte count: 106kb

<br>Hours count: 50
<br><a href="http://xem.github.io/js13k19/day26">DEMO</a>

<br>
<hr>
<br>

<p>Day 27: I spent this sunday morning cleaning up, debugging and completing yesterday's progress with gravity, collisions and slopes;
<br>- make the slopes work on any of their four rotations
<br>- handle "long slopes" and "jumpers" the same way (only changing the angles and legths)
<br>- prevent the car from moving/turning when it's in the air
<br>- consider the car out-of-bounds if it's under a slope (and make it collide with the "under" side of the slope)
<br>- ensure that the car follows the slope uphill/downhill if it collides on a side of the slope.
<br>- etc.

<br><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 27.<br>(polishing yesterday&#39;s features)<br><br>Slopes can now block the car when it arrives from below, and have a barrier that prevents the car from passing through its base if it&#39;s not attached to a flat road block... <a href="https://twitter.com/hashtag/smallvictory?src=hash&amp;ref_src=twsrc%5Etfw">#smallvictory</a> <a href="https://t.co/7u1YY55iGV">pic.twitter.com/7u1YY55iGV</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1170597955667144704?ref_src=twsrc%5Etfw">September 8, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 
<br>

<br>And the afternoon:
<br>

<h4>Momentum</h4>
<br>The car must have an extra boost when passing on an accelerator, and jump when it arrives quickly on top of a slope or a jumper. (that's an important part of the game and the puzzles).
<br>The accelerator pushes the car forward if it's oriented like the yellow arrows, and backward otherwise.
<br>The jumps are made by including the Z offset added to the car when it goes up a slope to its vertical speed, the one that was only used for the car's gravity until now.

<br><p>The whole thing took much more time than anticipated, that's why I worked on it until nearly midnight.

<br><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 27.<br>(new stuff)<br><br>Lost a lot of time and energy in trafic today...<br><br>But I managed to make accelerators and momentum (especially, jumps) work as I want!<br><br>And debugged all the rest...<br><br>Program for tomorrow: checkpoints, end flag, score screen, medals, ice sliding,... <a href="https://t.co/kuPrxXsPZp">pic.twitter.com/kuPrxXsPZp</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1170815696575574017?ref_src=twsrc%5Etfw">September 8, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 

<br><p>Let's do a little build to <a href="https://twitter.com/MaximeEuziere/status/1170818805863464965">check the zip size...</a>

<br>
<br>Byte count: 112kb commented, 13.1kb zipped (argh), 11.8kb advzipped (oof!)

<br>Hours count: 54
<br><a href="http://xem.github.io/js13k19/day27">DEMO</a>

<br>
<hr>
<br>
<h3>Week 5</h3>


<p>Day 28: Good news! This monday morning, I checked the calendar and realized that we had actually 24 more hours than I thought until the deadline:
<br>More exactly, if we consider august 13th "day 1" of the compo, then September 13th is technically "day 32", even if both day 1 and day 32 are only half-days.

<h4>Collisions... the end?</h4>

<p>This morning I fixed many errors (and removed a lot of bad code) with the accelerators, and the collisions in general (I made them work in all possible angles and with or without slopes, and I capped the car speed if it went on an accelerator for too many frames).

<br><p>I also took a look at my minified code, it was funny to see all of it fit in a screen and have all the main parts easily recognizable!

<br><p><img src="images/js13k19/35.png">

<br><p>This evening (after work hours), I removed the hole blocks (RIP, at least for now), finished implementing the remaining "collisions", with the jumper, and the trees, and when the car falls on rock cubes or elevated curved roads. I also fixed the bugs that happened when we went past the bounds of the grid in the editor.

<br>I also finally implemented the ice layers that make the out-of-bounds car unable to change direction!

tweet











<p>Day 29: mar

<p>Day 30: mer

<p>Day 31: jeu

...
<br>
<br>
<hr>
<br>
<h3>Conclusion</h3>

<p>

<p><b>Xem</b>

</div>

</main>

</div>

<footer></footer>

<script src="../ui.js"></script>
<script>
header();
footer();
menu();
</script>

</body>
</html>