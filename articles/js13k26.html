<!doctype html>
<meta charset=utf-8>
<meta name="viewport" content="width=device-width, user-scalable=no">
<html>
<head>
<link rel=stylesheet href="../style.css?v=2024-07">
<title>Maxime Euzière</title>
<base target=_blank>
</head>
<body>

<style>
.twitter-tweet { margin: 30px 0 !important; border: 3px solid #ccc; border-radius: 30px; overflow: hidden; transform: scale(.95)}
ul { padding-left: 15px }
</style>

<div class="wrapper">

<header></header>

<div id=menu></div>

<main>

<div class=section>

<h2>JS13k 2026: </h2>
<br><h3>August-September 2026</h3>


<!--
<p><img src="images/js13k26/banner.png">

<br>
<p><h3>TL;DR</h3>
<ul>
<li>Hi! My game is playable <a href="">HERE</a>
<li>Source code is available <a href="https://github.com/xem/js13k26">HERE</a>
<li>It was ranked ...
<li>You can see a playthrough video here (spoilers!):
<br><br>
</ul>

-->

<br><hr>
<p>...TODO...
<br><hr>
<p><h3>Before the jam</h3>


<p><b>Let's prepare for a future word game! (October 2024)</b>

<p>At the end of JS13k 2025, I remembered that Senokay, the author of <a href="https://lifthrasiir.github.io/roadroller/">RoadRoller</a>, had made a 1kb typing game ("epyt") containing 1,903 english words, thanks to the magic of WOFF2's Brotli dictionnary (you can play the game and read the explanations <a href="https://js1024.fun/demos/2022/18/readme">HERE</a>), and it made me wonder if I could use that to make a word game for JS13K. Imagine a 13kb game containing a huge english dictionnary!
<p>By chance, Senokay released a standalone script that compresses any JS file into a self-extracting WOFF2 file in HTML form. And it's compatible with Firefox! (epyt is not playable on modern versions of Firefox). His script is available <a href="https://gist.github.com/lifthrasiir/1c7f9c5a421ad39c1af19a9c4f060743">HERE</a> and I made a more complete package with all the necessary data and instructions <a href="https://github.com/xem/woff2">HERE</a>.

<p>My next step was to think about which words exactly I would like to put in a 13kb game. Indeed, I quickly realized that the whole english or french dictionnary (300k+ words each) could never fit in an entry, even with the WOFF2 compressor. So I took some time to search relevant lists of words, and settled with three corpus for each language: the "10k most used words", the "official Scrabble words", and the biggest list of words I could find online. Then, I started making little compression tests on my PC. The results were quite promising, so I rolled up my sleeves and made a complete tool that generates lists of words in french and english with tons of interesting options (choose the number of letters, order words by size or alphabetically, normalize the special chars, remove compound words or words with repeated letters, txt or json output, etc): I called it <a href="https://xem.github.io/words">WORDS</a>!

<p><img src="images/js13k26/words.png" width=400>

<p><b>With this tool in hand, I could make much more tests and here's what I found:</b>
<br>1) Compressing a long list of words (for a project bigger than 1kb) is actually much more efficient with Roadroller than with WOFF2.
<br>2) The compression is much more efficient if we order the words alphabetially than if we order them by length first.
<br>3) For some reason, the compression rate is also much better if the list is in JSON instead of TXT (i.e. with the double quotes around the words).
<br>
<p><b>So with my JSON and RoadRoller in hand, I could made the tests I wanted and here are my conclusions:</b>
<br>- We can compress ALL the french and english 5-letter Scrabble words together (17,541 words, 140kb) in 15.3kb (too big for js13k). <a href="files/js13k26/1.html">DEMO</a>.
<br>- We can compress french + english 5-letter Scrabble words without repeated letters (11,074 words, 88kb) in 10.5kb (ok for js13k!). <a href="files/js13k26/2.html">DEMO</a>.
<br>- We can compress ALL the english 1- to 5-letter Scrabble words (14,915 words, 112kb) in 12.8kb (ok for js13k!). <a href="files/js13k26/3.html">DEMO</a>.
<br>- We can compress all the french 1- to 5-letter Scrabble words (11444 words, 87.3kb) in 9.8kb (ok for js13k!). <a href="files/js13k26/4.html">DEMO</a>.
<br>- We can compress all 3-10 letters english words that are both in top 10k and in the Scrabble (8,229 words, 79kb) in 12.8kb. <a href="files/js13k26/5.html">DEMO</a>.
<br>- As soon as we try to include 6 (or more) letter words, the size explodes, so they are sadly disqualified for a js13k word game.
<br>For example, the 16,706 6-letter english Scrabble words alone weigh 150kb and compress in 21kb.
<br>- The 10k most used english words (95kb) compress in 19.7kb. (or 25kb/4.9kb for the 1-5 letter words only) 
<br>- The 10k most used french words (without the compound words, 85kb) compress in 16kb. (or 12kb/3kb for the 1-5 letter words only) 
<br>- RoadRoller is kinda unpredictable: for example, compressing the french 1-5 letter words THEN the english 1-5 letter words without reloading the page in between, makes the english words compress better (about 300 bytes less, which is not negligeable when zipped!)
<!--<br>- However, this remark is for the Web version of RoadRoller.
<br>The CLI version can be used in "infinite mode" and produce outputs increasingly smaller.
<br>The command line looks like this: <mark style="background:#def;padding:4px;font:12px bold courrier,monospace">node cli.mjs -t text -a write -M 1024 -D -S 9999 -OO raw.js -o raw.min.js</mark>.
<br>For example, the 1-5 letters english Scrabble words compress in ... kb after letting the CLI run for 24 hours. <a href="files/js13k26/5.html">DEMO</a>.
-->

<p>Anyway, you can remark that in each test involving 1 to 5 letter words, amazingly, <b>each word gets compressed in under one byte</b> in average. RoadRoller and Zip are truly magical!

<p>But that's not all! I tried to save some bytes by not repeating the prefixes of consecutive words. I even <a href="https://xem.github.io/MiniPrefixRemover/">created a tool for that</a>. When I first tried it on an array of 5-letter words, the output after compression was BIGGER than if I hadn't used it. So I thiught it was not useful compared to RoadRoller and Zip alone.
<p>However, I tried to use it on words of different lengths, then I separated the consecutive words with a character that represents the different of lengths between the words, and finally I concatenated everything into a string. In that case, it does actually saved a lot of space! For example, the 3-10 letter english words present in the top 10k and in the Scrabble dictionnary (8,229 words, 79kb) now take 11.8kb. And if I put every word present in the two dictionnaries (8,332 words, 2 to 15 letters long, 82kb), it now fits into 11.2kb! <a href="files/js13k26/6.html">DEMO</a> 

<p>The compressed words look like this: <mark style="background:#def;padding:4px;font:12px bold courrier,monospace">abandoned2ilities5ty2le2original4tion3ut3ve...</mark>
<br>Which correspond to this after a little decompression: <mark style="background:#def;padding:4px;font:12px bold courrier,monospace">abandoned, abilities, ability, able, aboriginal, abortion, about, above...</mark>
<p>And I added a tool for that <a href="https://xem.github.io/MiniPrefixRemover/any.html">here</a>:

<p>So, after all this progress, I think I will probably make a 13kb word game in the future. And maybe add a french version, in a sparate entry. Even if the dictionnary uses 95%+ of the entry, the remaining space should be enough to implement my little word games. After all, I already code-golfed <a href="https://xem.github.io/MiniWordle/">a Mini Wordle in 214 bytes</a> and <a href="https://xem.github.io/spellingbee/index.html">a french spelling bee clone</a> in ~2kb.

<p>To be continued...</p>


<br><br>

<p><b>Let's prepare a 2D physics engine! (November 2024)</b>

<p>To be continued...</p>


<br><br><br><br>


<p><h3>During the jam</h3>
<p>...TODO...

<br><br><br><br>


<p><h3>Conclusion</h3>
<p>...TODO...

<br><br><br><br>


<p><b>Xem</b>
</main>

</div>

<footer></footer>

<script src="../ui.js?v=2024-07"></script>
<script>
header();
footer();
menu();
</script>
<style>
.inline, .inline * { display: inline; padding: 2px !important; }</style>
</body>
</html>